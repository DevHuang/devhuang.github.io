<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="RunLoop,NSRunLoop,CFRunLoop," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="RunLoops 是 thread 线程的底层基础.它的本质是和它的意思一样运行着的循环,更加确切的说是线程中的循环.它用来接受循环事件和安排线程的工作,并且在线程中没有工作时,让线程进入睡眠状态.">
<meta name="keywords" content="RunLoop,NSRunLoop,CFRunLoop">
<meta property="og:type" content="article">
<meta property="og:title" content="深入理解RunLoop">
<meta property="og:url" content="http://yoursite.com/2016/09/01/blog_runLoop/index.html">
<meta property="og:site_name" content="DevHuang&#39;s Blog">
<meta property="og:description" content="RunLoops 是 thread 线程的底层基础.它的本质是和它的意思一样运行着的循环,更加确切的说是线程中的循环.它用来接受循环事件和安排线程的工作,并且在线程中没有工作时,让线程进入睡眠状态.">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-396fdbacba494b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-eec7fc00562e90c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-b8aacb3f19ecbbad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-5274d3f557fba3bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-1155ae240c459fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-e34c1b942406e399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-24f3cec35bade855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-7bced44fc3e27231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-cd6b82093eba6517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1853274-3c7f49b1251d29a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-09-01T13:27:04.299Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解RunLoop">
<meta name="twitter:description" content="RunLoops 是 thread 线程的底层基础.它的本质是和它的意思一样运行着的循环,更加确切的说是线程中的循环.它用来接受循环事件和安排线程的工作,并且在线程中没有工作时,让线程进入睡眠状态.">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1853274-396fdbacba494b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/09/01/blog_runLoop/"/>





  <title>深入理解RunLoop | DevHuang's Blog</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">DevHuang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">iOS成长之路</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/09/01/blog_runLoop/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="DevHuang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/dog.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevHuang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">深入理解RunLoop</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-09-01T00:00:00+08:00">
                2016-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NSRunLoop/" itemprop="url" rel="index">
                    <span itemprop="name">NSRunLoop</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/09/01/blog_runLoop/" class="leancloud_visitors" data-flag-title="深入理解RunLoop">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>RunLoops 是 thread 线程的底层基础.它的本质是和它的意思一样运行着的循环,更加确切的说是线程中的循环.它用来接受循环事件和安排线程的工作,并且在线程中没有工作时,让线程进入睡眠状态.<br><a id="more"></a></p>
<h3 id="什么是-RunLoops"><a href="#什么是-RunLoops" class="headerlink" title="什么是 RunLoops"></a>什么是 RunLoops</h3><p>iOS的应用程序里面，程序启动后会有一个如下的main() 函数：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，在UIApplicationMain()方法里面完成了程序初始化,并设置程序的Delegate任务,而且随之开启主线程的 RunLoop,就开始接受事件处理，保持了程序的持续运行。而这个默认启动的runloop是和主线程相关的<br>总结runloop的作用：</p>
<p>(1).保证程序不退出<br>(2).负责处理各种事件（source、timer、observer）<br>(3).如果没有事件发生，会让程序进入休眠状态。这样可以节省cup资源，提高程序性能，有事做就去处理，没事做就休息</p>
<p>RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>我们可以将RunLoop 理解成为是一个循环,在里面它接受线程的输入,通过事件处理函数来处理事件.你的代码中应该提供 while or for 循环来驱动 runloop.在你的循环中,用 runloop 对象驱动事件处理相关的内容,接受事件,并做响应的处理.</p>
<p>iOS 中提供了两套API来访问和使用runloop：<br>CFRunLoopRef（CoreFoundation 框架），纯 C 函数 API，所有API都是线程安全的。<br>NSRunLoop（Foundation框架）， 是基于 CFRunLoopRef 的oc封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<h3 id="线程与runloop"><a href="#线程与runloop" class="headerlink" title="线程与runloop"></a>线程与runloop</h3><p>CFRunLoop 是基于 pthread 来管理的，而pthread和NSThread是一一对应的</p>
<p>Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分，Cocoa和CoreFundation都提供了run loop对象方便配置和管理线程的run loop（以下都已Cocoa为例）。每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。</p>
<p>主线程的runloop自动创建，子线程的runloop默认不创建。<br>runloop是不能够通过alloc init来创建。要获取runloop可以通过这两个函数CFRunLoopGetMain()和 CFRunLoopGetCurrent()来获得主线程、当前线程runloop（实质是一种懒加载）。（在NSRunloop中对应就是- mainRunloop和- currentRunloop方法）<br>可以看出来，这两个函数的内部实现看出线程和runloop是一一对应的，这种对应关系用一个字典保存起来，key是pthread，value是CFRunLoopRef：</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-396fdbacba494b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  runloop在第一次获取时创建，然后在线程结束时销毁。所以，在子线程如果不手动获取runloop，它是一直都不会有的。</p>
<h3 id="RunLoop相关分类"><a href="#RunLoop相关分类" class="headerlink" title="RunLoop相关分类"></a>RunLoop相关分类</h3><p>在 CoreFoundation 里面关于 RunLoop 有5个类:CFRunLoopRef、CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef、CFRunLoopObserverRef<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-eec7fc00562e90c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>图解:<br>(1).一个 RunLoop可以有多个Mode，每个 Mode 又包含若干个 Source/Timer/Observer。<br>(2).Source/Timer/Observer又叫mode item。不同mode下的mode item互不影响<br>(3).一个 item可被加入不同的mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，RunLoop退出。（不过如果仅仅依赖没有mode item来让runloop退出，这做法是不可靠的）</p>
<h4 id="Mode-Item"><a href="#Mode-Item" class="headerlink" title="Mode Item"></a>Mode Item</h4><p>source。CFRunLoopSourceRef事件源<br>按照官方文档CFRunLoopSourceRef为3类，但数据结构只有两类(source0、source1).</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/1853274-b8aacb3f19ecbbad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>RunLoop的输入源、时间源（基于时间的触发器，上层对应NSTimer）<br>输入分为：NSPort、自定义源、performSelector:OnThread:delay:<br>NSPort：基于端口的源:与内核端口相关。只需要简单的创建端口对象，并使用NSPort的方法将端口对象加入到run loop。端口对象会处理创建以及配置输入源。对应的是source1.<br>自定义源：自定义源：使用CFRunLoopSourceRef类型相关的函数来创建自定义输入源，比如CFRunLoopSourceCreate.<br>Selector:执行完后会自动清除出runloop（这是文档的说法，和实际测试不一样。基于端口的源不会）.</p>
<p>Selector的source分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">主线程</div><div class="line">performSelectorOnMainThread:withObject:waitUntilDone:</div><div class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</div><div class="line"></div><div class="line">指定线程</div><div class="line">performSelector:onThread:withObject:waitUntilDone:</div><div class="line">performSelector:onThread:withObject:waitUntilDone:modes:</div><div class="line"></div><div class="line">针对当前线程</div><div class="line">performSelector:withObject:afterDelay:         </div><div class="line">performSelector:withObject:afterDelay:inModes:</div><div class="line"></div><div class="line">取消，在当前线程，和上面两个方法对应</div><div class="line">cancelPreviousPerformRequestsWithTarget:</div><div class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</div></pre></td></tr></table></figure></p>
<p>总结<br>(1).对于onMainThread和onthread这两种情况，创建的是source0任务。如果调用线程和指定线程为同一线程:<br>wait参数设为YES（阻塞当前线程直到selector执行完），那么aSelector会直接在指定线程运行，不会添加到runloop。（其实就有点类似于线程死锁）<br>wait参数为NO，selector源添加到runloop且执行完不会自动清除出runloop。<br>如果调用线程和指定线程不是同一线程:selector源添加到runloop且执行完不会自动清除出runloop。<br>(2).performSelector:withObject:afterDelay则不是source0而是timer，使用是添加到runloop，执行完会自动移除出runloop。</p>
<p>剩余方法（他们是同步执行的，和线程无关，主线程子线程都可以用。不会添加到runloop，而是直接执行，相当于是[self xxx]这样调用，只不过是编译期、运行期处理的不同）:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)performSelector:(SEL)aSelector;</div><div class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</div><div class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</div></pre></td></tr></table></figure></p>
<p>对source0和source1深入理解<br>(1).source0 非基于port的：负责App内部事件，由App负责管理触发，例如UIEvent、UITouch事件。包含了一个回调，不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop)来唤醒 RunLoop，让其处理这个事件。<br>-performSelector:onThread:withObject:waitUntilDone: inModes:创建的是source0任务</p>
<p>(2).source1 基于port的：包含一个 mach_port 和一个回调，可监听系统端口和通过内核和其他线程发送的消息，能主动唤醒runloop，接收分发系统事件。</p>
<p>总结:Source1和Timer都属于端口事件源，不同的是所有的Timer都共用一个端口(Timer Port)，而每个Source1都有不同的对应端口。<br>Source0属于input Source中的一部分，Input Source还包括cuntom自定义源，由其他线程手动发出。</p>
<p>timer<br>CFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer。在预设的时间点唤醒runloop执行回调。因为它是基于RunLoop的，因此它不是实时的（就是NSTimer 是不准确的。 因为RunLoop只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次）。</p>
<p>observer<br>CFRunLoopObserverRef观察者，监听runloop的状态。通过回调接收状态变化。它不属于runloop的事件源。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">  kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</div><div class="line">  kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</div><div class="line">  kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</div><div class="line">  kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</div><div class="line">  kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</div><div class="line">  kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Mode 暴露的管理 mode item 的接口分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure></p>
<h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>CFRunLoopModeRef。每次启动RunLoop时，只能指定其中一个 Mode，这个就是CurrentMode。要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。<br>数据结构如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;   //must have the run loop locked before locking this</div><div class="line">//mode名</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">//source0 源</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">//source1 源</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">//observer 源</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">//timer 源</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line"></div><div class="line">//mach port 到 mode的映射,为了在runloop主逻辑中过滤runloop自己的port消息。</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line"></div><div class="line">//记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">//使用 mk timer， 用到的mach port，和source1类似，都依赖于mach port</div><div class="line">    mach_port_t _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">//timer触发的理想时间</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">//timer触发的实际时间，理想时间加上tolerance（偏差）</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>系统默认注册了5个mode，以下两个是比较常用的：<br>1.kCFRunLoopDefaultMode （NSDefaultRunLoopMode），默认模式<br>2.UITrackingRunLoopMode， scrollview滑动时就是处于这个模式下。保证界面滑动时不受其他mode影响</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</div><div class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</div></pre></td></tr></table></figure></p>
<p>对于传入的 mode name 如果runLoop 内部没有对应 mode 时，runLoop会自动创建对应的 CFRunLoopModeRef。mode只能添加不能删除</p>
<p>kCFRunLoopCommonModes（NSRunLoopCommonModes）<br>它是一个占位用的mode，它不是真正意义上的mode。<br>如果要在线程中开启runloop，这样写是不对的：[[NSRunLoop currentRunLoop] runMode:NSRunLoopCommonModes beforeDate:[NSDate distantFuture]];<br>CFRunLoop中有关CommonMode的结构:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFMutableSetRef _commonModes;     // Set</div><div class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</div><div class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</div><div class="line">    CFMutableSetRef _modes;           // Set</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>小结:<br>1.关于mode：一个mode可以标记为common属性（用CFRunLoopAddCommonMode函数），然后它就会保存在_commonModes。主线程已有的两个modekCFRunLoopDefaultMode 和 UITrackingRunLoopMode 都已经是CommonModes了。<br>2.关于item：_commonModeItems里面存放的source, observer, timer等，在每次runLoop运行的时候都会被同步到具有Common标记的Modes里。比如这样：[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];就是把timer放到commonItem里</p>
<h3 id="runloop的实现"><a href="#runloop的实现" class="headerlink" title="runloop的实现"></a>runloop的实现</h3><p>直接上源码吧!<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;    </div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    //根据mode name找到对应的mode</div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">    //如果mode里没有source/timer/observer,直接返回。</div><div class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">    Boolean did = false;</div><div class="line">    if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    int32_t result = kCFRunLoopRunFinished;</div><div class="line"></div><div class="line">    //1.通知 Observers:即将进入runloop。</div><div class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">    //内部函数，进入loop</div><div class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">    //10.通知 Observers:RunLoop 即将退出。</div><div class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line"></div><div class="line">        __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">    rl-&gt;_currentMode = previousMode;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div></pre></td><td class="code"><pre><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    uint64_t startTSR = mach_absolute_time();//获取系统启动之后 的内核时间</div><div class="line"></div><div class="line">    //如果当前runLoop或者runLoopMode为停止状态的话直接返回</div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">    return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">    rlm-&gt;_stopped = false;</div><div class="line">    return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;//用来保存主队列（mainQueue）的端口。mach端口--线程之间通信</div><div class="line">    //判断当前线程是否主线程（当前runloop是否主线程runloop），如果是就分发一个队列调度端口</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    // 只有在MainRunLoop，才会有下面这行赋值，否则 dispatchPort 为NULL</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name))</div><div class="line">        dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line"></div><div class="line"></div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    //给当前mode分发队列端口</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    //gcd有关的东西，实现runloop超时管理。</div><div class="line">    /*</div><div class="line">     struct __timeout_context &#123;</div><div class="line">     dispatch_source_t ds;</div><div class="line">     CFRunLoopRef rl;//runloop</div><div class="line">     uint64_t termTSR;//超时时间点？</div><div class="line">     &#125;;</div><div class="line">     */</div><div class="line">    //对gcd的一些api不是很熟悉，但大概看懂是主要通过dispatch_source_t创建计时器；精度很高，系统自动触发，是系统级别的源</div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));//超时上下文</div><div class="line">    if (seconds &lt;= 0.0) &#123; //seconds：设置的runloop超时时间</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;//设置的超时时间在最大限制内，才创建timeout_timer</div><div class="line">        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</div><div class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">        timeout_context-&gt;ds = timeout_timer;</div><div class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">        dispatch_set_context(timeout_timer, timeout_context); //绑定// source gets ownership of context</div><div class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout 超时时间无穷尽</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">        uint8_t msg_buffer[3 * 1024];</div><div class="line">        mach_msg_header_t *msg = NULL;</div><div class="line">        mach_port_t livePort = MACH_PORT_NULL;</div><div class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;//_portSet：记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</div><div class="line"></div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);//不忽略端口唤醒</div><div class="line">        //2. 通知Observers:通知即将处理timer</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        //3. 通知Observers:通知即将处理Source0(非port)。</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line"></div><div class="line">        //处理加入到runLoop中的block。（非延迟的主线程？）</div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        //4.处理source0事件</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        //处理block</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //poll标志着有没有处理source0的消息，如果没有则为false，反之为true</div><div class="line">        //poll=NO的情况：没有source0且超时时间!=0</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);//(后一条件似乎是必然为false的)</div><div class="line"></div><div class="line">        //主线程runloop 端口存在、didDispatchPortLastTime为假（首次执行不会进入判断，因为didDispatchPortLastTime为true）</div><div class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //__CFRunLoopServiceMachPort用于接受指定端口(一个也可以是多个)的消息,最后一个参数代表当端口无消息的时候是否休眠,0是立刻返回不休眠,TIMEOUT_INFINITY代表休眠</div><div class="line">            //处理通过GCD派发到主线程的任务,这些任务优先级最高会被最先处理</div><div class="line">            //5.如果有Source1，就直接跳转去处理消息。（文档说是检测source1，不过源码看来是检测dispatchPort---gcd端口事件）</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123;</div><div class="line">                goto handle_msg;//如果端口有事件则跳转至handle_msg</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        didDispatchPortLastTime = false;</div><div class="line"></div><div class="line">        //之前没有处理过source0，也没有source1消息，就让线程进入睡眠。</div><div class="line">        //6.通知 Observers: RunLoop 的线程即将进入休眠</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting))</div><div class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">        // 标志当前runLoop为休眠状态</div><div class="line">        __CFRunLoopSetSleeping(rl);</div><div class="line"></div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line"></div><div class="line">        __CFRunLoopModeUnlock(rlm);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        //  进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop</div><div class="line">        do &#123;</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                objc_clear_stack(0);</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</div><div class="line">            /// • 一个基于 port 的Source 的事件。</div><div class="line">            /// • 一个 Timer 到时间了</div><div class="line">            /// • RunLoop 自身的超时时间到了</div><div class="line">            /// • 被其他什么调用者手动唤醒</div><div class="line"></div><div class="line">            //如果poll为no，且waitset中无port有消息,线程进入休眠；否则唤醒</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">            //livePort是modeQueuePort，则代表为当前mode队列的端口</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                //不太懂</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                //知道Timer被激活了才跳出二级循环继续循环一级循环</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            //如果livePort不为modeQueuePort，runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口。</div><div class="line">            else &#123;</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            objc_clear_stack(0);</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">#endif</div><div class="line"></div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        //忽略端口唤醒</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">        // user callouts now OK again</div><div class="line">        __CFRunLoopUnsetSleeping(rl);</div><div class="line">        //8.通知 Observers:RunLoop的线程刚刚被唤醒了。</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line">        //处理端口消息</div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);//设置此时runLoop忽略端口唤醒（保证线程安全）</div><div class="line"></div><div class="line"></div><div class="line">        // 9.处理待处理的事件</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;//什么都不做（超时或..?</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125;</div><div class="line">        //struct __CFRunLoop中有这么一项：__CFPort _wakeUpPort，用于手动将当前runloop线程唤醒，通过调用CFRunLoopWakeUp完成，CFRunLoopWakeUp会向_wakeUpPort发送一条消息</div><div class="line">        else if (livePort == rl-&gt;_wakeUpPort) &#123;//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();//唤醒</div><div class="line">            // do nothing on Mac OS</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer, because we apparently fired early</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        //处理因timer的唤醒。9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line"></div><div class="line">            //9.2处理异步方法唤醒。处理gcd dispatch到main_queue的block，执行block。</div><div class="line">            /*有判断是否是在MainRunLoop，有获取Main_Queue 的port，并且有调用 Main_Queue 上的回调，这只能是是 GCD 主队列上的异步任务。即：dispatch_async(dispatch_get_main_queue(), block)产生的任务。</div><div class="line">             */</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">             sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 9.3处理Source1 (基于port)</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            // Despite the name, this works for windows handles as well</div><div class="line">            //过滤macPort消息，有一些消息不一定是runloop中注册的，这里只处理runloop中注册的消息，在rlm-&gt;_portToV1SourceMap通过macPort找有没有对应的runloopMode</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            if (rls) &#123;</div><div class="line">                mach_msg_header_t *reply = NULL;</div><div class="line">                // 处理Source1</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">                if (NULL != reply) &#123;</div><div class="line">                    //当前线程处理完source1，给发消息的线程反馈消息</div><div class="line">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">#endif</div><div class="line">        //block处理</div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line"></div><div class="line">        // 进入loop时参数说处理完事件就返回。</div><div class="line">    if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">        retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125;</div><div class="line">        // 超出传入参数标记的超时时间了</div><div class="line">    else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">    &#125;</div><div class="line">        // 被外部调用者强制停止了</div><div class="line">    else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">        retVal = kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">        rlm-&gt;_stopped = false;</div><div class="line">        retVal = kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">        // source/timer/observer一个都没有了</div><div class="line">    else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">        retVal = kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">        // 如果没超时，mode里没空，loop也没被停止，那继续loop。</div><div class="line">    &#125; while (0 == retVal);</div><div class="line"></div><div class="line">    //释放定时器</div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>函数内部主要做了一个do-while循环，线程一直处于 “等待消息-&gt;接受-&gt;处理” 的循环中，直到这个循环结束。<br>对上面的源码做个归纳 就是以下10点:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-5274d3f557fba3bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>整体流程如下:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-1155ae240c459fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  主线程runloop会处理gcd端口事件源。</p>
<h3 id="关于runloop的休眠与唤醒"><a href="#关于runloop的休眠与唤醒" class="headerlink" title="关于runloop的休眠与唤醒"></a>关于runloop的休眠与唤醒</h3><p>对于runloop而言最核心的事情就是保证线程在没有消息的时候休眠，在有消息时唤醒，以提高程序性能。runloop这个机制是依靠系统内核来完成的（苹果操作系统核心组件Darwin中的Mach）。</p>
<p>Mach提供了诸如处理器调度、IPC (进程间通信)等基础服务。在 Mach 中，进程、线程和虚拟内存都被称为”对象”。Mach 的对象间只能通过消息传递的方式实现对象间的通信。消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>Runloop本质：mach_msg()<br>Runloop通过mach_msg()函数接收、发送消息。它的本质是调用函数mach_msg_trap()，相当于是一个系统调用，会触发内核状态切换。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作。</p>
<p>如图所示:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-e34c1b942406e399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"><br>  runloop用mach_msg()这个函数去接收消息，如果没有内核发送port 消息过来，内核会将线程置于等待状态 mach_msg_trap() (当前线程阻塞)。如果有消息返回（内核开新线程返回消息），判断消息类型处理事件，并通过modeItem的callback回调。(总结：基于port的source1，监听端口，端口有消息，触发回调；而source0，要手动标记为待处理和手动唤醒runloop)</p>
<p>  正如runloop源码里的第7步一样<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//  进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop</div><div class="line">do &#123;</div><div class="line">  if (kCFUseCollectableAllocator) &#123;</div><div class="line">      objc_clear_stack(0);</div><div class="line">      memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">  &#125;</div><div class="line">  msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">  //7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</div><div class="line">  /// • 一个基于 port 的Source 的事件。</div><div class="line">  /// • 一个 Timer 到时间了</div><div class="line">  /// • RunLoop 自身的超时时间到了</div><div class="line">  /// • 被其他什么调用者手动唤醒</div><div class="line"></div><div class="line">  //如果poll为no，且waitset中无port有消息,线程进入休眠；否则唤醒</div><div class="line">  __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">  //livePort是modeQueuePort，则代表为当前mode队列的端口</div><div class="line">  if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">      //不太懂</div><div class="line">      while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">      //知道Timer被激活了才跳出二级循环继续循环一级循环</div><div class="line">      if (rlm-&gt;_timerFired) &#123;</div><div class="line">          rlm-&gt;_timerFired = false;</div><div class="line">          break;</div><div class="line">      &#125; else &#123;</div><div class="line">          if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  //如果livePort不为modeQueuePort，runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口。</div><div class="line">  else &#123;</div><div class="line">      // Go ahead and leave the inner loop.</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line">&#125; while (1);</div></pre></td></tr></table></figure></p>
<p>runloop的休眠状态也是一个do-while循环。其中的核心处理函数__CFRunLoopServiceMachPort：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//真正让runloop休眠的地方</div><div class="line">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) &#123;</div><div class="line">    Boolean originalBuffer = true;</div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    for (;;) &#123;        /* In that sleep of death what nightmares may come ... */</div><div class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = 0;</div><div class="line">        msg-&gt;msgh_local_port = port;</div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class="line">        msg-&gt;msgh_size = buffer_size;</div><div class="line">        msg-&gt;msgh_id = 0;</div><div class="line">        //根据timerout参数的值来判断是让runloop 休眠还是继续查询（poll）</div><div class="line">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        //调用mach_msg()函数接收消息</div><div class="line">        ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class="line">        CFRUNLOOP_WAKEUP(ret);//唤醒</div><div class="line">        if (MACH_MSG_SUCCESS == ret) &#123;//成功获取到消息</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TIMED_OUT == ret) &#123;//获取消息超时</div><div class="line">            if (!originalBuffer) free(msg);</div><div class="line">            *buffer = NULL;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        if (originalBuffer) *buffer = NULL;</div><div class="line">        originalBuffer = false;</div><div class="line">        *buffer = realloc(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>__CFRunLoopServiceMachPort用于接受指定端口(一个也可以是多个)的消息，最后一个参数代表当端口无消息的时候是否休眠，0是立刻返回不休眠，TIMEOUT_INFINITY代表休眠。<br>然后调用mach_msg()函数接收消息（如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap()，所以来到这里，runloop如果没事做就休眠了），根据接收消息的结果对livePort进行赋值，一种是成功获取到消息后，会根据情况赋值为msg-&gt;msgh_local_port或者MACH_PORT_NULL，而另一种获取消息超时的情况会赋值为MACH_PORT_NULL。</p>
<p>如果livePort不是modeQueuePort那么就是唤醒runloop的消息端口或者MACH_PORT_NULL。</p>
<p>接着来到第九步，就会看到对livePort不同情况的处理了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">if (MACH_PORT_NULL == livePort) &#123;//什么都不做（超时或..?</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125;</div><div class="line">        //struct __CFRunLoop中有这么一项：__CFPort _wakeUpPort，用于手动将当前runloop线程唤醒，通过调用CFRunLoopWakeUp完成，CFRunLoopWakeUp会向_wakeUpPort发送一条消息</div><div class="line">        else if (livePort == rl-&gt;_wakeUpPort) &#123;//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();//唤醒</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        //处理因timer的唤醒。9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            //9.2处理异步方法唤醒。处理gcd dispatch到main_queue的block，执行block。</div><div class="line">        &#125; else &#123;</div><div class="line">            // 9.3处理Source1 (基于port)</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            ......</div><div class="line">            if (rls) &#123;</div><div class="line">                __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">                ......</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<h3 id="runloop的CallOut"><a href="#runloop的CallOut" class="headerlink" title="runloop的CallOut"></a>runloop的CallOut</h3><p>runloop的回调，一般都是通过一个名字很长的函数，比如下面六个：打断点调试的时候可以在调用栈中看到他们的身影<br>(换句话说你的代码其实最终都是通过下面几个函数来负责调用的，即使你自己监听Observer也会先调用下面的函数然后间接通知你)：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</div><div class="line">    static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</div></pre></td></tr></table></figure></p>
<h3 id="runloop退出的条件"><a href="#runloop退出的条件" class="headerlink" title="runloop退出的条件"></a>runloop退出的条件</h3><p>一次性执行；app退出；线程关闭；设置最大时间到期；modeItem为空（实际上observer不算是源，所以就算有observer也是会返回的）；</p>
<h3 id="runloop的使用"><a href="#runloop的使用" class="headerlink" title="runloop的使用"></a>runloop的使用</h3><h4 id="开启和关闭的接口"><a href="#开启和关闭的接口" class="headerlink" title="开启和关闭的接口"></a>开启和关闭的接口</h4><p>CFRunLoopRef（CoreFoundation 框架）<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//运行 CFRunLoopRef</div><div class="line">void CFRunLoopRun();</div><div class="line">//运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因</div><div class="line">SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);</div><div class="line">//停止运行 CFRunLoopRef</div><div class="line">void CFRunLoopStop( CFRunLoopRef rl );</div></pre></td></tr></table></figure></p>
<pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopRun(void) &#123;    /* DOES CALLOUT */</div><div class="line">    int32_t result;</div><div class="line">    do &#123;</div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

运行在NSDefaultRunLoopMode模式下。直到调用CFRunLoopStop()强制停止（kCFRunLoopRunStopped）或者source/timer/一个都没有了（kCFRunLoopRunFinished）。即源码int32_t __CFRunLoopRun()（就是之前上面那个几百行的）中的：
</code></pre><p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-24f3cec35bade855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</div><div class="line">  CHECK_FOR_FORK();</div><div class="line">  return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>  总结：<br>  (1).参数。第一个：runloop运行模式。第二个：运行时间（超时时间）。第三个：是否在处理完source(source0\source1)之后让runloop退出返回。<br>  (2).接下来要讲的NSRunloop中的两个接口：- (void)runUntilDate:(NSDate <em>)limitDate;和- (BOOL)runMode:(NSString </em>)mode beforeDate:(NSDate *)limitDate;是基于这和函数进行封装的（猜测）。<br>  (3).源码上看，和上一个函数一样，都用到CFRunLoopRunSpecific()所以最终都是调用int32_t __CFRunLoopRun()。因此也即能用CFRunLoopStop()来退出runloop。<br>  (4).返回值。是导致runloop退出的原因<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">kCFRunLoopRunFinished = 1,</div><div class="line">kCFRunLoopRunStopped = 2,</div><div class="line">kCFRunLoopRunTimedOut = 3,</div><div class="line">kCFRunLoopRunHandledSource = 4</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopStop( CFRunLoopRef rl );(用于停掉由上面两个函数启动的runloop。)</div></pre></td></tr></table></figure>
</code></pre><h4 id="NSRunloop（Foundation框架）"><a href="#NSRunloop（Foundation框架）" class="headerlink" title="NSRunloop（Foundation框架）"></a>NSRunloop（Foundation框架）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制</div><div class="line">- (void)run;</div><div class="line">//运行模式为默认的NSDefaultRunLoopMode模式 ，参数为运时间期限</div><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div><div class="line">//对runloop运行模式、时间期限可以自行设置</div><div class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure>
</code></pre><p>  关于<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)run;</div></pre></td></tr></table></figure></p>
<p>  (1).循环一旦开启，就关闭不了，并且之后的代码就无法执行。api文档中提到：如果没有输入源和定时源加入到runloop中，runloop就马上退出，否则通过频繁调用-runMode:beforeDate:方法来让runloop运行在NSDefaultRunLoopMode模式下。<br>  但是！人为地移除输入源、timer不能保证runloop会退出，因为系统有可能会自己添加一些源来处理事件。（下面两种方法也是）<br>  (2).无法用CFRunLoopStop(runloopRef)退出，这种方式启动的runloop不利于控制，不建议使用</p>
<p>  关于<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure></p>
<p>  (1).运行在NSDefaultRunLoopMode模式，有超时时间限制。它实际上也是不断调用-runMode:beforeDate:方法来让runloop运行在NSDefaultRunLoopMode模式下，直到到达超时时间。<br>  (2).调用CFRunLoopStop(runloopRef)无法停止Run Loop的运行。为什么呢..因为这个方法只会结束当前-runMode:beforeDate:的调用，之后的-runMode:beforeDate:该调用的还是会继续。。。直到timeout。<br>  (3).对应CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)</p>
<p>  关于<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure></p>
<p>  (1).相比上一种方法可以指定运行模式。<br>  (2).对应CFRunLoopRunInMode(mode,limiteDate,true)方法,只执行一次，执行完就退出。<br>  (3).可以用CFRunLoopStop(runloopRef)退出runloop。<br>  (4).api文档里面提到：在第一个input source（非timer）被处理或到达limitDate之后runloop退出</p>
<p>  下面看一个例子<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  - (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  self.view.backgroundColor = [UIColor whiteColor];</div><div class="line"></div><div class="line">  UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 80, 50, 50)];</div><div class="line">  btn.backgroundColor = [UIColor redColor];</div><div class="line">  [self.view addSubview:btn];</div><div class="line">  [btn addTarget:self action:@selector(clicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line"></div><div class="line">  NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(threadMethod) object:nil];</div><div class="line">  self.thread = thread;</div><div class="line">  [self.thread start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)threadMethod&#123;</div><div class="line">  @autoreleasepool &#123;   </div><div class="line">      [[NSRunLoop currentRunLoop]addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">      [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">      NSLog(@&quot;thread end&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)clicked&#123;</div><div class="line">  [self performSelector:@selector(doSomething) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)doSomething&#123;</div><div class="line">  NSLog(@&quot;doSomething&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  分别在控制台打印出doSomething和thread end<br>  给runloop添加源[NSMachPort port]保活，执行完perform selector（重温一下，这里会给runloop添加一个源） runloop就退出了。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">这里可以从源码上解释一下：</div><div class="line">回顾上面那几百行的源码，我们可以看到其实这个runloop 的do-while循环是由一个变量retVal的值来控制的，也即代码的最后几行：</div><div class="line"></div><div class="line">// 进入loop时参数说处理完事件就返回。</div><div class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">    retVal = kCFRunLoopRunHandledSource;</div><div class="line">    &#125;</div><div class="line">    // 超出传入参数标记的超时时间了</div><div class="line">else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">        retVal = kCFRunLoopRunTimedOut;</div><div class="line">&#125;</div><div class="line">    // 被外部调用者强制停止了</div><div class="line">else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">    retVal = kCFRunLoopRunStopped;</div><div class="line">&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">    rlm-&gt;_stopped = false;</div><div class="line">    retVal = kCFRunLoopRunStopped;</div><div class="line">&#125;</div><div class="line">    // source/timer/observer一个都没有了</div><div class="line">else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">    retVal = kCFRunLoopRunFinished;</div><div class="line">&#125;</div><div class="line">    // 如果没超时，mode里没空，loop也没被停止，那继续loop。</div><div class="line">&#125; while (0 == retVal);</div></pre></td></tr></table></figure></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;，对应CFRunLoopRunInMode(mode,limiteDate,true)。因此</div></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">  retVal = kCFRunLoopRunHandledSource;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</code></pre><p>  中的stopAfterHandle值就是true。由于这里的perform源是source0，因此也即：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//4.处理source0事件</div><div class="line">    Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div></pre></td></tr></table></figure></p>
<p>  sourceHandledThisLoop在这里赋值为true。<br>  如果是source1源也是同理分析，所以在第一个input source被处理之后runloop退出。</p>
<h3 id="基本的常见问题"><a href="#基本的常见问题" class="headerlink" title="基本的常见问题"></a>基本的常见问题</h3><p>  基本使用三步骤<br>  添加事件到runloop中：1.创建事件（源） 2.指定该事件（源）在runloop中的运行模式，并加入到runloop中 3.在与runloop的模式匹配时，事件（源）运行</p>
<h4 id="ModeItem要在对应的Mode下才会被runloop处理"><a href="#ModeItem要在对应的Mode下才会被runloop处理" class="headerlink" title="ModeItem要在对应的Mode下才会被runloop处理"></a>ModeItem要在对应的Mode下才会被runloop处理</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  主线程中执行以下代码：</div><div class="line">  - (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //创建timer</div><div class="line">    //参数1：间隔时间   参数2：对象   参数3：方法   参数4：自定义   参数5：是否重复执行</div><div class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(task) userInfo:nil repeats:YES];</div><div class="line">    //把定时源加入到当前线程下的消息循环中</div><div class="line">    [[NSRunLoop currentRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"> - (void)task&#123;</div><div class="line">   // 输出当前循环模式</div><div class="line">    NSLog(@&quot;%@&quot;,[[NSRunLoop currentRunLoop]currentMode]);</div><div class="line">    NSLog(@&quot;task is running&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>  设置timer在NSDefaultRunLoopMode模式下运行。一开始什么也不做，timer正常运行；当对屏幕界面进行滚动时，timer停止运行。这是因为：没有拖动界面时是kCFRunLoopDefaultMode，拖动界面则是UITrackingRunLoopMode模式，与设置的模式不匹配所以无法运行。</p>
<p>如果需要在两个 Mode 中都能得到运行，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一个方法，就是将 Timer 加入到顶层的 RunLoop 的 commonItem中，在每次runLoop运行的时候都会被同步到具有Common标记的Modes里。<br>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</p>
<p>ps:[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];就相当于：上面viewDidLoad里面的两句代码，自动添加到当前runloop且在default mode模式下。如果要修改模式，调用一次addTimer:forMode:方法就可以了[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</p>
<h4 id="子线程的runloop要手动开启"><a href="#子线程的runloop要手动开启" class="headerlink" title="子线程的runloop要手动开启"></a>子线程的runloop要手动开启</h4><p>  往指定线程的runloop中加入源：performSelector…<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  //创建子线程</div><div class="line">  NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(task2) object:nil];</div><div class="line">  [thread start];</div><div class="line">  //往指定线程的消息循环中加入源</div><div class="line">  //参数1:方法   参数2:指定线程   参数3:对象   参数4:等待方法执行完成</div><div class="line">  [self performSelector:@selector(addtask) onThread:thread withObject:nil waitUntilDone:NO];</div><div class="line">  &#125;</div><div class="line">  -(void)task2&#123;</div><div class="line">  NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">  &#125;</div><div class="line">  -(void)addtask&#123;</div><div class="line">  NSLog(@&quot;addtask is running&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  performSelector中的方法addtask不会执行，因为线程的方法瞬间就执行完了，线程就结束被回收了而且线程也不会监听是否有方法继续交给它执行。<br>每个线程有自己的runLoop, 我们可以通过[NSRunLoop currentRunLoop]或CFRunLoopGetCurrent()来获取。 不过只有主线程的runLoop是默认启动的，其他线程的runloop就需要我们手动启动。</p>
<p>  需要在子线程中开启runloop：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  - (void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">//方式一</div><div class="line">//    [[NSRunLoop currentRunLoop]run];</div><div class="line">//    NSLog(@&quot;over&quot;);//不会打印，因为一直在循环，没有退出</div><div class="line">//方式二</div><div class="line">//    [[NSRunLoop currentRunLoop]runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];</div><div class="line">//    NSLog(@&quot;over&quot;);    </div><div class="line">//方式三，apple推荐</div><div class="line">//    BOOL shouldKeepRunning = YES;        // global</div><div class="line">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">    while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);//通过全局变量控制runloop的开关</div><div class="line">    NSLog(@&quot;over&quot;);//这句不会执行</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  打印结果如下<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-7bced44fc3e27231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  如果想runloop可以终止的，官方推荐：- (BOOL)runMode:(NSString <em>)mode beforeDate:(NSDate </em>)limitDate;官方example:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BOOL shouldKeepRunning = YES;        //全局变量</div><div class="line">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div></pre></td></tr></table></figure></p>
<p>  通过全局变量控制runloop的开关。</p>
<h4 id="要给runloop添加modeItem，否则runloop退出"><a href="#要给runloop添加modeItem，否则runloop退出" class="headerlink" title="要给runloop添加modeItem，否则runloop退出"></a>要给runloop添加modeItem，否则runloop退出</h4><p>  如果mode中一个item都没有，runloop退出。下面稍微修改一下上面2的代码：把performSelector方法放到touchesBegan中<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  - (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //创建子线程</div><div class="line">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(task2) object:nil];</div><div class="line">    [self.thread start];</div><div class="line">    //往指定线程的消息循环中加入源</div><div class="line">    //参数1:方法   参数2:指定线程   参数3:对象   参数4:等待方法执行完成</div><div class="line">//    [self performSelector:@selector(addtask) onThread:thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">-(void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">//    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    while (YES &amp;&amp; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class="line">    NSLog(@&quot;over&quot;);</div><div class="line">&#125;</div><div class="line">-(void)addtask&#123;</div><div class="line">    NSLog(@&quot;addtask is running&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    [self performSelector:@selector(addtask) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-cd6b82093eba6517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  运行，”over”被打印出来了，证明runloop退出。点击屏幕，addtask方法没有执行。<br>  这个方法创建Source 0 任务，并分发到指定线程的 RunLoop 中。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector</div><div class="line">             onThread:(NSThread *)thr</div><div class="line">           withObject:(id)arg</div><div class="line">        waitUntilDone:(BOOL)wait</div><div class="line">                modes:(NSArray *)array;</div></pre></td></tr></table></figure></p>
<p>  那为什么和代码修改前的运行结果不一样？个人理解是这样的，2.中在子线程runloop开启前就已经添加了source0事件源了。而现在修改后的代码，把事件源的添加分离开来了，先开了子线程，而等到用户点击屏幕的时候才会添加事件源；对于子线程，runloop虽然创建并且开启了，但是因为一直没有mode item，因此runloop马上就退出了。</p>
<p>那怎么解决？一种简单粗暴的方法，在runloop开启之前给它加个mode item咯：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">//加个端口的源</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    while (YES &amp;&amp; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class="line">    NSLog(@&quot;over&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  如果这样子改：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  -(void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">    while (1) &#123;</div><div class="line">        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  在运行上来讲是没问题的，用户点击屏幕的时候addtask方法会执行。不过，runloop一开始没有modeitem的问题还是存在的，这导致在while循环里面runloop不断创建、启动、退出，直到点击屏幕有事件源添加进来为止。</p>
<p>  提示:当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<h4 id="observer设置监听runloop状态"><a href="#observer设置监听runloop状态" class="headerlink" title="observer设置监听runloop状态"></a>observer设置监听runloop状态</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 创建observer</div><div class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class="line">      NSLog(@&quot;----监听到RunLoop状态发生改变---%zd&quot;, activity);</div><div class="line">  &#125;);</div><div class="line">  // 添加观察者：监听RunLoop的状态</div><div class="line">  CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);   </div><div class="line">  // 释放Observer</div><div class="line">  CFRelease(observer);</div></pre></td></tr></table></figure>
</code></pre><p>  创建observer，用CFRunLoopObserverCreateWithHandler函数，参数1：分配内存 参数2：要监听哪个runloop状态的标记 参数3：是否重复。这个observer是只调用一次还是runloop每次循环都调 参数4：优先级，一般传0 参数5：回调</p>
<h4 id="CF的内存管理"><a href="#CF的内存管理" class="headerlink" title="CF的内存管理"></a>CF的内存管理</h4><p>  (1).凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release<br>  (2).runloop先唤醒，然后处理各种事件（包括点击事件），最后又回到休眠状态</p>
<h4 id="autoreleasepool自动释放池在什么时候释放"><a href="#autoreleasepool自动释放池在什么时候释放" class="headerlink" title="autoreleasepool自动释放池在什么时候释放"></a>autoreleasepool自动释放池在什么时候释放</h4><p>  MRC环境下:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Person.h</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">+ (instancetype)personInitWithName:(NSString *)name;</div><div class="line">@end</div><div class="line"></div><div class="line">Person.m</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">+ (instancetype)personInitWithName:(NSString *)name&#123;</div><div class="line">//MRC内存管理原则：谁创建谁释放</div><div class="line">  Person *person = [[[Person alloc]init]autorelease];//自动释放池 延时释放</div><div class="line">  person.name = name;</div><div class="line">  return person;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">vc.m</div><div class="line">#import &quot;Person.h&quot;</div><div class="line">@property (nonatomic ,assign)Person *person1;</div><div class="line">- (void)viewDidLoad&#123;</div><div class="line">  ........</div><div class="line">  self.person1 = [Person personInitWithName:@&quot;name1&quot;];</div><div class="line">  NSLog(@&quot;%@&quot;,self.person1.name);</div><div class="line">&#125;</div><div class="line">- (IBAction)clicked:(id)sender &#123;</div><div class="line">  NSLog(@&quot;person.name:%@&quot;,self.person1.name);//MRC下点击按钮后报野指针错误</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  MRC内存管理原则：谁创建谁释放。代码中使用autorelease来对person对象进行释放。自动释放池释放时，对池内所有对象都发送一次release，person对象被释放。</p>
<p>  运行结果：在点击完按钮之后报野指针错误，即对象已经被释放掉了。对此，可以从对象释放反推出自动释放池已经被释放了。那为什么会在这个时候释放？<br>  直接上图:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-3c7f49b1251d29a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  iPhone应用程序运行-&gt;有触摸事件-&gt;cocoaTouch创建事件，生成事件对象-&gt;cocoaTouch创建自动释放池-&gt;应用处理事件（就是一些我们自己写的代码，并有可能产生一些中间、临时对象，这些对象放在自动释放池中）-&gt;事件处理完毕自动释放池释放<br>  官方文档：The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. 在主线程事件循环开始的时候创建了自动释放池,在事件循环结束的时候释放自动释放池，因此在处理事件过程中产生的一些自动释放的对象会被释放掉</p>
<p>  实际上,苹果在主线程 RunLoop 里注册了两个 Observer。第一个 Observer 监视的事件是即将进入Loop，其优先级最高，保证创建释放池发生在其他所有回调之前。<br>  第二个 Observer 监视了两个事件：准备进入休眠时 释放旧的池并创建新池；即将退出Loop时释放自动释放池。优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>  代码中，viewDidLoad的代码执行完runloop就要进入休眠了，这时候先释放旧池并把person对象释放。点击事件把runloop唤醒，之后再新池里访问释放掉的对象就报野指针错误了。</p>
<p>  提示:<br>  在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<p>  什么时候使用自动释放池？<br>  开启子线程的时候要自己创建自动释放池，否则可能会发生内存泄露。<br>  使用 NSThread 做多线程开发时,需要在线程调度方法中手动添加自动释放池。比如：<br>  MRC环境下: 采用 __block<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(execute) object:nil];</div><div class="line">[thread start];</div><div class="line">......</div><div class="line">- (void)execute&#123;</div><div class="line">  @autoreleasepool&#123;</div><div class="line">      NSTimer *timer ...</div><div class="line">      [[NSRunLoop currentRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode];</div><div class="line">      [[NSRunLoop currentRunLoop]run];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  循环中创建了许多临时对象，在循环里面使用自动释放池，用来减少高内存占用。举例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  for (int i = 0; i &lt; largeNumber; ++i) &#123;</div><div class="line">  NSString *str = @&quot;Hello World&quot;;</div><div class="line">  str = [str stringByAppendingFormat:@&quot; - %d&quot;, i];</div><div class="line">  str = [str uppercaseString];</div><div class="line">  NSLog(@&quot;%@&quot;, str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  运行这段代码，将会看到内存占用情况一直在增长，因为循环中的临时对象没有被释放掉。<br>  改进：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  for (int i = 0; i &lt; largeNumber; ++i) &#123;</div><div class="line">  @autoreleasepool&#123;</div><div class="line">  ......要执行的代码</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  RunLoop 实现的功能比如事件响应、手势识别、界面更新、定时器、performSelector、GCD，笔者会在以后的博客里慢慢更新…</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/RunLoop/" rel="tag"># RunLoop</a>
          
            <a href="/tags/NSRunLoop/" rel="tag"># NSRunLoop</a>
          
            <a href="/tags/CFRunLoop/" rel="tag"># CFRunLoop</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/08/02/blog_block/" rel="next" title="Block精析">
                <i class="fa fa-chevron-left"></i> Block精析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/10/18/blog_runtime/" rel="prev" title="深入理解runtime">
                深入理解runtime <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/dog.jpg"
               alt="DevHuang" />
          <p class="site-author-name" itemprop="name">DevHuang</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">分类</span>
              
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-RunLoops"><span class="nav-number">1.</span> <span class="nav-text">什么是 RunLoops</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程与runloop"><span class="nav-number">2.</span> <span class="nav-text">线程与runloop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RunLoop相关分类"><span class="nav-number">3.</span> <span class="nav-text">RunLoop相关分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Mode-Item"><span class="nav-number">3.1.</span> <span class="nav-text">Mode Item</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mode"><span class="nav-number">3.2.</span> <span class="nav-text">Mode</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runloop的实现"><span class="nav-number">4.</span> <span class="nav-text">runloop的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于runloop的休眠与唤醒"><span class="nav-number">5.</span> <span class="nav-text">关于runloop的休眠与唤醒</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runloop的CallOut"><span class="nav-number">6.</span> <span class="nav-text">runloop的CallOut</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runloop退出的条件"><span class="nav-number">7.</span> <span class="nav-text">runloop退出的条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#runloop的使用"><span class="nav-number">8.</span> <span class="nav-text">runloop的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开启和关闭的接口"><span class="nav-number">8.1.</span> <span class="nav-text">开启和关闭的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSRunloop（Foundation框架）"><span class="nav-number">8.2.</span> <span class="nav-text">NSRunloop（Foundation框架）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本的常见问题"><span class="nav-number">9.</span> <span class="nav-text">基本的常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ModeItem要在对应的Mode下才会被runloop处理"><span class="nav-number">9.1.</span> <span class="nav-text">ModeItem要在对应的Mode下才会被runloop处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子线程的runloop要手动开启"><span class="nav-number">9.2.</span> <span class="nav-text">子线程的runloop要手动开启</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#要给runloop添加modeItem，否则runloop退出"><span class="nav-number">9.3.</span> <span class="nav-text">要给runloop添加modeItem，否则runloop退出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#observer设置监听runloop状态"><span class="nav-number">9.4.</span> <span class="nav-text">observer设置监听runloop状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CF的内存管理"><span class="nav-number">9.5.</span> <span class="nav-text">CF的内存管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#autoreleasepool自动释放池在什么时候释放"><span class="nav-number">9.6.</span> <span class="nav-text">autoreleasepool自动释放池在什么时候释放</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">DevHuang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("LSKJErV1WTWliGwJScXmR6HS-gzGzoHsz", "Ffgxrm5JcUBej3cPp7BLIAMk");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
