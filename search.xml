<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[HTTP防劫持方案]]></title>
      <url>/2017/02/15/blog_httpMonitor/</url>
      <content type="html"><![CDATA[<p>HTTP劫持是在使用者与其目的网络服务所建立的专用数据通道中，监视特定数据信息，提示当满足设定的条件时，就会在正常的数据流中插入精心设计的网络数据报文，目的是让用户端程序解释”错误”的数据，并以弹出新窗口的形式在使用者界面展示宣传性广告或者直接显示某网站的内容。<br><a id="more"></a></p>
<h3 id="什么是HTTP劫持"><a href="#什么是HTTP劫持" class="headerlink" title="什么是HTTP劫持"></a>什么是HTTP劫持</h3><p>在运营商的路由器节点上，设置协议检测，一旦发现是HTTP请求，而且是html类型请求，则拦截处理。后续做法往往分为2种，1种是类似DNS劫持返回302让用户浏览器跳转到另外的地址，还有1种是在服务器返回的 HTML 数据中插入 js 或 dom 节点，从而使网页中出现自己的广告等等垃圾信息。<br>看图你就懂了一切(虽然被劫持我也很绝望)<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-dedbb1f0dbf9473a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<h3 id="URL-Loading-System"><a href="#URL-Loading-System" class="headerlink" title="URL Loading System"></a>URL Loading System</h3><p>官方文档<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The URL loading system is a set of classes and protocols that allow your app to access</div><div class="line">content referenced by a URL. At the heart of this technology is the NSURL class, which</div><div class="line">lets your app manipulate URLs and the resources they refer to.</div></pre></td></tr></table></figure></p>
<p>官方配图<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i" target="_blank" rel="external">About the URL Loading System</a><br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-0e8a88b94bb9c062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<h3 id="NSURLCache"><a href="#NSURLCache" class="headerlink" title="NSURLCache"></a>NSURLCache</h3><p>NSURLCache 为 URL 请求提供了内存中以及磁盘上的综合缓存机制。 作为基础类库 URL Loading System 的一部分，任何通过 NSURLConnection 加载的请求都将被 NSURLCache 处理。</p>
<p>当一个请求完成得到来自服务器的Response，在本地保存作为cache。下一次同一个请求再发起时，本地保存的Response就会马上返回，不需要连接服务器。NSURLCache 会 自动 且 透明 地返回回应。</p>
<p>在NSURLConnection加载系统中，缓存被设计为request对象的一个属性，由NSURLRequest对象的cachePolicy属性指定。而在NSURLSession加载系统中，缓存被设计为 NSURLSessionConfiguration对像的一个属性，该属性所指定的策略被该session的所有request所共享。</p>
<p>作为一个Cache，它头文件中提供的方法并不复杂，就是基本的增删查改，（其中增和改可以算是一个功能，没有就增，改就是覆盖）。主要方法仅六个：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 初始化方法</div><div class="line">- (instancetype)initWithMemoryCapacity:(NSUInteger)memoryCapacity diskCapacity:(NSUInteger)diskCapacity diskPath:(nullable NSString *)path;</div><div class="line">// 查询方法</div><div class="line">- (nullable NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;</div><div class="line">// 存储方法</div><div class="line">- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;</div><div class="line">// 删除方法</div><div class="line">- (void)removeCachedResponseForRequest:(NSURLRequest *)request;</div><div class="line">- (void)removeAllCachedResponses;</div><div class="line">- (void)removeCachedResponsesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);</div></pre></td></tr></table></figure></p>
<p>  当然，在项目中为了方便，我们一般都会实现一个子类，当系统调用URLCache的增删改查方法时，由子类来接管系统的URLCache功能。<br>  NSURLCache的缓存策略，以及和HTTP header之间的关系，可以参考<a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="external">NSHipster NSURLCache</a>文章</p>
<h3 id="js签名防注入"><a href="#js签名防注入" class="headerlink" title="js签名防注入"></a>js签名防注入</h3><p>这个方法主要用于资讯类App,就像文章开头那样的情况<br>步骤如下:<br>(1).发版前，在 bundle 中存一份最新的前端js文件<br>(2).后台在返回 js 文件 URL 的时候，对 js 文件内容进行 SHA-256 ，得到的 hash 值拼接到 js 的文件名中<br>(3).请求 js 资源文件时，在NSURLCache中的- (NSCachedURLResponse <em>)cachedResponseForRequest:(NSURLRequest </em>)request方法中拦截请求<br>(4).拦截请求之后，判断本地是否有缓存，如果有，则直接返回缓存文件包装成 response<br>(5).下载 js 资源时，走NSURLProtocol 代理方法- (void)connection:(NSURLConnection <em>)connection didReceiveData:(NSData </em>)data，对 data 进行SHA-256签名比对，如果签名一致，将 data 通过；如果签名不一致，代表 js 被污染，直接丢弃，从bundle取出本地预存的 js 文件返回回来。</p>
<p>基本逻辑如下(需要用到上文中NSURLCache实现的子类)<br>URLCache实现文件中：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request &#123;</div><div class="line">    NSString* ua = [request valueForHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">    if (!EmptyString(ua) &amp;&amp; [ua lf_containsSubString:@&quot;AppleWebKit&quot;]) &#123;</div><div class="line"></div><div class="line">        if ([CacheManager shouldVerifyHashCode:request]) &#123; //包含64位hashcode的js css文件</div><div class="line">              // 取本地JS缓存</div><div class="line">            NSData *resultData = [CacheManager getJSCache];</div><div class="line">            if (resultData) &#123;</div><div class="line">               NSURLResponse *response = [[NSURLResponse alloc] initWithURL:request.URL MIMEType:nil expectedContentLength:resultData.length textEncodingName:nil];</div><div class="line">                return [[NSCachedURLResponse alloc] initWithResponse:response data:resultData];</div><div class="line">            &#125; else &#123;</div><div class="line">              return nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return [super cachedResponseForRequest:request];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request &#123;</div><div class="line">    NSString* ua = [request valueForHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">    if ([CacheManager shouldVerifyHashCode:request] &amp;&amp; [ua lf_containsSubString:@&quot;AppleWebKit&quot;]) &#123;</div><div class="line">      // 将请求回来的，并且通过验证的新js放到缓存中</div><div class="line">        [[CacheManager defaultManager] storeCachedResponse:cachedResponse forRequest:request])</div><div class="line">         return;</div><div class="line">     &#125;    </div><div class="line">    [super storeCachedResponse:cachedResponse forRequest:request];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  自定义的NSURLProtocol子类:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 初始化方法</div><div class="line">+ (BOOL)canInitWithRequest:(NSURLRequest *)request &#123;</div><div class="line">    NSString *ua = [request valueForHTTPHeaderField:@&quot;User-Agent&quot;];</div><div class="line">    if ([CacheManager shouldVerifyHashCode:request] &amp;&amp; [ua lf_containsSubString:@&quot;AppleWebKit&quot;]) &#123;</div><div class="line">      // 拦截js请求</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 收到请求返回data的代理方法</div><div class="line">- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data &#123;</div><div class="line">  if([data verifySHA256Success]) &#123;</div><div class="line">      [self.client URLProtocol:self didLoadData:data];</div><div class="line">  &#125; else &#123;</div><div class="line">    localData = [CacheManager bundleCacheFromUrl:url];</div><div class="line">    [self.client URLProtocol:self didLoadData:localData];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里不用担心不能更新js文件，因为当后台的 js 文件有更新时，新 js 文件的签名就会发生变化，js 文件的URL也就自然变化，于是本地请求的时候，缓存是无法命中的，所以，也就会直接走下载 js 的那个路径。</p>
<p>缺点如下：<br>(1).在发生 js 劫持的时候，只能使用本地 js，可能会比最新版本 js 落后<br>(2).js 文件必须是由自己的服务端提供，并控制，才好对 js 进行签名，所以适用范围略窄<br>作为这个方案的扩充，可以考虑再次利用NSURLProtocol，当发现 js 被污染，重定向URL，此URL由服务端返回一个加密的 js 文件，对称加密，密钥插入在 js 的密文中，本地解密 js 文件，就可以保证得到最新的，安全的 js 文件了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文总结的是HTTP的防劫持，其实现在苹果也建议我们使用HTTPS，是啊，如果大家都使用了HTTPS哪还有这么多事呢，但是苹果框架下的URL Loading System需要我们研究的东西还是比较多的，长路漫漫,Fighting<del>~</del></p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p><a href="https://segmentfault.com/a/1190000009049544" target="_blank" rel="external">iOS 客户端对于运营商劫持的一点点对抗方式</a><br><a href="https://segmentfault.com/a/1190000006601382" target="_blank" rel="external">iOS 开发中使用 NSURLProtocol 拦截 HTTP 请求</a><br><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/URLLoadingSystem/URLLoadingSystem.html#//apple_ref/doc/uid/10000165i" target="_blank" rel="external">About the URL Loading System</a><br><a href="http://nshipster.cn/nsurlcache/" target="_blank" rel="external">NSHipster NSURLCache</a></p>
]]></content>
      
        <categories>
            
            <category> HTTP劫持 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> NSURLCache </tag>
            
            <tag> URL Loading System </tag>
            
            <tag> JaveScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DNS防劫持方案]]></title>
      <url>/2016/12/07/blog_property/</url>
      <content type="html"><![CDATA[<p>DNS劫持又称域名劫持，是指在劫持的网络范围内拦截域名解析的请求，分析请求的域名，把审查范围以外的请求放行，否则返回假的IP地址或者什么都不做使请求失去响应，其效果就是对特定的网络不能反应或访问的是假网址。<br><a id="more"></a></p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>　　DNS（域名系统）的作用是把网络地址（域名，以一个字符串的形式）对应到真实的计算机能够识别的网络地址（IP地址），以便计算机能够进一步通信，传递网址和内容等。由于域名劫持往往只能在特定的被劫持的网络范围内进行，所以在此范围外的域名服务器（DNS）能够返回正常的IP地址，高级用户可以在网络设置把DNS指向这些正常的域名服务器以实现对网址的正常访问。所以域名劫持通常相伴的措施——封锁正常DNS的IP。如果知道该域名的真实IP地址，则可以直接用此IP代替域名后进行访问。比如访问百度域名，可以把访问改为202.108.22.5，从而绕开域名劫持<br>如下图所示</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-28b760d26c717412.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<h3 id="NSURLProtocol"><a href="#NSURLProtocol" class="headerlink" title="NSURLProtocol"></a>NSURLProtocol</h3><p> 官方文档这样描述<br>     <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">An NSURLProtocol object handles the loading of protocol-specific URL data. The NSURLProtocol class itself is an abstract class that provides the infrastructure for processing URLs with a specific URL scheme. You create subclasses for any custom protocols or URL schemes that your app supports.</div></pre></td></tr></table></figure></p>
<p> NSURLProtocol也是苹果众多黑魔法中的一种，使用它可以轻松地重定义整个URL Loading System。当你注册自定义NSURLProtocol后，就有机会对所有的请求进行统一的处理，基于这一点它可以让你</p>
<p>(1).自定义请求和响应</p>
<p>(2).提供自定义的全局缓存支持</p>
<p>(3).重定向网络请求</p>
<p>(4).提供HTTP Mocking (方便前期测试)</p>
<p>(5).其他一些全局的网络请求修改需求</p>
<p>这使得我们不必改动网络请求的业务代码，也能在需要的时候改变请求的细节。作为一个抽象类，我们必须继承自NSURLProtocol才能实现中间攻击的功能。</p>
<p>使用方法<br>(1).继承NSURLPorotocl，并注册你的NSURLProtocol<br>[NSURLProtocol registerClass:[XXURLProtocol class]];</p>
<p>当NSURLConnection准备发起请求时，它会遍历所有已注册的NSURLProtocol，询问它们能否处理当前请求。所以你需要尽早注册这个Protocol。</p>
<p>(2).是否要处理对应的请求<br>当遍历到我们自定义的NSURLProtocol时，系统先会调用canInitWithRequest:这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。由于网页存在动态链接的可能性，简单的返回YES可能会创建大量的NSURLProtocol对象，因此我们需要保证每个请求能且仅能被返回一次YES。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)canInitWithRequest: (NSURLRequest *)request;</div><div class="line">+ (BOOL)canInitWithTask: (NSURLSessionTask *)task;</div></pre></td></tr></table></figure></p>
<p>(3).是否要对请求进行重定向，或者修改请求头、域名等关键信息。<br>当遍历到我们自定义的NSURLProtocol时，系统先会调用canInitWithRequest:这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。由于网页存在动态链接的可能性，简单的返回YES可能会创建大量的NSURLProtocol对象，因此我们需要保证每个请求能且仅能被返回一次YES。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (NSURLRequest *)canonicalRequestForRequest: (NSURLRequest *)request;</div></pre></td></tr></table></figure></p>
<p>(4).标记是否被处理过<br>当遍历到我们自定义的NSURLProtocol时，系统先会调用canInitWithRequest:这个方法。顾名思义，这是整个流程的入口，只有这个方法返回YES我们才能够继续后续的处理。由于网页存在动态链接的可能性，简单的返回YES可能会创建大量的NSURLProtocol对象，因此我们需要保证每个请求能且仅能被返回一次YES。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)startLoading;</div><div class="line">- (void)stopLoading;</div></pre></td></tr></table></figure></p>
<h3 id="DNS劫持"><a href="#DNS劫持" class="headerlink" title="DNS劫持"></a>DNS劫持</h3><p>对于iOS开发来讲,DNS劫持一般发生在使用webView的时候,我们更多地是处理网页加载的劫持。</p>
<p>LocalDNS是一种常见的防劫持方案。简单来说，在网页发起请求的时候获取请求域名，然后在本地进行解析得到ip，返回一个直接访问网页ip地址的请求。结构体struct hostent用来表示地址信息：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct hostent &#123;</div><div class="line">    char *h_name;                     // official name of host</div><div class="line">    char **h_aliases;                 // alias list</div><div class="line">    int h_addrtype;                   // host address type——AF_INET || AF_INET6</div><div class="line">    int h_length;                     // length of address</div><div class="line">    char **h_addr_list;               // list of addresses</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>C函数gethostbyname使用递归查询的方式将传入的域名转换成struct hostent结构体，但是这个函数存在一个缺陷：由于采用递归方式查询域名，常常会发生超时。但是gethostbyname本身不支持超时处理，所以这个函数调用的时候放到操作队列中执行，并且采用信号量等待1.5秒查询：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ (struct hostent *)getHostByName: (const char *)hostName &#123;</div><div class="line">    __block struct hostent * phost = NULL;</div><div class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);</div><div class="line">    NSOperationQueue * queue = [NSOperationQueue new];</div><div class="line">    queue.maxConcurrentOperationCount = 1;</div><div class="line">    [queue addOperationWithBlock: ^&#123;</div><div class="line">        phost = gethostbyname(hostName);</div><div class="line">        dispatch_semaphore_signal(semaphore);</div><div class="line">    &#125;];</div><div class="line">    dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 1.5 * NSEC_PER_SEC));</div><div class="line">    [queue cancelAllOperations];</div><div class="line">    return phost;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><p>  然后通过函数inet_ntop把结构体中的地址信息符号化，获得C字符串类型的地址信息。提供getIpAddressFromHostName方法隐藏对ipv4和ipv6地址的处理细节：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">  + (NSString *)getIpv4AddressFromHost: (NSString *)host &#123;</div><div class="line">    const char * hostName = host.UTF8String;</div><div class="line">    struct hostent * phost = [self getHostByName: hostName];</div><div class="line">    if ( phost == NULL ) &#123; return nil; &#125;</div><div class="line"></div><div class="line">    struct in_addr ip_addr;</div><div class="line">    memcpy(&amp;ip_addr, phost-&gt;h_addr_list[0], 4);</div><div class="line"></div><div class="line">    char ip[20] = &#123; 0 &#125;;</div><div class="line">    inet_ntop(AF_INET, &amp;ip_addr, ip, sizeof(ip));</div><div class="line">    return [NSString stringWithUTF8String: ip];</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)getIpv6AddressFromHost: (NSString *)host &#123;</div><div class="line">    const char * hostName = host.UTF8String;</div><div class="line">    struct hostent * phost = [self getHostByName: hostName];</div><div class="line">    if ( phost == NULL ) &#123; return nil; &#125;</div><div class="line"></div><div class="line">    char ip[32] = &#123; 0 &#125;;</div><div class="line">    char ** aliases;</div><div class="line">    switch (phost-&gt;h_addrtype) &#123;</div><div class="line">        case AF_INET:</div><div class="line">        case AF_INET6: &#123;</div><div class="line">            for (aliases = phost-&gt;h_addr_list; *aliases != NULL; aliases++) &#123;</div><div class="line">                NSString * ipAddress = [NSString stringWithUTF8String: inet_ntop(phost-&gt;h_addrtype, *aliases, ip, sizeof(ip))];</div><div class="line">                    if (ipAddress) &#123; return ipAddress; &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; break;</div><div class="line"></div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">    return nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (NSString *)getIpAddressFromHostName: (NSString *)host &#123;</div><div class="line">    NSString * ipAddress = [self getIpv4AddressFromHost: host];</div><div class="line">    if (ipAddress == nil) &#123;</div><div class="line">        ipAddress = [self getIpv6AddressFromHost: host];</div><div class="line">    &#125;</div><div class="line">    return ipAddress;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><h3 id="适配IPv6"><a href="#适配IPv6" class="headerlink" title="适配IPv6"></a>适配IPv6</h3><p>苹果明确现在的的应用要支持IPv6地址，对于开发者来说，并没有太大的改动，无非是将gethostbyname改成另外一个函数：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">phost = gethostbyname2(host, AF_INET6);</div></pre></td></tr></table></figure></p>
<p>另外就是解析域名过程中优先获取IPv6的地址而不是IPv4：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (NSString *)getIpAddressFromHostName: (NSString *)host &#123;</div><div class="line">    NSString * ipAddress = [self getIpv6AddressFromHost: host];</div><div class="line">    if (ipAddress == nil) &#123;</div><div class="line">        ipAddress = [self getIpv4AddressFromHost: host];</div><div class="line">    &#125;</div><div class="line">    return ipAddress;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="服务器下发对应的DNS解析列表代替递归查询的方法"><a href="#服务器下发对应的DNS解析列表代替递归查询的方法" class="headerlink" title="服务器下发对应的DNS解析列表代替递归查询的方法"></a>服务器下发对应的DNS解析列表代替递归查询的方法</h3><p>localDNS直接进行解析获取的ip地址可能不是最优选择，另一种做法是让应用每次启动后从服务器下发对应的DNS解析列表，直接从列表中获取ip地址访问。这种做法对比递归式的查询，无疑效率要更高一些，需要注意的是在下发请求过程中如何避免解析列表被中间人篡改。</p>
<p>因为请求地址可能无效，需要以ip映射host的映射表来保证在访问无效的地址之后能重新使用原来的域名发起请求。另外确定ip无效后应该维护一个无效地址表，用来域名解析后判断是否继续使用地址访问。</p>
<p>此外，如果你的应用还没有服务器下发DNS解析列表这一业务，那么直接使用Local DNS解析可能会遇到解析出来的ip无效问题。目前上面代码的处理是如果ip无效，发起回调让webView重新加载。除此之外有另外一种解决方案。应用本地存储一张需要访问到的域名表，然后在程序启动之后异步执行域名解析过程，参照<a href="http://nszzy.me/2016/09/07/dns-resolving/" target="_blank" rel="external">DNS解析失败的处理 (支持IPv6)</a>一文，提前做好无效解析的处理。</p>
<h3 id="针对WebKit的解决方案"><a href="#针对WebKit的解决方案" class="headerlink" title="针对WebKit的解决方案"></a>针对WebKit的解决方案</h3><p>WKWebView是苹果推出的UIWebView的替代方案，但前者还不够优秀以至于使用后者开发的大有人在。另外使用NSURLProtocol实现防DNS劫持功能的时候，在调起canInitWithRequest:后就再无下文，不过呢通过查阅资料发现想实现WebKit的请求拦截需要调用一些私有方法，让<a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="external">WKWebView 支持 NSURLProtocol</a> 文章已经做了很好的处理，在文中的基础上，可以对注册协议的过程多加了一层处理。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">static inline NSString * lxd_scheme_selector_suffix() &#123;</div><div class="line">    return @&quot;SchemeForCustomProtocol:&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline SEL lxd_register_scheme_selector() &#123;</div><div class="line">    const NSString * const registerPrefix = @&quot;register&quot;;</div><div class="line">    return NSSelectorFromString([registerPrefix stringByAppendingString: lxd_scheme_selector_suffix()]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static inline SEL lxd_unregister_scheme_selector() &#123;</div><div class="line">    const NSString * const unregisterPrefix = @&quot;unregister&quot;;</div><div class="line">    return NSSelectorFromString([unregisterPrefix stringByAppendingString: lxd_scheme_selector_suffix()]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><p>  <a href="https://blog.yeatse.com/2016/10/26/support-nsurlprotocol-in-wkwebview/" target="_blank" rel="external">WKWebView 支持 NSURLProtocol</a><br>  <a href="http://sindrilin.com/apm/2017/03/31/DNS%E5%8A%AB%E6%8C%81" target="_blank" rel="external">DNS劫持</a><br>  <a href="http://nshipster.cn/nsurlprotocol/" target="_blank" rel="external">NSHipster NSURLProtocol</a></p>
]]></content>
      
        <categories>
            
            <category> DNS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DNS </tag>
            
            <tag> UIWebView </tag>
            
            <tag> WKWebViiew </tag>
            
            <tag> NSURLProtocol </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解runtime]]></title>
      <url>/2016/10/18/blog_runtime/</url>
      <content type="html"><![CDATA[<p>什么是运行时刻<br>运行时刻是指一个程序在运行（或者在被执行）的状态。在一些编程语言中，把某些可以重用的程序或者实例打包或者重建成为”运行库”。<br><a id="more"></a></p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>Runtime 又叫运行时，是一套底层的 C 语言 API，其为 iOS 内部的核心之一，我们平时编写的 OC 代码，底层都是基于它来实现的。<br>Objective-C 从三种不同的层级上与 Runtime 系统进行交互<br>(1). 通过Objective-C 源代码<br>(2). 通过 Foundation 框架的NSObject类定义的方法<br>(3). 通过对 runtime 函数的直接调用</p>
<h4 id="通过Objective-C-源代码"><a href="#通过Objective-C-源代码" class="headerlink" title="通过Objective-C 源代码"></a>通过Objective-C 源代码</h4><p>如果我们编写OC代码,编译器会将 OC 代码转换成运行时代码。<br>比如<br>[tableView cellForRowAtIndexPath:indexPath];<br>在编译时RunTime会将上述代码转化成[发送消息]<br>objc_msgSend(tableView, @selector(cellForRowAtIndexPath:),indexPath);</p>
<h4 id="通过-Foundation-框架的NSObject类定义的方法"><a href="#通过-Foundation-框架的NSObject类定义的方法" class="headerlink" title="通过 Foundation 框架的NSObject类定义的方法"></a>通过 Foundation 框架的NSObject类定义的方法</h4><p>Cocoa 程序中绝大部分类都是 NSObject 类的子类，所以都继承了 NSObject 的行为。(NSProxy 类时个例外，它是个抽象超类)<br>一些情况下，NSObject 类仅仅定义了完成某件事情的模板，并没有提供所需要的代码。例如 -description 方法，该方法返回类内容的字符串表示，该方法主要用来调试程序。NSObject 类并不知道子类的内容，所以它只是返回类的名字和对象的地址，NSObject 的子类可以重新实现。</p>
<h4 id="通过对-runtime-函数的直接调用"><a href="#通过对-runtime-函数的直接调用" class="headerlink" title="通过对 runtime 函数的直接调用"></a>通过对 runtime 函数的直接调用</h4><p>Runtime 系统是具有公共接口的动态共享库，我们使用时只需要引入objc/Runtime.h头文件即可。</p>
<h3 id="几个参数概念"><a href="#几个参数概念" class="headerlink" title="几个参数概念"></a>几个参数概念</h3><h4 id="SEL"><a href="#SEL" class="headerlink" title="SEL"></a>SEL</h4><p>objc_msgSend函数第二个参数类型为SEL，它是selector在Objc中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector *SEL;</div></pre></td></tr></table></figure></p>
<p>其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个SEL类型的方法选择器。<br>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(NSNumber一堆抽象工厂方法)。</p>
<h4 id="id"><a href="#id" class="headerlink" title="id"></a>id</h4><p>objc_msgSend第一个参数类型为id，大家对它都不陌生，它是一个指向类实例的指针：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_object *id;</div></pre></td></tr></table></figure></p>
<p>那objc_object又是啥呢：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">struct objc_object &#123; Class isa; &#125;;</div></pre></td></tr></table></figure></p>
<p>objc_object结构体包含一个isa指针，根据isa指针就可以顺藤摸瓜找到对象所属的类。<br>PS:isa指针不总是指向实例对象所属的类，不能依靠它来确定类型，而是应该用class方法来确定实例对象的类。因为KVO的实现机理就是将被观察对象的isa指针指向一个中间类而不是真实的类，这是一种叫做 isa-swizzling 的技术。</p>
<h4 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h4><p>之所以说isa是指针是因为Class其实是一个指向objc_class结构体的指针：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_class *Class;</div></pre></td></tr></table></figure></p>
<p>objc_class 的数据结构如下：<br> <img src="http://upload-images.jianshu.io/upload_images/1853274-0730cc4dce9f7431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。<br>在objc_class结构体中：ivars是objc_ivar_list指针；methodLists是指向objc_method_list指针的指针。<br>其中 objc_ivar_list 和 objc_method_list 分别是成员变量列表和方法列表：<br> <img src="http://upload-images.jianshu.io/upload_images/1853274-fe0a6fe7d9a93cf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>也就是说可以动态修改 *methodLists 的值来添加成员方法，这也是Category实现的原理，同样解释了 Category 不能添加属性的原因。<br>objc_ivar_list 结构体用来存储成员变量的列表，而 objc_ivar 则是存储了单个成员变量的信息；同理，objc_method_list 结构体存储着方法数组的列表，而单个方法的信息则由 objc_method 结构体存储。</p>
<p>值得注意的时，objc_class 中也有一个 isa 指针，这说明 Objc 类本身也是一个对象。为了处理类和对象的关系，Runtime 库创建了一种叫做 Meta Class(元类) 的东西，类对象所属的类就叫做元类。Meta Class 表述了类对象本身所具备的元数据。</p>
<p>我们所熟悉的类方法，就源自于 Meta Class。我们可以理解为类方法就是类对象的实例方法。每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。</p>
<p>当你发出一个类似 <a href="类方法">NSObject alloc</a> 的消息时，实际上，这个消息被发送给了一个类对象(Class Object)，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类(Root Meta Class)的实例。所有元类的 isa 指针最终都指向根元类。</p>
<p>所以当 [NSObject alloc] 这条消息发送给类对象的时候，运行时代码 objc_msgSend() 会去它元类中查找能够响应消息的方法实现，如果找到了，就会对这个类对象执行方法调用。</p>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p>Method 代表类中某个方法的类型</p>
<p>typedef struct objc_method *Method;</p>
<p>struct objc_method {<br>    SEL method_name                                          OBJC2_UNAVAILABLE;<br>    char *method_types                                       OBJC2_UNAVAILABLE;<br>    IMP method_imp                                           OBJC2_UNAVAILABLE;<br>}<br>objc_method 存储了方法名，方法类型和方法实现：</p>
<p>方法名类型为 SEL<br>方法类型 method_types 是个 char 指针，存储方法的参数类型和返回值类型<br>method_imp 指向了方法的实现，本质是一个函数指针</p>
<h4 id="Ivar"><a href="#Ivar" class="headerlink" title="Ivar"></a>Ivar</h4><p>Ivar 是表示成员变量的类型。</p>
<p>typedef struct objc_ivar *Ivar;</p>
<p>struct objc_ivar {<br>    char <em>ivar_name                                          OBJC2_UNAVAILABLE;<br>    char </em>ivar_type                                          OBJC2_UNAVAILABLE;<br>    int ivar_offset                                          OBJC2_UNAVAILABLE;</p>
<p>#ifdef <strong>LP64</strong><br>    int space                                                OBJC2_UNAVAILABLE;</p>
<p>#endif<br>}<br>其中 ivar_offset 是基地址偏移字节</p>
<h4 id="IMP"><a href="#IMP" class="headerlink" title="IMP"></a>IMP</h4><p>IMP在objc.h中的定义是：</p>
<p>typedef id (*IMP)(id, SEL, …);<br>它就是一个函数指针，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 IMP 这个函数指针就指向了这个方法的实现。</p>
<p>如果得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面 Cache 中会提到。</p>
<p>你会发现 IMP 指向的方法与 objc_msgSend 函数类型相同，参数都包含 id 和 SEL 类型。每个方法名都对应一个 SEL 类型的方法选择器，而每个实例对象中的 SEL 对应的方法实现肯定是唯一的，通过一组 id和 SEL 参数就能确定唯一的方法实现地址。</p>
<p>而一个确定的方法也只有唯一的一组 id 和 SEL 参数。</p>
<h4 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h4><p>Cache 定义如下：</p>
<p>typedef struct objc_cache *Cache</p>
<p>struct objc_cache {<br>    unsigned int mask /<em> total = mask + 1 </em>/                 OBJC2_UNAVAILABLE;<br>    unsigned int occupied                                    OBJC2_UNAVAILABLE;<br>    Method buckets[1]                                        OBJC2_UNAVAILABLE;<br>};<br>Cache 为方法调用的性能进行优化，每当实例对象接收到一个消息时，它不会直接在 isa 指针指向的类的方法列表中遍历查找能够响应的方法，因为每次都要查找效率太低了，而是优先在 Cache 中查找。</p>
<p>Runtime 系统会把被调用的方法存到 Cache 中，如果一个方法被调用，那么它有可能今后还会被调用，下次查找的时候就会效率更高。就像计算机组成原理中 CPU 绕过主存先访问 Cache 一样。</p>
<h4 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h4><p>typedef struct objc_property <em>Property;<br>typedef struct objc_property </em>objc_property_t;//这个更常用<br>可以通过class_copyPropertyList 和 protocol_copyPropertyList 方法获取类和协议中的属性：</p>
<p>objc_property_t <em>class_copyPropertyList(Class cls, unsigned int </em>outCount)<br>objc_property_t <em>protocol_copyPropertyList(Protocol </em>proto, unsigned int *outCount)。</p>
<p>property_getName 用来查找属性的名称，返回 c 字符串。property_getAttributes 函数挖掘属性的真实名称和 @encode 类型，返回 c 字符串。</p>
<p>objc_property_t class_getProperty(Class cls, const char <em>name)<br>objc_property_t protocol_getProperty(Protocol </em>proto, const char *name, BOOL isRequiredProperty, BOOL isInstanceProperty)<br>class_getProperty 和 protocol_getProperty 通过给出属性名在类和协议中获得属性的引用。</p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>苹果官方文档中的 messages aren’t bound to method implementations until Runtime。<br>消息直到运行时才会与方法实现进行绑定。<br>这里要清楚一点，objc_msgSend 方法看清来好像返回了数据，其实objc_msgSend 从不返回数据，而是你的方法在运行时实现被调用后才会返回数据。<br>如图：<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-c290381e13840b9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"><br>  (1).首先检测这个 selector 是不是要忽略。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数。<br>  (2).检测这个 selector 的 target 是不是 nil，Objc 允许我们对一个 nil 对象执行任何方法不会 Crash，因为运行时会被忽略掉。<br>  (3).如果上面两步都通过了，那么就开始查找这个类的实现 IMP，先从 cache 里查找，如果找到了就运行对应的函数去执行相应的代码。<br>  (4).如果 cache 找不到就找类的方法列表中是否有对应的方法。<br>  (5).如果类的方法列表中找不到就到父类的方法列表中查找，一直找到 NSObject 类为止。<br>  (6).如果还找不到，就要开始进入动态方法解析了。<br>  在消息的传递中，编译器会根据情况在 objc_msgSend ， objc_msgSend_stret ， objc_msgSendSuper ， objc_msgSendSuper_stret 这四个方法中选择一个调用。如果消息是传递给父类，那么会调用名字带有 Super 的函数，如果消息返回值是数据结构而不是简单值时，会调用名字带有 stret 的函数。</p>
<h3 id="方法中的隐藏参数"><a href="#方法中的隐藏参数" class="headerlink" title="方法中的隐藏参数"></a>方法中的隐藏参数</h3><p>我们经常用到关键字 self ，但是 self 是如何获取当前方法的对象呢？<br>其实，这也是 Runtime 系统的作用，self 实在方法运行时被动态传入的。</p>
<p>当 objc_msgSend 找到方法对应实现时，它将直接调用该方法实现，并将消息中所有参数都传递给方法实现，同时，它还将传递两个隐藏参数：</p>
<p>接受消息的对象(self 所指向的内容，当前方法的对象指针)<br>方法选择器(_cmd 指向的内容，当前方法的 SEL 指针)<br>因为在源代码方法的定义中，我们并没有发现这两个参数的声明。它们时在代码被编译时被插入方法实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。</p>
<p>这两个参数中， self更实用。它是在方法实现中访问消息接收者对象的实例变量的途径。</p>
<p>这时我们可能会想到另一个关键字 super ，实际上 super 关键字接收到消息时，编译器会创建一个 objc_super 结构体：</p>
<p>struct objc_super { id receiver; Class class; };<br>这个结构体指明了消息应该被传递给特定的父类。 receiver 仍然是 self 本身，当我们想通过 [super class] 获取父类时，编译器其实是将指向 self 的 id 指针和 class 的 SEL 传递给了 objc_msgSendSuper 函数。只有在 NSObject 类中才能找到 class 方法，然后 class 方法底层被转换为 object_getClass()， 接着底层编译器将代码转换为 objc_msgSend(objc_super-&gt;receiver, @selector(class))，传入的第一个参数是指向 self 的 id 指针，与调用 [self class] 相同，所以我们得到的永远都是 self 的类型。因此你会发现：</p>
<p>// 这句话并不能获取父类的类型，只能获取当前类的类型名<br>NSLog(@”%@”, NSStringFromClass([super class]));</p>
<h3 id="获取方法地址"><a href="#获取方法地址" class="headerlink" title="获取方法地址"></a>获取方法地址</h3><p>NSObject 类中有一个实例方法：methodForSelector，你可以用它来获取某个方法选择器对应的 IMP ，举个例子：</p>
<p>void (*setter)(id, SEL, BOOL);<br>int i;</p>
<p>setter = (void (*)(id, SEL, BOOL))[target<br>    methodForSelector:@selector(setFilled:)];<br>for ( i = 0 ; i &lt; 1000 ; i++ )<br>    setter(targetList[i], @selector(setFilled:), YES);<br>当方法被当做函数调用时，两个隐藏参数也必须明确给出，上面的例子调用了1000次函数，你也可以尝试给 target 发送1000次 setFilled: 消息会花多久。</p>
<p>虽然可以更高效的调用方法，但是这种做法很少用，除非时需要持续大量重复调用某个方法的情况，才会选择使用以免消息发送泛滥。<br>注意:methodForSelector:方法是由 Runtime 系统提供的，而不是 Objc 自身的特性.</p>
<h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><p>你可以动态提供一个方法实现。如果我们使用关键字 @dynamic 在类的实现文件中修饰一个属性，表明我们会为这个属性动态提供存取方法，编译器不会再默认为我们生成这个属性的 setter 和 getter 方法了，需要我们自己提供。</p>
<p>@dynamic propertyName;<br>这时，我们可以通过分别重载 resolveInstanceMethod: 和 resolveClassMethod: 方法添加实例方法实现和类方法实现。</p>
<p>当 Runtime 系统在 Cache 和类的方法列表(包括父类)中找不到要执行的方法时，Runtime 会调用 resolveInstanceMethod: 或 resolveClassMethod: 来给我们一次动态添加方法实现的机会。我们需要用 class_addMethod 函数完成向特定类添加特定方法实现的操作：</p>
<p>void dynamicMethodIMP(id self, SEL _cmd) {<br>    // implementation ….<br>}<br>@implementation MyClass</p>
<ul>
<li>(BOOL)resolveInstanceMethod:(SEL)aSEL<br>{<br>  if (aSEL == @selector(resolveThisMethodDynamically)) {<pre><code>class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, &quot;v@:&quot;);
return YES;
</code></pre>  }<br>  return [super resolveInstanceMethod:aSEL];<br>}<br>@end<br>上面的例子为 resolveThisMethodDynamically 方法添加了实现内容，就是 dynamicMethodIMP 方法中的代码。其中 “v@:” 表示返回值和参数.<br>注意：<br>动态方法解析会在消息转发机制侵入前执行，动态方法解析器将会首先给予提供该方法选择器对应的 IMP 的机会。如果你想让该方法选择器被传送到转发机制，就让 resolveInstanceMethod: 方法返回 NO。</li>
</ul>
<h3 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>消息转发机制执行前，Runtime 系统允许我们替换消息的接收者为其他对象。通过 - (id)forwardingTargetForSelector:(SEL)aSelector 方法。</p>
<ul>
<li>(id)forwardingTargetForSelector:(SEL)aSelector<br>{<br>  if(aSelector == @selector(mysteriousMethod:)){<pre><code>return alternateObject;
</code></pre>  }<br>  return [super forwardingTargetForSelector:aSelector];<br>}<br>如果此方法返回 nil 或者 self，则会计入消息转发机制(forwardInvocation:)，否则将向返回的对象重新发送消息。</li>
</ul>
<h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>当动态方法解析不做处理返回 NO 时，则会触发消息转发机制。这时 forwardInvocation: 方法会被执行，我们可以重写这个方法来自定义我们的转发逻辑：</p>
<ul>
<li>(void)forwardInvocation:(NSInvocation *)anInvocation<br>{<br>  if ([someOtherObject respondsToSelector:<pre><code>    [anInvocation selector]])
[anInvocation invokeWithTarget:someOtherObject];
</code></pre>  else<pre><code>[super forwardInvocation:anInvocation];
</code></pre>}</li>
</ul>
<p>唯一参数是个 NSInvocation 类型的对象，该对象封装了原始的消息和消息的参数。我们可以实现 forwardInvocation: 方法来对不能处理的消息做一些处理。也可以将消息转发给其他对象处理，而不抛出错误。</p>
<p>注意：参数 anInvocation 是从哪来的？<br>在 forwardInvocation: 消息发送前，Runtime 系统会向对象发送methodSignatureForSelector: 消息，并取到返回的方法签名用于生成 NSInvocation 对象。所以重写 forwardInvocation: 的同时也要重写 methodSignatureForSelector: 方法，否则会抛异常。</p>
<p>当一个对象由于没有相应的方法实现而无法相应某消息时，运行时系统将通过 forwardInvocation: 消息通知该对象。每个对象都继承了 forwardInvocation: 方法。但是， NSObject 中的方法实现只是简单的调用了 doesNotRecognizeSelector:。通过实现自己的 forwardInvocation: 方法，我们可以将消息转发给其他对象。</p>
<p>forwardInvocation: 方法就是一个不能识别消息的分发中心，将这些不能识别的消息转发给不同的接收对象，或者转发给同一个对象，再或者将消息翻译成另外的消息，亦或者简单的“吃掉”某些消息，因此没有响应也不会报错。这一切都取决于方法的具体实现。</p>
<p>注意：<br>forwardInvocation:方法只有在消息接收对象中无法正常响应消息时才会被调用。所以，如果我们向往一个对象将一个消息转发给其他对象时，要确保这个对象不能有该消息的所对应的方法。否则，forwardInvocation:将不可能被调用。</p>
<h4 id="转发和多继承"><a href="#转发和多继承" class="headerlink" title="转发和多继承"></a>转发和多继承</h4><p>转发和继承相似，可用于为 Objc 编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好像它把另一个对象中的方法接过来或者“继承”过来一样。</p>
<p>如图 ：</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-ffa14442851733e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>这使得在不同继承体系分支下的两个类可以实现“继承”对方的方法，在上图中 Warrior 和 Diplomat 没有继承关系，但是 Warrior 将 negotiate 消息转发给了 Diplomat 后，就好似 Diplomat 是 Warrior 的超类一样。</p>
<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p>
<h4 id="转发与继承"><a href="#转发与继承" class="headerlink" title="转发与继承"></a>转发与继承</h4><p>虽然转发可以实现继承的功能，但是 NSObject 还是必须表面上很严谨，像 respondsToSelector: 和 isKindOfClass: 这类方法只会考虑继承体系，不会考虑转发链。</p>
<p>如果上图中的 Warrior 对象被问到是否能响应 negotiate消息：</p>
<p>if ( [aWarrior respondsToSelector:@selector(negotiate)] )<br>    …<br>回答当然是 NO， 尽管它能接受 negotiate 消息而不报错，因为它靠转发消息给 Diplomat 类响应消息。</p>
<p>如果你就是想要让别人以为 Warrior 继承到了 Diplomat 的 negotiate 方法，你得重新实现 respondsToSelector: 和 isKindOfClass: 来加入你的转发算法：</p>
<ul>
<li>(BOOL)respondsToSelector:(SEL)aSelector<br>{<br>  if ( [super respondsToSelector:aSelector] )<pre><code>return YES;
</code></pre>  else {<pre><code>/* Here, test whether the aSelector message can     *
 * be forwarded to another object and whether that  *
 * object can respond to it. Return YES if it can.  */
</code></pre>  }<br>  return NO;<br>}<br>除了 respondsToSelector: 和 isKindOfClass: 之外，instancesRespondToSelector: 中也应该写一份转发算法。如果使用了协议，conformsToProtocol: 同样也要加入到这一行列中。</li>
</ul>
<p>如果一个对象想要转发它接受的任何远程消息，它得给出一个方法标签来返回准确的方法描述 methodSignatureForSelector:，这个方法会最终响应被转发的消息。从而生成一个确定的 NSInvocation 对象描述消息和消息参数。这个方法最终响应被转发的消息。它需要像下面这样实现：</p>
<ul>
<li>(NSMethodSignature<em>)methodSignatureForSelector:(SEL)selector<br>{<br>  NSMethodSignature</em> signature = [super methodSignatureForSelector:selector];<br>  if (!signature) {<pre><code>signature = [surrogate methodSignatureForSelector:selector];
</code></pre>  }<br>  return signature;<br>}</li>
</ul>
<h4 id="Non-Fragile-ivars"><a href="#Non-Fragile-ivars" class="headerlink" title="Non Fragile ivars"></a>Non Fragile ivars</h4><p>当一个类被编译时，实例变量的内存布局就形成了，它表明访问类的实例变量的位置。实例变量一次根据自己所占空间而产生位移，这样子有一个很大的缺陷，就是缺乏拓展性。哪天苹果更新了 NSObject 类的话，就会出现问题，但是在健壮的实例变量下，编译器生成的实例变量布局跟以前一样，但是当 Runtime 系统检测到与父类有部分重叠时它会调整你新添加的实例变量的位移，那样你再子类中新添加的成员变量就被保护起来了。</p>
<p>注意：<br>在健壮的实例变量下，不要使用 siof(SomeClass)，而是用 class_getInstanceSize([SomeClass class]) 代替；也不要使用 offsetof(SomeClass, SomeIvar)，而要使用 ivar_getOffset(class_getInstanceVariable([SomeClass class], “SomeIvar”)) 来代替。</p>
<p>runtime虽好，但是千万不能滥用哦<del>~</del>~</p>
]]></content>
      
        <categories>
            
            <category> runtime </category>
            
        </categories>
        
        
        <tags>
            
            <tag> runtime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解RunLoop]]></title>
      <url>/2016/09/01/blog_runLoop/</url>
      <content type="html"><![CDATA[<p>RunLoops 是 thread 线程的底层基础.它的本质是和它的意思一样运行着的循环,更加确切的说是线程中的循环.它用来接受循环事件和安排线程的工作,并且在线程中没有工作时,让线程进入睡眠状态.<br><a id="more"></a></p>
<h3 id="什么是-RunLoops"><a href="#什么是-RunLoops" class="headerlink" title="什么是 RunLoops"></a>什么是 RunLoops</h3><p>iOS的应用程序里面，程序启动后会有一个如下的main() 函数：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，在UIApplicationMain()方法里面完成了程序初始化,并设置程序的Delegate任务,而且随之开启主线程的 RunLoop,就开始接受事件处理，保持了程序的持续运行。而这个默认启动的runloop是和主线程相关的<br>总结runloop的作用：</p>
<p>(1).保证程序不退出<br>(2).负责处理各种事件（source、timer、observer）<br>(3).如果没有事件发生，会让程序进入休眠状态。这样可以节省cup资源，提高程序性能，有事做就去处理，没事做就休息</p>
<p>RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>我们可以将RunLoop 理解成为是一个循环,在里面它接受线程的输入,通过事件处理函数来处理事件.你的代码中应该提供 while or for 循环来驱动 runloop.在你的循环中,用 runloop 对象驱动事件处理相关的内容,接受事件,并做响应的处理.</p>
<p>iOS 中提供了两套API来访问和使用runloop：<br>CFRunLoopRef（CoreFoundation 框架），纯 C 函数 API，所有API都是线程安全的。<br>NSRunLoop（Foundation框架）， 是基于 CFRunLoopRef 的oc封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<h3 id="线程与runloop"><a href="#线程与runloop" class="headerlink" title="线程与runloop"></a>线程与runloop</h3><p>CFRunLoop 是基于 pthread 来管理的，而pthread和NSThread是一一对应的</p>
<p>Run loop，正如其名，loop表示某种循环，和run放在一起就表示一直在运行着的循环。实际上，run loop和线程是紧密相连的，可以这样说run loop是为了线程而生，没有线程，它就没有存在的必要。Run loops是线程的基础架构部分，Cocoa和CoreFundation都提供了run loop对象方便配置和管理线程的run loop（以下都已Cocoa为例）。每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。</p>
<p>主线程的runloop自动创建，子线程的runloop默认不创建。<br>runloop是不能够通过alloc init来创建。要获取runloop可以通过这两个函数CFRunLoopGetMain()和 CFRunLoopGetCurrent()来获得主线程、当前线程runloop（实质是一种懒加载）。（在NSRunloop中对应就是- mainRunloop和- currentRunloop方法）<br>可以看出来，这两个函数的内部实现看出线程和runloop是一一对应的，这种对应关系用一个字典保存起来，key是pthread，value是CFRunLoopRef：</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-396fdbacba494b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  runloop在第一次获取时创建，然后在线程结束时销毁。所以，在子线程如果不手动获取runloop，它是一直都不会有的。</p>
<h3 id="RunLoop相关分类"><a href="#RunLoop相关分类" class="headerlink" title="RunLoop相关分类"></a>RunLoop相关分类</h3><p>在 CoreFoundation 里面关于 RunLoop 有5个类:CFRunLoopRef、CFRunLoopModeRef、CFRunLoopSourceRef、CFRunLoopTimerRef、CFRunLoopObserverRef<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-eec7fc00562e90c9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>图解:<br>(1).一个 RunLoop可以有多个Mode，每个 Mode 又包含若干个 Source/Timer/Observer。<br>(2).Source/Timer/Observer又叫mode item。不同mode下的mode item互不影响<br>(3).一个 item可被加入不同的mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，RunLoop退出。（不过如果仅仅依赖没有mode item来让runloop退出，这做法是不可靠的）</p>
<h4 id="Mode-Item"><a href="#Mode-Item" class="headerlink" title="Mode Item"></a>Mode Item</h4><p>source。CFRunLoopSourceRef事件源<br>按照官方文档CFRunLoopSourceRef为3类，但数据结构只有两类(source0、source1).</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/1853274-b8aacb3f19ecbbad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>RunLoop的输入源、时间源（基于时间的触发器，上层对应NSTimer）<br>输入分为：NSPort、自定义源、performSelector:OnThread:delay:<br>NSPort：基于端口的源:与内核端口相关。只需要简单的创建端口对象，并使用NSPort的方法将端口对象加入到run loop。端口对象会处理创建以及配置输入源。对应的是source1.<br>自定义源：自定义源：使用CFRunLoopSourceRef类型相关的函数来创建自定义输入源，比如CFRunLoopSourceCreate.<br>Selector:执行完后会自动清除出runloop（这是文档的说法，和实际测试不一样。基于端口的源不会）.</p>
<p>Selector的source分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">主线程</div><div class="line">performSelectorOnMainThread:withObject:waitUntilDone:</div><div class="line">performSelectorOnMainThread:withObject:waitUntilDone:modes:</div><div class="line"></div><div class="line">指定线程</div><div class="line">performSelector:onThread:withObject:waitUntilDone:</div><div class="line">performSelector:onThread:withObject:waitUntilDone:modes:</div><div class="line"></div><div class="line">针对当前线程</div><div class="line">performSelector:withObject:afterDelay:         </div><div class="line">performSelector:withObject:afterDelay:inModes:</div><div class="line"></div><div class="line">取消，在当前线程，和上面两个方法对应</div><div class="line">cancelPreviousPerformRequestsWithTarget:</div><div class="line">cancelPreviousPerformRequestsWithTarget:selector:object:</div></pre></td></tr></table></figure></p>
<p>总结<br>(1).对于onMainThread和onthread这两种情况，创建的是source0任务。如果调用线程和指定线程为同一线程:<br>wait参数设为YES（阻塞当前线程直到selector执行完），那么aSelector会直接在指定线程运行，不会添加到runloop。（其实就有点类似于线程死锁）<br>wait参数为NO，selector源添加到runloop且执行完不会自动清除出runloop。<br>如果调用线程和指定线程不是同一线程:selector源添加到runloop且执行完不会自动清除出runloop。<br>(2).performSelector:withObject:afterDelay则不是source0而是timer，使用是添加到runloop，执行完会自动移除出runloop。</p>
<p>剩余方法（他们是同步执行的，和线程无关，主线程子线程都可以用。不会添加到runloop，而是直接执行，相当于是[self xxx]这样调用，只不过是编译期、运行期处理的不同）:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (id)performSelector:(SEL)aSelector;</div><div class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object;</div><div class="line">- (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;</div></pre></td></tr></table></figure></p>
<p>对source0和source1深入理解<br>(1).source0 非基于port的：负责App内部事件，由App负责管理触发，例如UIEvent、UITouch事件。包含了一个回调，不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop)来唤醒 RunLoop，让其处理这个事件。<br>-performSelector:onThread:withObject:waitUntilDone: inModes:创建的是source0任务</p>
<p>(2).source1 基于port的：包含一个 mach_port 和一个回调，可监听系统端口和通过内核和其他线程发送的消息，能主动唤醒runloop，接收分发系统事件。</p>
<p>总结:Source1和Timer都属于端口事件源，不同的是所有的Timer都共用一个端口(Timer Port)，而每个Source1都有不同的对应端口。<br>Source0属于input Source中的一部分，Input Source还包括cuntom自定义源，由其他线程手动发出。</p>
<p>timer<br>CFRunLoopTimerRef是基于时间的触发器，基本上说的就是NSTimer。在预设的时间点唤醒runloop执行回调。因为它是基于RunLoop的，因此它不是实时的（就是NSTimer 是不准确的。 因为RunLoop只负责分发源的消息。如果线程当前正在处理繁重的任务，就有可能导致Timer本次延时，或者少执行一次）。</p>
<p>observer<br>CFRunLoopObserverRef观察者，监听runloop的状态。通过回调接收状态变化。它不属于runloop的事件源。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</div><div class="line">  kCFRunLoopEntry         = (1UL &lt;&lt; 0), // 即将进入Loop</div><div class="line">  kCFRunLoopBeforeTimers  = (1UL &lt;&lt; 1), // 即将处理 Timer</div><div class="line">  kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source</div><div class="line">  kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠</div><div class="line">  kCFRunLoopAfterWaiting  = (1UL &lt;&lt; 6), // 刚从休眠中唤醒</div><div class="line">  kCFRunLoopExit          = (1UL &lt;&lt; 7), // 即将退出Loop</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Mode 暴露的管理 mode item 的接口分类<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure></p>
<h4 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h4><p>CFRunLoopModeRef。每次启动RunLoop时，只能指定其中一个 Mode，这个就是CurrentMode。要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。<br>数据结构如下：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoopMode &#123;</div><div class="line">    CFRuntimeBase _base;</div><div class="line">    pthread_mutex_t _lock;   //must have the run loop locked before locking this</div><div class="line">//mode名</div><div class="line">    CFStringRef _name;</div><div class="line">    Boolean _stopped;</div><div class="line">    char _padding[3];</div><div class="line">//source0 源</div><div class="line">    CFMutableSetRef _sources0;</div><div class="line">//source1 源</div><div class="line">    CFMutableSetRef _sources1;</div><div class="line">//observer 源</div><div class="line">    CFMutableArrayRef _observers;</div><div class="line">//timer 源</div><div class="line">    CFMutableArrayRef _timers;</div><div class="line"></div><div class="line">//mach port 到 mode的映射,为了在runloop主逻辑中过滤runloop自己的port消息。</div><div class="line">    CFMutableDictionaryRef _portToV1SourceMap;</div><div class="line"></div><div class="line">//记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</div><div class="line">    __CFPortSet _portSet;</div><div class="line">    CFIndex _observerMask;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    dispatch_source_t _timerSource;</div><div class="line">    dispatch_queue_t _queue;</div><div class="line">    Boolean _timerFired; // set to true by the source when a timer has fired</div><div class="line">    Boolean _dispatchTimerArmed;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">//使用 mk timer， 用到的mach port，和source1类似，都依赖于mach port</div><div class="line">    mach_port_t _timerPort;</div><div class="line">    Boolean _mkTimerArmed;</div><div class="line">#endif</div><div class="line">//timer触发的理想时间</div><div class="line">    uint64_t _timerSoftDeadline; /* TSR */</div><div class="line">//timer触发的实际时间，理想时间加上tolerance（偏差）</div><div class="line">    uint64_t _timerHardDeadline; /* TSR */</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>系统默认注册了5个mode，以下两个是比较常用的：<br>1.kCFRunLoopDefaultMode （NSDefaultRunLoopMode），默认模式<br>2.UITrackingRunLoopMode， scrollview滑动时就是处于这个模式下。保证界面滑动时不受其他mode影响</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);</div><div class="line">CFRunLoopRunInMode(CFStringRef modeName, ...);</div></pre></td></tr></table></figure></p>
<p>对于传入的 mode name 如果runLoop 内部没有对应 mode 时，runLoop会自动创建对应的 CFRunLoopModeRef。mode只能添加不能删除</p>
<p>kCFRunLoopCommonModes（NSRunLoopCommonModes）<br>它是一个占位用的mode，它不是真正意义上的mode。<br>如果要在线程中开启runloop，这样写是不对的：[[NSRunLoop currentRunLoop] runMode:NSRunLoopCommonModes beforeDate:[NSDate distantFuture]];<br>CFRunLoop中有关CommonMode的结构:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct __CFRunLoop &#123;</div><div class="line">    CFMutableSetRef _commonModes;     // Set</div><div class="line">    CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt;</div><div class="line">    CFRunLoopModeRef _currentMode;    // Current Runloop Mode</div><div class="line">    CFMutableSetRef _modes;           // Set</div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>小结:<br>1.关于mode：一个mode可以标记为common属性（用CFRunLoopAddCommonMode函数），然后它就会保存在_commonModes。主线程已有的两个modekCFRunLoopDefaultMode 和 UITrackingRunLoopMode 都已经是CommonModes了。<br>2.关于item：_commonModeItems里面存放的source, observer, timer等，在每次runLoop运行的时候都会被同步到具有Common标记的Modes里。比如这样：[[NSRunLoop currentRunLoop] addTimer:_timer forMode:NSRunLoopCommonModes];就是把timer放到commonItem里</p>
<h3 id="runloop的实现"><a href="#runloop的实现" class="headerlink" title="runloop的实现"></a>runloop的实现</h3><p>直接上源码吧!<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;    </div><div class="line">    CHECK_FOR_FORK();</div><div class="line">    if (__CFRunLoopIsDeallocating(rl)) return kCFRunLoopRunFinished;</div><div class="line">    __CFRunLoopLock(rl);</div><div class="line">    //根据mode name找到对应的mode</div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);</div><div class="line">    //如果mode里没有source/timer/observer,直接返回。</div><div class="line">    if (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) &#123;</div><div class="line">    Boolean did = false;</div><div class="line">    if (currentMode) __CFRunLoopModeUnlock(currentMode);</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">    volatile _per_run_data *previousPerRun = __CFRunLoopPushPerRunData(rl);</div><div class="line">    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;</div><div class="line">    rl-&gt;_currentMode = currentMode;</div><div class="line">    int32_t result = kCFRunLoopRunFinished;</div><div class="line"></div><div class="line">    //1.通知 Observers:即将进入runloop。</div><div class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);</div><div class="line">    //内部函数，进入loop</div><div class="line">    result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);</div><div class="line">    //10.通知 Observers:RunLoop 即将退出。</div><div class="line">    if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line"></div><div class="line">        __CFRunLoopModeUnlock(currentMode);</div><div class="line">        __CFRunLoopPopPerRunData(rl, previousPerRun);</div><div class="line">    rl-&gt;_currentMode = previousMode;</div><div class="line">    __CFRunLoopUnlock(rl);</div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div></pre></td><td class="code"><pre><div class="line">static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123;</div><div class="line">    uint64_t startTSR = mach_absolute_time();//获取系统启动之后 的内核时间</div><div class="line"></div><div class="line">    //如果当前runLoop或者runLoopMode为停止状态的话直接返回</div><div class="line">    if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">    return kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">    rlm-&gt;_stopped = false;</div><div class="line">    return kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mach_port_name_t dispatchPort = MACH_PORT_NULL;//用来保存主队列（mainQueue）的端口。mach端口--线程之间通信</div><div class="line">    //判断当前线程是否主线程（当前runloop是否主线程runloop），如果是就分发一个队列调度端口</div><div class="line">    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));</div><div class="line">    // 只有在MainRunLoop，才会有下面这行赋值，否则 dispatchPort 为NULL</div><div class="line">    if (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name))</div><div class="line">        dispatchPort = _dispatch_get_main_queue_port_4CF();</div><div class="line"></div><div class="line"></div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">    //给当前mode分发队列端口</div><div class="line">    mach_port_name_t modeQueuePort = MACH_PORT_NULL;</div><div class="line">    if (rlm-&gt;_queue) &#123;</div><div class="line">        modeQueuePort = _dispatch_runloop_root_queue_get_port_4CF(rlm-&gt;_queue);</div><div class="line">        if (!modeQueuePort) &#123;</div><div class="line">            CRASH(&quot;Unable to get port for run loop mode queue (%d)&quot;, -1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">#endif</div><div class="line">    //gcd有关的东西，实现runloop超时管理。</div><div class="line">    /*</div><div class="line">     struct __timeout_context &#123;</div><div class="line">     dispatch_source_t ds;</div><div class="line">     CFRunLoopRef rl;//runloop</div><div class="line">     uint64_t termTSR;//超时时间点？</div><div class="line">     &#125;;</div><div class="line">     */</div><div class="line">    //对gcd的一些api不是很熟悉，但大概看懂是主要通过dispatch_source_t创建计时器；精度很高，系统自动触发，是系统级别的源</div><div class="line">    dispatch_source_t timeout_timer = NULL;</div><div class="line">    struct __timeout_context *timeout_context = (struct __timeout_context *)malloc(sizeof(*timeout_context));//超时上下文</div><div class="line">    if (seconds &lt;= 0.0) &#123; //seconds：设置的runloop超时时间</div><div class="line">        seconds = 0.0;</div><div class="line">        timeout_context-&gt;termTSR = 0ULL;</div><div class="line">    &#125; else if (seconds &lt;= TIMER_INTERVAL_LIMIT) &#123;//设置的超时时间在最大限制内，才创建timeout_timer</div><div class="line">        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);</div><div class="line">        timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</div><div class="line">        dispatch_retain(timeout_timer);</div><div class="line">        timeout_context-&gt;ds = timeout_timer;</div><div class="line">        timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);</div><div class="line">        timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);</div><div class="line">        dispatch_set_context(timeout_timer, timeout_context); //绑定// source gets ownership of context</div><div class="line">        dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);</div><div class="line">        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);</div><div class="line">        uint64_t ns_at = (uint64_t)((__CFTSRToTimeInterval(startTSR) + seconds) * 1000000000ULL);</div><div class="line">        dispatch_source_set_timer(timeout_timer, dispatch_time(1, ns_at), DISPATCH_TIME_FOREVER, 1000ULL);</div><div class="line">        dispatch_resume(timeout_timer);</div><div class="line">    &#125; else &#123; // infinite timeout 超时时间无穷尽</div><div class="line">        seconds = 9999999999.0;</div><div class="line">        timeout_context-&gt;termTSR = UINT64_MAX;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Boolean didDispatchPortLastTime = true;</div><div class="line">    int32_t retVal = 0;</div><div class="line">    do &#123;</div><div class="line">        uint8_t msg_buffer[3 * 1024];</div><div class="line">        mach_msg_header_t *msg = NULL;</div><div class="line">        mach_port_t livePort = MACH_PORT_NULL;</div><div class="line">        __CFPortSet waitSet = rlm-&gt;_portSet;//_portSet：记录了所有当前mode中需要监听的port，作为调用监听消息函数的参数。</div><div class="line"></div><div class="line">        __CFRunLoopUnsetIgnoreWakeUps(rl);//不忽略端口唤醒</div><div class="line">        //2. 通知Observers:通知即将处理timer</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);</div><div class="line">        //3. 通知Observers:通知即将处理Source0(非port)。</div><div class="line">        if (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);</div><div class="line"></div><div class="line">        //处理加入到runLoop中的block。（非延迟的主线程？）</div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        //4.处理source0事件</div><div class="line">        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div><div class="line">        //处理block</div><div class="line">        if (sourceHandledThisLoop) &#123;</div><div class="line">            __CFRunLoopDoBlocks(rl, rlm);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //poll标志着有没有处理source0的消息，如果没有则为false，反之为true</div><div class="line">        //poll=NO的情况：没有source0且超时时间!=0</div><div class="line">        Boolean poll = sourceHandledThisLoop || (0ULL == timeout_context-&gt;termTSR);//(后一条件似乎是必然为false的)</div><div class="line"></div><div class="line">        //主线程runloop 端口存在、didDispatchPortLastTime为假（首次执行不会进入判断，因为didDispatchPortLastTime为true）</div><div class="line">        if (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) &#123;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //__CFRunLoopServiceMachPort用于接受指定端口(一个也可以是多个)的消息,最后一个参数代表当端口无消息的时候是否休眠,0是立刻返回不休眠,TIMEOUT_INFINITY代表休眠</div><div class="line">            //处理通过GCD派发到主线程的任务,这些任务优先级最高会被最先处理</div><div class="line">            //5.如果有Source1，就直接跳转去处理消息。（文档说是检测source1，不过源码看来是检测dispatchPort---gcd端口事件）</div><div class="line">            if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0)) &#123;</div><div class="line">                goto handle_msg;//如果端口有事件则跳转至handle_msg</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        didDispatchPortLastTime = false;</div><div class="line"></div><div class="line">        //之前没有处理过source0，也没有source1消息，就让线程进入睡眠。</div><div class="line">        //6.通知 Observers: RunLoop 的线程即将进入休眠</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting))</div><div class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);</div><div class="line">        // 标志当前runLoop为休眠状态</div><div class="line">        __CFRunLoopSetSleeping(rl);</div><div class="line"></div><div class="line">        __CFPortSetInsert(dispatchPort, waitSet);</div><div class="line"></div><div class="line">        __CFRunLoopModeUnlock(rlm);</div><div class="line">        __CFRunLoopUnlock(rl);</div><div class="line"></div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        //  进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop</div><div class="line">        do &#123;</div><div class="line">            if (kCFUseCollectableAllocator) &#123;</div><div class="line">                objc_clear_stack(0);</div><div class="line">                memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">            &#125;</div><div class="line">            msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">            //7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</div><div class="line">            /// • 一个基于 port 的Source 的事件。</div><div class="line">            /// • 一个 Timer 到时间了</div><div class="line">            /// • RunLoop 自身的超时时间到了</div><div class="line">            /// • 被其他什么调用者手动唤醒</div><div class="line"></div><div class="line">            //如果poll为no，且waitset中无port有消息,线程进入休眠；否则唤醒</div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">            //livePort是modeQueuePort，则代表为当前mode队列的端口</div><div class="line">            if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">                //不太懂</div><div class="line">                while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">                //知道Timer被激活了才跳出二级循环继续循环一级循环</div><div class="line">                if (rlm-&gt;_timerFired) &#123;</div><div class="line">                    rlm-&gt;_timerFired = false;</div><div class="line">                    break;</div><div class="line">                &#125; else &#123;</div><div class="line">                    if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            //如果livePort不为modeQueuePort，runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口。</div><div class="line">            else &#123;</div><div class="line">                // Go ahead and leave the inner loop.</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125; while (1);</div><div class="line">#else</div><div class="line">        if (kCFUseCollectableAllocator) &#123;</div><div class="line">            objc_clear_stack(0);</div><div class="line">            memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">        &#125;</div><div class="line">        msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">        __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">#endif</div><div class="line"></div><div class="line">        __CFRunLoopLock(rl);</div><div class="line">        __CFRunLoopModeLock(rlm);</div><div class="line">        __CFPortSetRemove(dispatchPort, waitSet);</div><div class="line">        //忽略端口唤醒</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);</div><div class="line">        // user callouts now OK again</div><div class="line">        __CFRunLoopUnsetSleeping(rl);</div><div class="line">        //8.通知 Observers:RunLoop的线程刚刚被唤醒了。</div><div class="line">        if (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting))</div><div class="line">            __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line">        //处理端口消息</div><div class="line">        handle_msg:;</div><div class="line">        __CFRunLoopSetIgnoreWakeUps(rl);//设置此时runLoop忽略端口唤醒（保证线程安全）</div><div class="line"></div><div class="line"></div><div class="line">        // 9.处理待处理的事件</div><div class="line">        if (MACH_PORT_NULL == livePort) &#123;//什么都不做（超时或..?</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125;</div><div class="line">        //struct __CFRunLoop中有这么一项：__CFPort _wakeUpPort，用于手动将当前runloop线程唤醒，通过调用CFRunLoopWakeUp完成，CFRunLoopWakeUp会向_wakeUpPort发送一条消息</div><div class="line">        else if (livePort == rl-&gt;_wakeUpPort) &#123;//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();//唤醒</div><div class="line">            // do nothing on Mac OS</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer, because we apparently fired early</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        //处理因timer的唤醒。9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            if (!__CFRunLoopDoTimers(rl, rlm, mach_absolute_time())) &#123;</div><div class="line">                // Re-arm the next timer</div><div class="line">                __CFArmNextTimerInMode(rlm, rl);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            __CFRunLoopModeUnlock(rlm);</div><div class="line">            __CFRunLoopUnlock(rl);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)6, NULL);</div><div class="line"></div><div class="line">            //9.2处理异步方法唤醒。处理gcd dispatch到main_queue的block，执行block。</div><div class="line">            /*有判断是否是在MainRunLoop，有获取Main_Queue 的port，并且有调用 Main_Queue 上的回调，这只能是是 GCD 主队列上的异步任务。即：dispatch_async(dispatch_get_main_queue(), block)产生的任务。</div><div class="line">             */</div><div class="line">            __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (void *)0, NULL);</div><div class="line">            __CFRunLoopLock(rl);</div><div class="line">            __CFRunLoopModeLock(rlm);</div><div class="line">             sourceHandledThisLoop = true;</div><div class="line">            didDispatchPortLastTime = true;</div><div class="line">        &#125; else &#123;</div><div class="line">            // 9.3处理Source1 (基于port)</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            // Despite the name, this works for windows handles as well</div><div class="line">            //过滤macPort消息，有一些消息不一定是runloop中注册的，这里只处理runloop中注册的消息，在rlm-&gt;_portToV1SourceMap通过macPort找有没有对应的runloopMode</div><div class="line">            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);</div><div class="line">            if (rls) &#123;</div><div class="line">                mach_msg_header_t *reply = NULL;</div><div class="line">                // 处理Source1</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">                if (NULL != reply) &#123;</div><div class="line">                    //当前线程处理完source1，给发消息的线程反馈消息</div><div class="line">                    (void)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);</div><div class="line">                    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">#if DEPLOYMENT_TARGET_MACOSX || DEPLOYMENT_TARGET_EMBEDDED || DEPLOYMENT_TARGET_EMBEDDED_MINI</div><div class="line">        if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">#endif</div><div class="line">        //block处理</div><div class="line">        __CFRunLoopDoBlocks(rl, rlm);</div><div class="line"></div><div class="line">        // 进入loop时参数说处理完事件就返回。</div><div class="line">    if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">        retVal = kCFRunLoopRunHandledSource;</div><div class="line">        &#125;</div><div class="line">        // 超出传入参数标记的超时时间了</div><div class="line">    else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">            retVal = kCFRunLoopRunTimedOut;</div><div class="line">    &#125;</div><div class="line">        // 被外部调用者强制停止了</div><div class="line">    else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">            __CFRunLoopUnsetStopped(rl);</div><div class="line">        retVal = kCFRunLoopRunStopped;</div><div class="line">    &#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">        rlm-&gt;_stopped = false;</div><div class="line">        retVal = kCFRunLoopRunStopped;</div><div class="line">    &#125;</div><div class="line">        // source/timer/observer一个都没有了</div><div class="line">    else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">        retVal = kCFRunLoopRunFinished;</div><div class="line">    &#125;</div><div class="line">        // 如果没超时，mode里没空，loop也没被停止，那继续loop。</div><div class="line">    &#125; while (0 == retVal);</div><div class="line"></div><div class="line">    //释放定时器</div><div class="line">    if (timeout_timer) &#123;</div><div class="line">        dispatch_source_cancel(timeout_timer);</div><div class="line">        dispatch_release(timeout_timer);</div><div class="line">    &#125; else &#123;</div><div class="line">        free(timeout_context);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>函数内部主要做了一个do-while循环，线程一直处于 “等待消息-&gt;接受-&gt;处理” 的循环中，直到这个循环结束。<br>对上面的源码做个归纳 就是以下10点:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-5274d3f557fba3bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>整体流程如下:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-1155ae240c459fd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  主线程runloop会处理gcd端口事件源。</p>
<h3 id="关于runloop的休眠与唤醒"><a href="#关于runloop的休眠与唤醒" class="headerlink" title="关于runloop的休眠与唤醒"></a>关于runloop的休眠与唤醒</h3><p>对于runloop而言最核心的事情就是保证线程在没有消息的时候休眠，在有消息时唤醒，以提高程序性能。runloop这个机制是依靠系统内核来完成的（苹果操作系统核心组件Darwin中的Mach）。</p>
<p>Mach提供了诸如处理器调度、IPC (进程间通信)等基础服务。在 Mach 中，进程、线程和虚拟内存都被称为”对象”。Mach 的对象间只能通过消息传递的方式实现对象间的通信。消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>Runloop本质：mach_msg()<br>Runloop通过mach_msg()函数接收、发送消息。它的本质是调用函数mach_msg_trap()，相当于是一个系统调用，会触发内核状态切换。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作。</p>
<p>如图所示:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-e34c1b942406e399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"><br>  runloop用mach_msg()这个函数去接收消息，如果没有内核发送port 消息过来，内核会将线程置于等待状态 mach_msg_trap() (当前线程阻塞)。如果有消息返回（内核开新线程返回消息），判断消息类型处理事件，并通过modeItem的callback回调。(总结：基于port的source1，监听端口，端口有消息，触发回调；而source0，要手动标记为待处理和手动唤醒runloop)</p>
<p>  正如runloop源码里的第7步一样<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//  进入循环开始不断的读取端口信息，如果端口有唤醒信息则唤醒当前runLoop</div><div class="line">do &#123;</div><div class="line">  if (kCFUseCollectableAllocator) &#123;</div><div class="line">      objc_clear_stack(0);</div><div class="line">      memset(msg_buffer, 0, sizeof(msg_buffer));</div><div class="line">  &#125;</div><div class="line">  msg = (mach_msg_header_t *)msg_buffer;</div><div class="line">  //7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</div><div class="line">  /// • 一个基于 port 的Source 的事件。</div><div class="line">  /// • 一个 Timer 到时间了</div><div class="line">  /// • RunLoop 自身的超时时间到了</div><div class="line">  /// • 被其他什么调用者手动唤醒</div><div class="line"></div><div class="line">  //如果poll为no，且waitset中无port有消息,线程进入休眠；否则唤醒</div><div class="line">  __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY);</div><div class="line">  //livePort是modeQueuePort，则代表为当前mode队列的端口</div><div class="line">  if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">      //不太懂</div><div class="line">      while (_dispatch_runloop_root_queue_perform_4CF(rlm-&gt;_queue));</div><div class="line">      //知道Timer被激活了才跳出二级循环继续循环一级循环</div><div class="line">      if (rlm-&gt;_timerFired) &#123;</div><div class="line">          rlm-&gt;_timerFired = false;</div><div class="line">          break;</div><div class="line">      &#125; else &#123;</div><div class="line">          if (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  //如果livePort不为modeQueuePort，runLoop被唤醒。这代表__CFRunLoopServiceMachPort给出的livePort只有两种可能：一种情况为MACH_PORT_NULL，另一种为真正获取的消息的端口。</div><div class="line">  else &#123;</div><div class="line">      // Go ahead and leave the inner loop.</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line">&#125; while (1);</div></pre></td></tr></table></figure></p>
<p>runloop的休眠状态也是一个do-while循环。其中的核心处理函数__CFRunLoopServiceMachPort：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//真正让runloop休眠的地方</div><div class="line">static Boolean __CFRunLoopServiceMachPort(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_port_t *livePort, mach_msg_timeout_t timeout) &#123;</div><div class="line">    Boolean originalBuffer = true;</div><div class="line">    kern_return_t ret = KERN_SUCCESS;</div><div class="line">    for (;;) &#123;        /* In that sleep of death what nightmares may come ... */</div><div class="line">        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;</div><div class="line">        msg-&gt;msgh_bits = 0;</div><div class="line">        msg-&gt;msgh_local_port = port;</div><div class="line">        msg-&gt;msgh_remote_port = MACH_PORT_NULL;</div><div class="line">        msg-&gt;msgh_size = buffer_size;</div><div class="line">        msg-&gt;msgh_id = 0;</div><div class="line">        //根据timerout参数的值来判断是让runloop 休眠还是继续查询（poll）</div><div class="line">        if (TIMEOUT_INFINITY == timeout) &#123; CFRUNLOOP_SLEEP(); &#125; else &#123; CFRUNLOOP_POLL(); &#125;</div><div class="line">        //调用mach_msg()函数接收消息</div><div class="line">        ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);</div><div class="line">        CFRUNLOOP_WAKEUP(ret);//唤醒</div><div class="line">        if (MACH_MSG_SUCCESS == ret) &#123;//成功获取到消息</div><div class="line">            *livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TIMED_OUT == ret) &#123;//获取消息超时</div><div class="line">            if (!originalBuffer) free(msg);</div><div class="line">            *buffer = NULL;</div><div class="line">            *livePort = MACH_PORT_NULL;</div><div class="line">            return false;</div><div class="line">        &#125;</div><div class="line">        if (MACH_RCV_TOO_LARGE != ret) break;</div><div class="line">        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);</div><div class="line">        if (originalBuffer) *buffer = NULL;</div><div class="line">        originalBuffer = false;</div><div class="line">        *buffer = realloc(*buffer, buffer_size);</div><div class="line">    &#125;</div><div class="line">    HALT;</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>__CFRunLoopServiceMachPort用于接受指定端口(一个也可以是多个)的消息，最后一个参数代表当端口无消息的时候是否休眠，0是立刻返回不休眠，TIMEOUT_INFINITY代表休眠。<br>然后调用mach_msg()函数接收消息（如果没有port 消息，内核会将线程置于等待状态 mach_msg_trap()，所以来到这里，runloop如果没事做就休眠了），根据接收消息的结果对livePort进行赋值，一种是成功获取到消息后，会根据情况赋值为msg-&gt;msgh_local_port或者MACH_PORT_NULL，而另一种获取消息超时的情况会赋值为MACH_PORT_NULL。</p>
<p>如果livePort不是modeQueuePort那么就是唤醒runloop的消息端口或者MACH_PORT_NULL。</p>
<p>接着来到第九步，就会看到对livePort不同情况的处理了：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">if (MACH_PORT_NULL == livePort) &#123;//什么都不做（超时或..?</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_NOTHING();</div><div class="line">            // handle nothing</div><div class="line">        &#125;</div><div class="line">        //struct __CFRunLoop中有这么一项：__CFPort _wakeUpPort，用于手动将当前runloop线程唤醒，通过调用CFRunLoopWakeUp完成，CFRunLoopWakeUp会向_wakeUpPort发送一条消息</div><div class="line">        else if (livePort == rl-&gt;_wakeUpPort) &#123;//只有外界调用CFRunLoopWakeUp才会进入此分支，这是外部主动唤醒runLoop的接口</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_WAKEUP();//唤醒</div><div class="line">        &#125;</div><div class="line">#if USE_DISPATCH_SOURCE_FOR_TIMERS</div><div class="line">        else if (modeQueuePort != MACH_PORT_NULL &amp;&amp; livePort == modeQueuePort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">#if USE_MK_TIMER_TOO</div><div class="line">        //处理因timer的唤醒。9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</div><div class="line">        else if (rlm-&gt;_timerPort != MACH_PORT_NULL &amp;&amp; livePort == rlm-&gt;_timerPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_TIMER();</div><div class="line">            ......</div><div class="line">        &#125;</div><div class="line">#endif</div><div class="line">        else if (livePort == dispatchPort) &#123;</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_DISPATCH();</div><div class="line">            //9.2处理异步方法唤醒。处理gcd dispatch到main_queue的block，执行block。</div><div class="line">        &#125; else &#123;</div><div class="line">            // 9.3处理Source1 (基于port)</div><div class="line">            CFRUNLOOP_WAKEUP_FOR_SOURCE();</div><div class="line">            ......</div><div class="line">            if (rls) &#123;</div><div class="line">                __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;</div><div class="line">                ......</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<h3 id="runloop的CallOut"><a href="#runloop的CallOut" class="headerlink" title="runloop的CallOut"></a>runloop的CallOut</h3><p>runloop的回调，一般都是通过一个名字很长的函数，比如下面六个：打断点调试的时候可以在调用栈中看到他们的身影<br>(换句话说你的代码其实最终都是通过下面几个函数来负责调用的，即使你自己监听Observer也会先调用下面的函数然后间接通知你)：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">static void __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__();</div><div class="line">    static void __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__();</div><div class="line">    static void __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__();</div></pre></td></tr></table></figure></p>
<h3 id="runloop退出的条件"><a href="#runloop退出的条件" class="headerlink" title="runloop退出的条件"></a>runloop退出的条件</h3><p>一次性执行；app退出；线程关闭；设置最大时间到期；modeItem为空（实际上observer不算是源，所以就算有observer也是会返回的）；</p>
<h3 id="runloop的使用"><a href="#runloop的使用" class="headerlink" title="runloop的使用"></a>runloop的使用</h3><h4 id="开启和关闭的接口"><a href="#开启和关闭的接口" class="headerlink" title="开启和关闭的接口"></a>开启和关闭的接口</h4><p>CFRunLoopRef（CoreFoundation 框架）<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//运行 CFRunLoopRef</div><div class="line">void CFRunLoopRun();</div><div class="line">//运行 CFRunLoopRef: 参数为运行模式、时间和是否在处理Input Source后退出标志，返回值是exit原因</div><div class="line">SInt32 CFRunLoopRunInMode (mode, seconds, returnAfterSourceHandled);</div><div class="line">//停止运行 CFRunLoopRef</div><div class="line">void CFRunLoopStop( CFRunLoopRef rl );</div></pre></td></tr></table></figure></p>
<pre><code>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopRun(void) &#123;    /* DOES CALLOUT */</div><div class="line">    int32_t result;</div><div class="line">    do &#123;</div><div class="line">        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);</div><div class="line">        CHECK_FOR_FORK();</div><div class="line">    &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

运行在NSDefaultRunLoopMode模式下。直到调用CFRunLoopStop()强制停止（kCFRunLoopRunStopped）或者source/timer/一个都没有了（kCFRunLoopRunFinished）。即源码int32_t __CFRunLoopRun()（就是之前上面那个几百行的）中的：
</code></pre><p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-24f3cec35bade855.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SInt32 CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123;     /* DOES CALLOUT */</div><div class="line">  CHECK_FOR_FORK();</div><div class="line">  return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>  总结：<br>  (1).参数。第一个：runloop运行模式。第二个：运行时间（超时时间）。第三个：是否在处理完source(source0\source1)之后让runloop退出返回。<br>  (2).接下来要讲的NSRunloop中的两个接口：- (void)runUntilDate:(NSDate <em>)limitDate;和- (BOOL)runMode:(NSString </em>)mode beforeDate:(NSDate *)limitDate;是基于这和函数进行封装的（猜测）。<br>  (3).源码上看，和上一个函数一样，都用到CFRunLoopRunSpecific()所以最终都是调用int32_t __CFRunLoopRun()。因此也即能用CFRunLoopStop()来退出runloop。<br>  (4).返回值。是导致runloop退出的原因<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">enum &#123;</div><div class="line">kCFRunLoopRunFinished = 1,</div><div class="line">kCFRunLoopRunStopped = 2,</div><div class="line">kCFRunLoopRunTimedOut = 3,</div><div class="line">kCFRunLoopRunHandledSource = 4</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void CFRunLoopStop( CFRunLoopRef rl );(用于停掉由上面两个函数启动的runloop。)</div></pre></td></tr></table></figure>
</code></pre><h4 id="NSRunloop（Foundation框架）"><a href="#NSRunloop（Foundation框架）" class="headerlink" title="NSRunloop（Foundation框架）"></a>NSRunloop（Foundation框架）</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//运行模式为默认的NSDefaultRunLoopMode模式，没有超时限制</div><div class="line">- (void)run;</div><div class="line">//运行模式为默认的NSDefaultRunLoopMode模式 ，参数为运时间期限</div><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div><div class="line">//对runloop运行模式、时间期限可以自行设置</div><div class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure>
</code></pre><p>  关于<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)run;</div></pre></td></tr></table></figure></p>
<p>  (1).循环一旦开启，就关闭不了，并且之后的代码就无法执行。api文档中提到：如果没有输入源和定时源加入到runloop中，runloop就马上退出，否则通过频繁调用-runMode:beforeDate:方法来让runloop运行在NSDefaultRunLoopMode模式下。<br>  但是！人为地移除输入源、timer不能保证runloop会退出，因为系统有可能会自己添加一些源来处理事件。（下面两种方法也是）<br>  (2).无法用CFRunLoopStop(runloopRef)退出，这种方式启动的runloop不利于控制，不建议使用</p>
<p>  关于<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)runUntilDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure></p>
<p>  (1).运行在NSDefaultRunLoopMode模式，有超时时间限制。它实际上也是不断调用-runMode:beforeDate:方法来让runloop运行在NSDefaultRunLoopMode模式下，直到到达超时时间。<br>  (2).调用CFRunLoopStop(runloopRef)无法停止Run Loop的运行。为什么呢..因为这个方法只会结束当前-runMode:beforeDate:的调用，之后的-runMode:beforeDate:该调用的还是会继续。。。直到timeout。<br>  (3).对应CFRunLoopRunInMode(kCFRunLoopDefaultMode,limiteDate,false)</p>
<p>  关于<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;</div></pre></td></tr></table></figure></p>
<p>  (1).相比上一种方法可以指定运行模式。<br>  (2).对应CFRunLoopRunInMode(mode,limiteDate,true)方法,只执行一次，执行完就退出。<br>  (3).可以用CFRunLoopStop(runloopRef)退出runloop。<br>  (4).api文档里面提到：在第一个input source（非timer）被处理或到达limitDate之后runloop退出</p>
<p>  下面看一个例子<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">  - (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  self.view.backgroundColor = [UIColor whiteColor];</div><div class="line"></div><div class="line">  UIButton *btn = [[UIButton alloc]initWithFrame:CGRectMake(0, 80, 50, 50)];</div><div class="line">  btn.backgroundColor = [UIColor redColor];</div><div class="line">  [self.view addSubview:btn];</div><div class="line">  [btn addTarget:self action:@selector(clicked) forControlEvents:UIControlEventTouchUpInside];</div><div class="line"></div><div class="line">  NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(threadMethod) object:nil];</div><div class="line">  self.thread = thread;</div><div class="line">  [self.thread start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)threadMethod&#123;</div><div class="line">  @autoreleasepool &#123;   </div><div class="line">      [[NSRunLoop currentRunLoop]addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">      [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">      NSLog(@&quot;thread end&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)clicked&#123;</div><div class="line">  [self performSelector:@selector(doSomething) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)doSomething&#123;</div><div class="line">  NSLog(@&quot;doSomething&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  分别在控制台打印出doSomething和thread end<br>  给runloop添加源[NSMachPort port]保活，执行完perform selector（重温一下，这里会给runloop添加一个源） runloop就退出了。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">这里可以从源码上解释一下：</div><div class="line">回顾上面那几百行的源码，我们可以看到其实这个runloop 的do-while循环是由一个变量retVal的值来控制的，也即代码的最后几行：</div><div class="line"></div><div class="line">// 进入loop时参数说处理完事件就返回。</div><div class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">    retVal = kCFRunLoopRunHandledSource;</div><div class="line">    &#125;</div><div class="line">    // 超出传入参数标记的超时时间了</div><div class="line">else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123;</div><div class="line">        retVal = kCFRunLoopRunTimedOut;</div><div class="line">&#125;</div><div class="line">    // 被外部调用者强制停止了</div><div class="line">else if (__CFRunLoopIsStopped(rl)) &#123;</div><div class="line">        __CFRunLoopUnsetStopped(rl);</div><div class="line">    retVal = kCFRunLoopRunStopped;</div><div class="line">&#125; else if (rlm-&gt;_stopped) &#123;</div><div class="line">    rlm-&gt;_stopped = false;</div><div class="line">    retVal = kCFRunLoopRunStopped;</div><div class="line">&#125;</div><div class="line">    // source/timer/observer一个都没有了</div><div class="line">else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123;</div><div class="line">    retVal = kCFRunLoopRunFinished;</div><div class="line">&#125;</div><div class="line">    // 如果没超时，mode里没空，loop也没被停止，那继续loop。</div><div class="line">&#125; while (0 == retVal);</div></pre></td></tr></table></figure></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (BOOL)runMode:(NSString *)mode beforeDate:(NSDate *)limitDate;，对应CFRunLoopRunInMode(mode,limiteDate,true)。因此</div></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">  retVal = kCFRunLoopRunHandledSource;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
</code></pre><p>  中的stopAfterHandle值就是true。由于这里的perform源是source0，因此也即：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//4.处理source0事件</div><div class="line">    Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);</div></pre></td></tr></table></figure></p>
<p>  sourceHandledThisLoop在这里赋值为true。<br>  如果是source1源也是同理分析，所以在第一个input source被处理之后runloop退出。</p>
<h3 id="基本的常见问题"><a href="#基本的常见问题" class="headerlink" title="基本的常见问题"></a>基本的常见问题</h3><p>  基本使用三步骤<br>  添加事件到runloop中：1.创建事件（源） 2.指定该事件（源）在runloop中的运行模式，并加入到runloop中 3.在与runloop的模式匹配时，事件（源）运行</p>
<h4 id="ModeItem要在对应的Mode下才会被runloop处理"><a href="#ModeItem要在对应的Mode下才会被runloop处理" class="headerlink" title="ModeItem要在对应的Mode下才会被runloop处理"></a>ModeItem要在对应的Mode下才会被runloop处理</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  主线程中执行以下代码：</div><div class="line">  - (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //创建timer</div><div class="line">    //参数1：间隔时间   参数2：对象   参数3：方法   参数4：自定义   参数5：是否重复执行</div><div class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(task) userInfo:nil repeats:YES];</div><div class="line">    //把定时源加入到当前线程下的消息循环中</div><div class="line">    [[NSRunLoop currentRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"> - (void)task&#123;</div><div class="line">   // 输出当前循环模式</div><div class="line">    NSLog(@&quot;%@&quot;,[[NSRunLoop currentRunLoop]currentMode]);</div><div class="line">    NSLog(@&quot;task is running&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>  设置timer在NSDefaultRunLoopMode模式下运行。一开始什么也不做，timer正常运行；当对屏幕界面进行滚动时，timer停止运行。这是因为：没有拖动界面时是kCFRunLoopDefaultMode，拖动界面则是UITrackingRunLoopMode模式，与设置的模式不匹配所以无法运行。</p>
<p>如果需要在两个 Mode 中都能得到运行，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一个方法，就是将 Timer 加入到顶层的 RunLoop 的 commonItem中，在每次runLoop运行的时候都会被同步到具有Common标记的Modes里。<br>[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</p>
<p>ps:[NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(run) userInfo:nil repeats:YES];就相当于：上面viewDidLoad里面的两句代码，自动添加到当前runloop且在default mode模式下。如果要修改模式，调用一次addTimer:forMode:方法就可以了[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];</p>
<h4 id="子线程的runloop要手动开启"><a href="#子线程的runloop要手动开启" class="headerlink" title="子线程的runloop要手动开启"></a>子线程的runloop要手动开启</h4><p>  往指定线程的runloop中加入源：performSelector…<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad &#123;</div><div class="line">  [super viewDidLoad];</div><div class="line">  //创建子线程</div><div class="line">  NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(task2) object:nil];</div><div class="line">  [thread start];</div><div class="line">  //往指定线程的消息循环中加入源</div><div class="line">  //参数1:方法   参数2:指定线程   参数3:对象   参数4:等待方法执行完成</div><div class="line">  [self performSelector:@selector(addtask) onThread:thread withObject:nil waitUntilDone:NO];</div><div class="line">  &#125;</div><div class="line">  -(void)task2&#123;</div><div class="line">  NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">  &#125;</div><div class="line">  -(void)addtask&#123;</div><div class="line">  NSLog(@&quot;addtask is running&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>  performSelector中的方法addtask不会执行，因为线程的方法瞬间就执行完了，线程就结束被回收了而且线程也不会监听是否有方法继续交给它执行。<br>每个线程有自己的runLoop, 我们可以通过[NSRunLoop currentRunLoop]或CFRunLoopGetCurrent()来获取。 不过只有主线程的runLoop是默认启动的，其他线程的runloop就需要我们手动启动。</p>
<p>  需要在子线程中开启runloop：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">  - (void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">//方式一</div><div class="line">//    [[NSRunLoop currentRunLoop]run];</div><div class="line">//    NSLog(@&quot;over&quot;);//不会打印，因为一直在循环，没有退出</div><div class="line">//方式二</div><div class="line">//    [[NSRunLoop currentRunLoop]runUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]];</div><div class="line">//    NSLog(@&quot;over&quot;);    </div><div class="line">//方式三，apple推荐</div><div class="line">//    BOOL shouldKeepRunning = YES;        // global</div><div class="line">    NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">    while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);//通过全局变量控制runloop的开关</div><div class="line">    NSLog(@&quot;over&quot;);//这句不会执行</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  打印结果如下<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-7bced44fc3e27231.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  如果想runloop可以终止的，官方推荐：- (BOOL)runMode:(NSString <em>)mode beforeDate:(NSDate </em>)limitDate;官方example:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BOOL shouldKeepRunning = YES;        //全局变量</div><div class="line">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</div><div class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div></pre></td></tr></table></figure></p>
<p>  通过全局变量控制runloop的开关。</p>
<h4 id="要给runloop添加modeItem，否则runloop退出"><a href="#要给runloop添加modeItem，否则runloop退出" class="headerlink" title="要给runloop添加modeItem，否则runloop退出"></a>要给runloop添加modeItem，否则runloop退出</h4><p>  如果mode中一个item都没有，runloop退出。下面稍微修改一下上面2的代码：把performSelector方法放到touchesBegan中<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">  - (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //创建子线程</div><div class="line">    self.thread = [[NSThread alloc] initWithTarget:self selector:@selector(task2) object:nil];</div><div class="line">    [self.thread start];</div><div class="line">    //往指定线程的消息循环中加入源</div><div class="line">    //参数1:方法   参数2:指定线程   参数3:对象   参数4:等待方法执行完成</div><div class="line">//    [self performSelector:@selector(addtask) onThread:thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div><div class="line">-(void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">//    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    while (YES &amp;&amp; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class="line">    NSLog(@&quot;over&quot;);</div><div class="line">&#125;</div><div class="line">-(void)addtask&#123;</div><div class="line">    NSLog(@&quot;addtask is running&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    [self performSelector:@selector(addtask) onThread:self.thread withObject:nil waitUntilDone:NO];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-cd6b82093eba6517.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  运行，”over”被打印出来了，证明runloop退出。点击屏幕，addtask方法没有执行。<br>  这个方法创建Source 0 任务，并分发到指定线程的 RunLoop 中。<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)performSelector:(SEL)aSelector</div><div class="line">             onThread:(NSThread *)thr</div><div class="line">           withObject:(id)arg</div><div class="line">        waitUntilDone:(BOOL)wait</div><div class="line">                modes:(NSArray *)array;</div></pre></td></tr></table></figure></p>
<p>  那为什么和代码修改前的运行结果不一样？个人理解是这样的，2.中在子线程runloop开启前就已经添加了source0事件源了。而现在修改后的代码，把事件源的添加分离开来了，先开了子线程，而等到用户点击屏幕的时候才会添加事件源；对于子线程，runloop虽然创建并且开启了，但是因为一直没有mode item，因此runloop马上就退出了。</p>
<p>那怎么解决？一种简单粗暴的方法，在runloop开启之前给它加个mode item咯：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">-(void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">//加个端口的源</div><div class="line">    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:NSDefaultRunLoopMode];</div><div class="line">    while (YES &amp;&amp; [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</div><div class="line">    NSLog(@&quot;over&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  如果这样子改：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  -(void)task2&#123;</div><div class="line">    NSLog(@&quot;task2 is running %@&quot;,[NSThread currentThread]);</div><div class="line">    while (1) &#123;</div><div class="line">        [[NSRunLoop currentRunLoop] runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  在运行上来讲是没问题的，用户点击屏幕的时候addtask方法会执行。不过，runloop一开始没有modeitem的问题还是存在的，这导致在while循环里面runloop不断创建、启动、退出，直到点击屏幕有事件源添加进来为止。</p>
<p>  提示:当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<h4 id="observer设置监听runloop状态"><a href="#observer设置监听runloop状态" class="headerlink" title="observer设置监听runloop状态"></a>observer设置监听runloop状态</h4><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 创建observer</div><div class="line">CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;</div><div class="line">      NSLog(@&quot;----监听到RunLoop状态发生改变---%zd&quot;, activity);</div><div class="line">  &#125;);</div><div class="line">  // 添加观察者：监听RunLoop的状态</div><div class="line">  CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode);   </div><div class="line">  // 释放Observer</div><div class="line">  CFRelease(observer);</div></pre></td></tr></table></figure>
</code></pre><p>  创建observer，用CFRunLoopObserverCreateWithHandler函数，参数1：分配内存 参数2：要监听哪个runloop状态的标记 参数3：是否重复。这个observer是只调用一次还是runloop每次循环都调 参数4：优先级，一般传0 参数5：回调</p>
<h4 id="CF的内存管理"><a href="#CF的内存管理" class="headerlink" title="CF的内存管理"></a>CF的内存管理</h4><p>  (1).凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release<br>  (2).runloop先唤醒，然后处理各种事件（包括点击事件），最后又回到休眠状态</p>
<h4 id="autoreleasepool自动释放池在什么时候释放"><a href="#autoreleasepool自动释放池在什么时候释放" class="headerlink" title="autoreleasepool自动释放池在什么时候释放"></a>autoreleasepool自动释放池在什么时候释放</h4><p>  MRC环境下:<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">Person.h</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">@property (nonatomic,copy) NSString *name;</div><div class="line">+ (instancetype)personInitWithName:(NSString *)name;</div><div class="line">@end</div><div class="line"></div><div class="line">Person.m</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">+ (instancetype)personInitWithName:(NSString *)name&#123;</div><div class="line">//MRC内存管理原则：谁创建谁释放</div><div class="line">  Person *person = [[[Person alloc]init]autorelease];//自动释放池 延时释放</div><div class="line">  person.name = name;</div><div class="line">  return person;</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">vc.m</div><div class="line">#import &quot;Person.h&quot;</div><div class="line">@property (nonatomic ,assign)Person *person1;</div><div class="line">- (void)viewDidLoad&#123;</div><div class="line">  ........</div><div class="line">  self.person1 = [Person personInitWithName:@&quot;name1&quot;];</div><div class="line">  NSLog(@&quot;%@&quot;,self.person1.name);</div><div class="line">&#125;</div><div class="line">- (IBAction)clicked:(id)sender &#123;</div><div class="line">  NSLog(@&quot;person.name:%@&quot;,self.person1.name);//MRC下点击按钮后报野指针错误</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  MRC内存管理原则：谁创建谁释放。代码中使用autorelease来对person对象进行释放。自动释放池释放时，对池内所有对象都发送一次release，person对象被释放。</p>
<p>  运行结果：在点击完按钮之后报野指针错误，即对象已经被释放掉了。对此，可以从对象释放反推出自动释放池已经被释放了。那为什么会在这个时候释放？<br>  直接上图:<br>  <img src="http://upload-images.jianshu.io/upload_images/1853274-3c7f49b1251d29a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  iPhone应用程序运行-&gt;有触摸事件-&gt;cocoaTouch创建事件，生成事件对象-&gt;cocoaTouch创建自动释放池-&gt;应用处理事件（就是一些我们自己写的代码，并有可能产生一些中间、临时对象，这些对象放在自动释放池中）-&gt;事件处理完毕自动释放池释放<br>  官方文档：The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. 在主线程事件循环开始的时候创建了自动释放池,在事件循环结束的时候释放自动释放池，因此在处理事件过程中产生的一些自动释放的对象会被释放掉</p>
<p>  实际上,苹果在主线程 RunLoop 里注册了两个 Observer。第一个 Observer 监视的事件是即将进入Loop，其优先级最高，保证创建释放池发生在其他所有回调之前。<br>  第二个 Observer 监视了两个事件：准备进入休眠时 释放旧的池并创建新池；即将退出Loop时释放自动释放池。优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>  代码中，viewDidLoad的代码执行完runloop就要进入休眠了，这时候先释放旧池并把person对象释放。点击事件把runloop唤醒，之后再新池里访问释放掉的对象就报野指针错误了。</p>
<p>  提示:<br>  在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<p>  什么时候使用自动释放池？<br>  开启子线程的时候要自己创建自动释放池，否则可能会发生内存泄露。<br>  使用 NSThread 做多线程开发时,需要在线程调度方法中手动添加自动释放池。比如：<br>  MRC环境下: 采用 __block<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(execute) object:nil];</div><div class="line">[thread start];</div><div class="line">......</div><div class="line">- (void)execute&#123;</div><div class="line">  @autoreleasepool&#123;</div><div class="line">      NSTimer *timer ...</div><div class="line">      [[NSRunLoop currentRunLoop]addTimer:timer forMode:NSDefaultRunLoopMode];</div><div class="line">      [[NSRunLoop currentRunLoop]run];</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  循环中创建了许多临时对象，在循环里面使用自动释放池，用来减少高内存占用。举例：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  for (int i = 0; i &lt; largeNumber; ++i) &#123;</div><div class="line">  NSString *str = @&quot;Hello World&quot;;</div><div class="line">  str = [str stringByAppendingFormat:@&quot; - %d&quot;, i];</div><div class="line">  str = [str uppercaseString];</div><div class="line">  NSLog(@&quot;%@&quot;, str);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  运行这段代码，将会看到内存占用情况一直在增长，因为循环中的临时对象没有被释放掉。<br>  改进：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">  for (int i = 0; i &lt; largeNumber; ++i) &#123;</div><div class="line">  @autoreleasepool&#123;</div><div class="line">  ......要执行的代码</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  RunLoop 实现的功能比如事件响应、手势识别、界面更新、定时器、performSelector、GCD，笔者会在以后的博客里慢慢更新…</p>
]]></content>
      
        <categories>
            
            <category> NSRunLoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RunLoop </tag>
            
            <tag> NSRunLoop </tag>
            
            <tag> CFRunLoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Block精析]]></title>
      <url>/2016/08/02/blog_block/</url>
      <content type="html"><![CDATA[<p>工作中经常会使用到Block 但是对于Block你真正的了解吗？下面是我对 Block 的整理，从零开始，由浅入深，并且带了几个 Block 实际开发的应用场景和面试经常会被问到的问题。<br><a id="more"></a></p>
<h3 id="Block的概念"><a href="#Block的概念" class="headerlink" title="Block的概念"></a>Block的概念</h3><p>苹果的官方文档给出这样的一句话<br>Blocks are a language-level feature added to C, Objective-C and C++, which allow you to create distinct segments of code that can be passed around to methods or functions as if they were values.<br>翻译过来就是：Block是Apple Inc.为C、C++以及Objective-C添加的特性，可以创建不同代码段传递给方法或函数。<br>简单点来说Block 是一种特殊的数据类型(匿名的函数和代码块)，可以正常定义变量、作为参数、作为返回值；还可以保存一段代码，在需要的时候调用.当然你也可以理解成闭包(闭包:闭包就是能够读取其它函数内部变量的函数)。</p>
<h3 id="Block的声明-定义-类型-调用"><a href="#Block的声明-定义-类型-调用" class="headerlink" title="Block的声明,定义,类型,调用"></a>Block的声明,定义,类型,调用</h3><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p><code>声明格式:返回值(^block变量名)(参数)</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void(^block)(); 最纯洁的block,无返回值无参</div></pre></td></tr></table></figure></p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>1.无参数无返回值</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void(^block)() = ^()&#123;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>2.有参数</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void(^block)(NSInteger) = ^(key)&#123;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>3.省略返回值的</code><br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int(^block)() = ^int&#123;</div><div class="line">    return 0;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p><code>使用 typedef 定义 Block 类型</code><br><code>1. typedef void (^BlockType)();</code><br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) BlockType block;</div></pre></td></tr></table></figure></p>
<p><code>2. 如何声明 如何使用</code><br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) void(^block)();</div></pre></td></tr></table></figure></p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p><code>采用比较严谨的方式来调用</code><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) void(^blockName)(NSString *); 先定义</div><div class="line"></div><div class="line">if (self.blockName) &#123;</div><div class="line">    self.blockName(@&quot;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Block传值"><a href="#Block传值" class="headerlink" title="Block传值"></a>Block传值</h3><p>场景如下: A，B两个界面，A界面中有一个label，一个buttonA。点击buttonA进入B界面，B界面中有一个UITextfield和一个buttonB，点击buttonB退出B界面并将B界面中UITextfield的值传到A界面中的label<br>那么在A界面中 实例代码如下<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (IBAction)buttonAction &#123;  </div><div class="line">      MyBViewController *myVC = [[MyBViewController alloc] init];</div><div class="line">      [self presentViewController:myVC animated:YES completion:^&#123;    </div><div class="line">        &#125;];</div><div class="line">      __weak typeof(self) weakSelf = self;//防止循环引用</div><div class="line">      //用属性定义的注意：这里属性是不会自动补全的，方法就会自动补全</div><div class="line">      [myVC setBlock:^(NSString *string)&#123;</div><div class="line">          weakSelf.labelA.text = string;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>B界面的.h文件中代码如下<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) void(^block)(NSString *); 先定义</div></pre></td></tr></table></figure></p>
<p>B界面的.m文件中代码如下<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (IBAction)buttonBAction &#123;</div><div class="line">      [self dismissViewControllerAnimated:YES completion:^&#123;</div><div class="line">      &#125;];</div><div class="line">    self.block(_myTextfielf.text);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Block在MRC-amp-ARC下的内存管理"><a href="#Block在MRC-amp-ARC下的内存管理" class="headerlink" title="Block在MRC &amp; ARC下的内存管理"></a>Block在MRC &amp; ARC下的内存管理</h3><h4 id="MRC下Block内存管理"><a href="#MRC下Block内存管理" class="headerlink" title="MRC下Block内存管理"></a>MRC下Block内存管理</h4><p>MRC没有strong,weak,局部变量对象就是相当于基本数据类型（基本数据类型放在栈里，代码块结束就销毁）<br>MRC给成员属性赋值,一定要使用set方法,不能直接访问下划线成员属性赋值.</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void(^block)() = ^&#123;</div><div class="line">    NSLog(@&quot;block&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,block);</div><div class="line"></div><div class="line">2016-08-02 20:15:56.054 Block[23533:817404] &lt;__NSGlobalBlock__: 0x102080320&gt;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//static int a = 3;// 静态变量</div><div class="line">__block int a = 3;// 还是局部变量</div><div class="line">void(^block)() = ^&#123;</div><div class="line">    NSLog(@&quot;block%d&quot;,a);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,block);</div><div class="line"></div><div class="line">2016-08-02 20:22:12.458 Block[23762:824109] &lt;__NSMallocBlock__: 0x60800005eff0&gt;</div></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, retain) void(^block)();</div><div class="line"></div><div class="line">用retain打印输出：</div><div class="line">2016-03-30 20:31:06.321 Block[23953:833320] &lt;__NSMallocBlock__: 0x608000056530&gt;</div><div class="line"></div><div class="line">@property (nonatomic, copy) void(^block)();</div><div class="line"></div><div class="line">用copy打印输出：</div><div class="line">2016-08-02 20:34:06.872 Block[24033:837243] &lt;__NSGlobalBlock__: 0x10db8b320&gt;</div></pre></td></tr></table></figure>
<p>  根据打印出来的log 得出以下结论<br>  (1). 访问外界变量的 Block 默认存储栈中,反之则存储在全局区.<br>  (2). block只能使用copy,不能使用retain. 原因: 使用retain,block还是在栈里面（代码块结束就销毁），而使用copy，block就在堆里面.</p>
<h4 id="ARC下Block内存管理"><a href="#ARC下Block内存管理" class="headerlink" title="ARC下Block内存管理"></a>ARC下Block内存管理</h4><p>  只要一个对象没有被强指针修饰就会被销毁，默认局部变量对象都是强指针，存放到堆里面.<br>  ARC 环境下：访问外界变量的 Block 默认存储在堆中（实际是放在栈区，然后ARC情况下自动又拷贝到堆区），自动释放.<br>  Block自动从栈区拷贝到堆区的原因是:<br>  栈上的Block，如果其所属的变量作用域结束，该Block就被废弃，如同一般的自动变量。当然，Block中的__block变量也同时被废弃.</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-f9fd483f1373b1d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>  为了解决栈块在其变量作用域结束之后被废弃（释放）的问题，我们需要把Block复制到堆中，延长其生命周期。开启ARC时，大多数情况下编译器会恰当地进行判断是否有需要将Block从栈复制到堆，如果有，自动生成将Block从栈上复制到堆上的代码。Block的复制操作执行的是copy实例方法。Block只要调用了copy方法，栈块就会变成堆块。</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-043415086438ba0b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"><br>    Block的复制操作执行的是copy实例方法。不同类型的Block使用copy方法的效果如下表：</p>
<p>  <img src="http://upload-images.jianshu.io/upload_images/1853274-b72a460029a468ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<pre><code>根据表得知，Block在堆中copy会造成引用计数增加，这与其他Objective-C对象是一样的。虽然Block在栈中也是以对象的身份存在，但是栈块没有引用计数，因为不需要，我们都知道栈区的内存由编译器自动分配释放.

the end:不管Block存储域在何处，用copy方法复制都不会引起任何问题。在不确定时调用copy方法即可.

### 防止Block循环引用 ###  
ARC环境下: 采用 __weak
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__weak typeof(self) weakSelf = self;</div><div class="line">    self.block = ^(Type var)&#123;</div><div class="line">    [weakSelf do];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

MRC环境下: 采用 __block
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">__block typeof(self) blockSelf = self;</div><div class="line">    self.block = ^(Type var)&#123;</div><div class="line">    [blockSelf do];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</code></pre><h3 id="Block当参数使用"><a href="#Block当参数使用" class="headerlink" title="Block当参数使用"></a>Block当参数使用</h3><p>(1).怎么区分参数是block,就看有没有^,只要有^.把block当做参数.</p>
<p>(2).把block当做参数,并不是马上就调用Block,什么时候调用,由方法内部决定.</p>
<p>(3).什么时候需要把block当做参数去使用：做的事情由外界(非本类)决定,但是什么时候做由内部决定.</p>
<h3 id="Block当返回值"><a href="#Block当返回值" class="headerlink" title="Block当返回值"></a>Block当返回值</h3><p>(1).这里体现了一种思想：链式编程思想：把所有的语句用.号连接起来, 好处:可读性非常好.</p>
<p>(2).把Block当返回值使用，经典框架 Masonry.</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void(^)())test &#123;</div><div class="line">    return ^&#123;</div><div class="line">    NSLog(@&quot;调用了block&quot;);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">self.test();</div><div class="line"></div><div class="line">self.test(); 发两步：1、self.test是调用get方法，返回一个block，2、self.test()调用block.</div></pre></td></tr></table></figure>
</code></pre><h3 id="Block底层实现"><a href="#Block底层实现" class="headerlink" title="Block底层实现"></a>Block底层实现</h3><p>block是一个指针结构体，在终端下使用LLVM编译器的clang命令可将含有Block的Objective-C代码转换成C++的源代码，以探查其具体实现方式：</p>
<p>clang -rewrite-objc 源码文件名</p>
<p>创建main.m文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        void (^myblock)() = ^() &#123;</div><div class="line">            NSLog(@&quot;block&quot;);</div><div class="line">        &#125;;</div><div class="line">        myblock();</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>利用终端编译生成C++代码：clang -rewrite-objc main.m</p>
<p>结构体和函数<br>(1). <strong>block_impl：这是一个结构体，也是C面向对象的体现，可以理解为block的基类;<br>(2). </strong>main_block_impl_0: 可以理解为block变量;<br>(3). <strong>main_block_func_0: 可以理解为匿名函数；<br>(4). </strong>main_block_desc_0: block的描述,Block_size;</p>
<h3 id="block的三种类型-全局块-栈块-堆块"><a href="#block的三种类型-全局块-栈块-堆块" class="headerlink" title="block的三种类型(全局块,栈块,堆块)"></a>block的三种类型(全局块,栈块,堆块)</h3><p>全局块(_NSConcreteGlobalBlock)<br>栈块(_NSConcreteStackBlock)<br>堆块(_NSConcreteMallocBlock)<br>如图所示</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1853274-4c82c43f97f31f00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"><br>全局块存在于全局内存中, 相当于单例.<br>栈块存在于栈内存中, 超出其作用域则马上被销毁.<br>堆块存在于堆内存中, 是一个带引用计数的对象, 需要自行管理其内存.<br>the end:存储在栈中的Block就是栈块、存储在堆中的就是堆块、既不在栈中也不在堆中的块就是全局块</p>
]]></content>
      
        <categories>
            
            <category> Block私房笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS知识点]]></title>
      <url>/2016/07/18/blog_iOSStudy/</url>
      <content type="html"><![CDATA[<p>易忘的小知识,没事拿出来看看~~~~<br><a id="more"></a><br><strong>设计模式是什么？ 你知道哪些设计模式，并简要叙述？</strong></p>
<p>设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。</p>
<p>(1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。</p>
<p>(2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。</p>
<p>(3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。</p>
<p>(4). 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。</p>
<p>(5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。</p>
<p>(6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。</p>
<p><strong>MVC 和 MVVM 的区别</strong></p>
<p>(1). MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。</p>
<p>(2). MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。</p>
<p><strong>#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</strong></p>
<p>答：</p>
<p>(1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。</p>
<p>(2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。</p>
<p>(3). #import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</p>
<p><strong>frame 和 bounds 有什么不同？</strong></p>
<p>frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)</p>
<p>bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)</p>
<p><strong>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</strong></p>
<p>答：Objective-C的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p>
<p><strong>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</strong></p>
<p>@property 的本质是什么？</p>
<p>@property = ivar + getter + setter;</p>
<p>“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）</p>
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。</p>
<p><strong>@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</strong></p>
<p>属性可以拥有的特质分为四类:</p>
<p>1.原子性— nonatomic 特质</p>
<p>2.读/写权限—readwrite(读写)、readonly (只读)</p>
<p>3.内存管理语义—assign、strong、 weak、unsafe_unretained、copy</p>
<p>4.方法名—getter=<name> 、setter=<name></name></name></p>
<p>5.不常用的：nonnull,null_resettable,nullable</p>
<p><strong>属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</strong></p>
<p>答：</p>
<p>(1). readwrite 是可读可写特性。需要生成getter方法和setter方法。</p>
<p>(2). readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。</p>
<p>(3). assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型。</p>
<p>(4). retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。</p>
<p>(5). copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。</p>
<p>(6). nonatomic 非原子操作。决定编译器生成的setter和getter方法是否是原子操作，atomic表示多线程安全，一般使用nonatomic，效率高。</p>
<p><strong>什么情况使用 weak 关键字，相比 assign 有什么不同？</strong></p>
<p>1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。</p>
<p>2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</p>
<p>IBOutlet连出来的视图属性为什么可以被设置成weak?</p>
<p>因为父控件的subViews数组已经对它有一个强引用。</p>
<p>不同点：</p>
<p>assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。</p>
<p>weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。</p>
<p><strong>怎么用 copy 关键字？</strong></p>
<p> 用途：</p>
<ol>
<li><p>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p>
</li>
<li><p>block 也经常使用 copy 关键字。</p>
<p>说明：</p>
<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</p>
</li>
</ol>
<p><strong>用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</strong></p>
<p>答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<ol>
<li><p>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</p>
</li>
<li><p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</p>
</li>
</ol>
<p>//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</p>
<p><strong>浅拷贝和深拷贝的区别？</strong></p>
<p>答：</p>
<p>浅拷贝：只复制指向对象的指针，而不复制引用对象本身。</p>
<p>深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。</p>
<p><strong>系统对象的 copy 与 mutableCopy 方法</strong></p>
<p>不管是集合类对象（NSArray、NSDictionary、NSSet … 之类的对象），还是非集合类对象（NSString, NSNumber … 之类的对象），接收到copy和mutableCopy消息时，都遵循以下准则：</p>
<ol>
<li><p>copy 返回的是不可变对象（immutableObject）；如果用copy返回值调用mutable对象的方法就会crash。</p>
</li>
<li><p>mutableCopy 返回的是可变对象（mutableObject）。</p>
</li>
</ol>
<p>一、非集合类对象的copy与mutableCopy</p>
<p>  在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</p>
<p>  对可变对象进行copy和mutableCopy都是内容复制。</p>
<p>二、集合类对象的copy与mutableCopy (同上)</p>
<p>  在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</p>
<p>  对可变对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)</p>
<p>【总结一句话】：</p>
<p>只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）！</p>
<p><strong>这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;</strong></p>
<p>问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。</p>
<p>//如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</p>
<p>// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）</p>
<p>原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。</p>
<p><strong>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</strong></p>
<p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</p>
<p>具体步骤：</p>
<ol>
<li><p>需声明该类遵从 NSCopying 协议</p>
</li>
<li><p>实现 NSCopying 协议的方法。</p>
</li>
</ol>
<p>// 该协议只有一个方法:</p>
<p>- (id)copyWithZone:(NSZone *)zone;</p>
<p>// 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。</p>
<p><strong>@synthesize 和 @dynamic 分别有什么作用？</strong></p>
<p>@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic。</p>
<p>如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;</p>
<p>// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</p>
<ol>
<li><p>@synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</p>
</li>
<li><p>@dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。</p>
</li>
</ol>
<p><strong>常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int</strong></p>
<p>答：</p>
<p>Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。</p>
<p><strong>id 声明的对象有什么特性？</strong></p>
<p>答：id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。</p>
<p><strong>Objective-C 如何对内存管理的，说说你的看法和解决方法？</strong></p>
<p>答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</p>
<p>(1). 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。</p>
<p>(2). 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。</p>
<p>(3). 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</p>
<p><strong>Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？</strong></p>
<p>答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread</p>
<p><strong>Category（类别）、 Extension（扩展）和继承的区别</strong></p>
<p>区别：</p>
<ol>
<li><p>分类有名字，类扩展没有分类名字，是一种特殊的分类。</p>
</li>
<li><p>分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。</p>
</li>
<li><p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
</li>
</ol>
<p><strong>我们说的OC是动态运行时语言是什么意思？</strong></p>
<p>答：主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。</p>
<p><strong>为什么我们常见的delegate属性都用是week而不是retain/strong？</strong></p>
<p>答：是为了防止delegate两端产生不必要的循环引用。</p>
<p><strong>什么时候用delete，什么时候用Notification？</strong></p>
<p>Delegate(委托模式)：1对1的反向消息通知功能。</p>
<p>Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</p>
<p><strong>什么是 KVO 和 KVC？</strong></p>
<p>(1). KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）</p>
<p>举例说明：</p>
<blockquote>
<p>   stu.name = @”张三” // 点语法给属性赋值</p>
<p>   [stu setValue:@”张三” forKey:@”name”]; // 通过字符串使用KVC方式给属性赋值</p>
<p>   stu1.nameLabel.text = @”张三”;</p>
<p>   [stu1 setValue:@”张三” forKey:@”nameLabel.text”]; // 跨层赋值</p>
</blockquote>
<p>2). KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。</p>
<p>​     KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。</p>
<p>KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。</p>
<p><strong>KVC的底层实现？</strong></p>
<p>当一个对象调用setValue方法时，方法内部会做以下操作：</p>
<p>(1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。</p>
<p>(2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。</p>
<p>(3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</p>
<p>(4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。</p>
<p>这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</p>
<p><strong>KVO的底层实现？</strong></p>
<p>KVO基于runtime机制实现。</p>
<p><strong>ViewController生命周期</strong></p>
<p>按照执行顺序排列：</p>
<ol>
<li><p>initWithCoder：通过nib文件初始化时触发。</p>
</li>
<li><p>awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。      </p>
</li>
<li><p>loadView：开始加载视图控制器自带的view。</p>
</li>
<li><p>viewDidLoad：视图控制器的view被加载完成。  </p>
</li>
<li><p>viewWillAppear：视图控制器的view将要显示在window上。</p>
</li>
<li><p>updateViewConstraints：视图控制器的view开始更新AutoLayout约束。</p>
</li>
<li><p>viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。</p>
</li>
<li><p>viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。</p>
</li>
<li><p>viewDidAppear：视图控制器的view已经展示到window上。</p>
</li>
<li><p>viewWillDisappear：视图控制器的view将要从window上消失。</p>
</li>
<li><p>viewDidDisappear：视图控制器的view已经从window上消失。</p>
</li>
</ol>
<p><strong>方法和选择器有何不同？</strong></p>
<p>selector是一个方法的名字，方法是一个组合体，包含了名字和实现。</p>
<p><strong>你是否接触过OC中的反射机制？简单聊一下概念和使用</strong></p>
<p>(1). class反射</p>
<p>通过类名的字符串形式实例化对象。</p>
<blockquote>
<p>Class class = NSClassFromString(@”student”);</p>
<p>Student *stu = [[class alloc] init];</p>
</blockquote>
<p>将类名变为字符串。</p>
<blockquote>
<p>Class class =[Student class];</p>
<p>NSString *className = NSStringFromClass(class);</p>
</blockquote>
<p>(2). SEL的反射</p>
<p>通过方法的字符串形式实例化方法。</p>
<blockquote>
<p>SEL selector = NSSelectorFromString(@”setName”);  </p>
<p>[stu performSelector:selector withObject:@”Mike”];</p>
</blockquote>
<p>将方法变成字符串。</p>
<blockquote>
<p>NSStringFromSelector(@selector*(setName:));</p>
</blockquote>
<p><strong>调用方法有两种方式：</strong></p>
<p>(1). 直接通过方法名来调用。[person show];</p>
<p>(2). 间接的通过SEL数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];  </p>
<p><strong>如何对iOS设备进行性能测试？</strong></p>
<p>答： Profile-&gt; Instruments -&gt;Time Profiler</p>
<p><strong>开发项目时你是怎么检查内存泄露？</strong></p>
<p>(1). 静态分析 analyze。</p>
<p>(2). instruments工具里面有个leak可以动态分析。</p>
<p><strong>什么是懒加载？</strong></p>
<p>答：懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。</p>
<p>我觉得最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。</p>
<p><strong>类变量的 @public，@protected，@private，@package 声明各有什么含义？</strong></p>
<p>@public 任何地方都能访问;</p>
<p>@protected 该类和子类中访问,是默认的;</p>
<p>@private 只能在本类中访问;</p>
<p>@package 本包内使用,跨包不可以。</p>
<p><strong>什么是谓词？</strong></p>
<p>谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选。</p>
<p>//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)</p>
<p>NSPredicate *predicate = [NSPredicate predicateWithFormat:@”age&lt;%d”,30];</p>
<p>//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果</p>
<p>NSArray *array = [persons filteredArrayUsingPredicate:predicate];</p>
<p><strong>isa指针问题</strong></p>
<p>isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。</p>
<p><strong>如何访问并修改一个类的私有属性？</strong></p>
<p>(1). 一种是通过KVC获取。</p>
<p>(2). 通过runtime访问并修改私有属性。</p>
<p><strong>一个objc对象的isa的指针指向什么？有什么作用？</strong></p>
<p>答：指向他的类对象,从而可以找到对象上的方法。</p>
<p><strong>isKindOfClass、isMemberOfClass、selector作用分别是什么</strong></p>
<p>isKindOfClass：作用是某个对象属于某个类型或者继承自某类型。</p>
<p>isMemberOfClass：某个对象确切属于某个类型。</p>
<p>selector：通过方法名，获取在内存中的函数的入口地址。</p>
<p><strong>delegate 和 notification 的区别</strong></p>
<p>(1). 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。</p>
<p>(2). notification通过维护一个array，实现一对多消息的转发。</p>
<p>(3). delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。</p>
<p><strong>什么是block？</strong></p>
<p>闭包（block）：闭包就是获取其它函数局部变量的匿名函数。</p>
<p><strong>block反向传值</strong></p>
<p>在控制器间传值可以使用代理或者block，使用block相对来说简洁。</p>
<p><strong>block的注意点</strong></p>
<p>(1). 在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：</p>
<p>__weak typeof(self) weakSelf = self;</p>
<p>(2). 在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。</p>
<p>__strong typeof(self) strongSelf = weakSelf;</p>
<p>(3). 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。</p>
<p><strong>BAD_ACCESS在什么情况下出现？</strong></p>
<p>答：这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</p>
<p><strong>lldb（gdb）常用的控制台调试命令？</strong></p>
<p>(1). p 输出基本类型。是打印命令，需要指定类型。是print的简写</p>
<p>p (int)[[[self view] subviews] count]</p>
<p>(2). po 打印对象，会调用对象description方法。是print-object的简写</p>
<p>po [self view]</p>
<p>(3). expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。</p>
<p>(4). bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈</p>
<p>(5). br l：是breakpoint list的简写</p>
<p><strong>你一般是怎么用Instruments的？</strong></p>
<p>Instruments里面工具很多，常用：</p>
<p>(1). Time Profiler: 性能分析</p>
<p>(2). Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。</p>
<p>(3). Allocations：用来检查内存，写算法的那批人也用这个来检查。</p>
<p>(4). Leaks：检查内存，看是否有内存泄露。</p>
<p><strong>iOS中常用的数据存储方式有哪些？</strong></p>
<p>数据存储有四种方案：NSUserDefault、KeyChain、file、DB。</p>
<p>其中File有三种方式：plist、Archive（归档）</p>
<p>DB包括：SQLite、FMDB、CoreData</p>
<p><strong>iOS的沙盒目录结构是怎样的？</strong></p>
<p>沙盒结构：</p>
<p>(1). Application：存放程序源文件，上架前经过数字签名，上架后不可修改。</p>
<p>(2). Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）</p>
<p>(3). Library：</p>
<p>Caches：存放体积大又不需要备份的数据。(常用的缓存路径)</p>
<p>Preference：设置目录，iCloud会备份设置信息。</p>
<p>(4). tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</p>
<p><strong>iOS多线程技术有哪几种方式？</strong></p>
<p>答：pthread、NSThread、GCD、NSOperation</p>
<p><strong>GCD 与 NSOperation 的区别：</strong></p>
<p>GCD 和 NSOperation 都是用于实现多线程：</p>
<p>GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。</p>
<p>NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。</p>
<p><strong>写出使用GCD方式从子线程回到主线程的方法代码</strong></p>
<p>答：</p>
<blockquote>
<p>dispatch_sync(dispatch_get_main_queue(), ^{ });</p>
</blockquote>
<p><strong>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</strong><br><strong>dispatch_barrier_async（栅栏函数）的作用是什么？</strong></p>
<p>函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</p>
<p>作用：</p>
<p>1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。</p>
<p>2.避免数据竞争<br><strong>什么是 RunLoop</strong></p>
<p>从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。</p>
<p>一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。</p>
<p>主线程的run loop默认是启动的。</p>
<p><strong>什么是 Runtime</strong></p>
<p>Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。</p>
<p><strong>Runtime实现的机制是什么，怎么用，一般用于干嘛？</strong></p>
<p>1). 使用时需要导入的头文件 <objc message.h=""> <objc runtime.h=""></objc></objc></p>
<p>2). Runtime 运行时机制，它是一套C语言库。</p>
<p>3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</p>
<p>比如：</p>
<p>类转成了 Runtime 库里面的结构体等数据类型，</p>
<p>方法转成了 Runtime 库里面的C语言函数，</p>
<p>平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制）</p>
<p>// OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
<p>// [stu show];  在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));</p>
<p>4). 因此，可以说 Runtime 是OC的底层实现，是OC的幕后执行者。</p>
<p>有了Runtime库，能做什么事情呢？</p>
<p> Runtime库里面包含了跟类、成员变量、方法相关的API。</p>
<p> 比如：</p>
<p>​    （1）获取类里面的所有成员变量。</p>
<p>​    （2）为类动态添加成员变量。</p>
<p>​    （3）动态改变类的方法实现。</p>
<p>​    （4）为类动态添加新的方法等。</p>
<p> 因此，有了Runtime，想怎么改就怎么改。</p>
<p><strong>什么是 Method Swizzle（黑魔法），什么情况下会使用？</strong></p>
<p>(1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。</p>
<p>(2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。</p>
<p>(3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。</p>
<p>(4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。</p>
<p>(5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。</p>
<p>(6). 我们可以利用 class_replaceMethod 来修改类。</p>
<p>(7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。</p>
<p>(8). 归根结底，都是偷换了selector的IMP。</p>
<p><strong>_objc_msgForward 函数是做什么的，直接调用它将会发生什么？</strong></p>
<p>答：_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</p>
<p><strong>什么是 TCP / UDP ?</strong></p>
<p>TCP：传输控制协议。</p>
<p>UDP：用户数据协议。</p>
<p>TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。</p>
<p>UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。</p>
<p>简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。</p>
<p><strong>通信底层原理（OSI七层模型）</strong></p>
<p>OSI采用了分层的结构化技术，共分七层：</p>
<p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>介绍一下XMPP？</strong></p>
<p>XMPP是一种以XML为基础的开放式实时通信协议。</p>
<p>简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。<br><strong>tableView的重用机制？</strong></p>
<p>答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</p>
<p><strong>如何实现视图的变形?</strong></p>
<p>答：通过修改view的 transform 属性即可。</p>
<p><strong>在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</strong></p>
<p>答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。</p>
<p><strong>字符串常用方法：</strong></p>
<p>NSString <em>str = @”abc</em>123”;</p>
<p>NSArray <em>arr = [str componentsSeparatedByString:@”</em>“]; //以目标字符串把原字符串分割成两部分，存到数组中。@[@”abc”, @”123”];</p>
<p><strong>你是怎么封装一个view的</strong></p>
<p>(1）. 可以通过纯代码或者xib的方式来封装子控件</p>
<p>(2）. 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值<br><strong>HTTP协议中 POST 方法和 GET 方法有那些区别?</strong></p>
<ol>
<li><p>GET用于向服务器请求数据，POST用于提交数据</p>
</li>
<li><p>GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作</p>
</li>
<li><p>GET请求的URL有长度限制，POST请求不会有长度限制</p>
</li>
</ol>
<p><strong>请简单的介绍下APNS发送系统消息的机制</strong></p>
<p>APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。</p>
<p>APNS的原理：</p>
<p>(1). 应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)</p>
<p>(2). 应用程序接收到设备令牌并发送给自己的后台服务器</p>
<p>(3). 服务器把要推送的内容和设备发送给APNS</p>
<p>(4). APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示</p>
<p><strong>第三方框架</strong></p>
<hr>
<p><strong>AFNetworking 底层原理分析</strong></p>
<p>AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:</p>
<p>(1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)</p>
<p>(2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。</p>
<p>(3). AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。</p>
<p>(4). AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。</p>
<p>(5). AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式</p>
<p>(AFJSONRequestSerializer).使用不多。</p>
<p>(6). AFURLResponseSerialization：反序列化工具类;基类.使用比较多:</p>
<p>(7). AFJSONResponseSerializer; JSON解析器,默认的解析器.</p>
<p>(8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理.</p>
<p>(9). AFXMLParserResponseSerializer; XML解析器;</p>
<p><strong>描述下SDWebImage里面给UIImageView加载图片的逻辑</strong></p>
<p>SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。</p>
<p>​    </p>
<p>加载图片的过程大致如下：</p>
<p>1.首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存</p>
<p>2.如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来</p>
<p>3.如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片</p>
<p>4.下载后的图片会加入缓存中，并写入磁盘中</p>
<p>5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来</p>
<p>SDWebImage原理：</p>
<p>调用类别的方法：</p>
<ol>
<li><p>从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。</p>
</li>
<li><p>从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。</p>
</li>
<li><p>从网络上获取，使用，缓存到内存，缓存到沙盒。</p>
</li>
</ol>
<p><strong>友盟统计接口统计的所有功能</strong></p>
<p>APP启动速度，APP停留页面时间等</p>
<p><strong>算法</strong></p>
<hr>
<p><strong>模拟栈操作</strong></p>
<blockquote>
<p> /**</p>
<ul>
<li><p>栈是一种数据结构，特点：先进后出</p>
</li>
<li><p>练习：使用全局变量模拟栈的操作</p>
<p>*/</p>
</li>
</ul>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdbool.h></stdbool.h></p>
<p>#include <assert.h></assert.h></p>
<p>//保护全局变量：在全局变量前加static后，这个全局变量就只能在本文件中使用</p>
<p>static int data[1024];//栈最多能保存1024个数据</p>
<p>static int count = 0;//目前已经放了多少个数(相当于栈顶位置)</p>
<p>//数据入栈 push</p>
<p>void push(int x){</p>
<p>  assert(!full());//防止数组越界</p>
<p>data[count++] = x;</p>
<p>}</p>
<p>//数据出栈 pop</p>
<p>int pop(){</p>
<p>assert(!empty());</p>
<p>return data[–count];</p>
<p>}</p>
<p>//查看栈顶元素 top</p>
<p>int top(){</p>
<p>assert(!empty());</p>
<p>return data[count-1];</p>
<p>}</p>
<p>//查询栈满 full</p>
<p>bool full() {</p>
<p>if(count &gt;= 1024) {</p>
<p>​     return 1;</p>
<p>}</p>
<p>​     return 0;</p>
<p>}</p>
<p>//查询栈空 empty</p>
<p>bool empty() {</p>
<p>if(count &lt;= 0) {</p>
<p>return 1;</p>
<p>}</p>
<p>​    return 0;</p>
<p>}</p>
<p>int main(){</p>
<p>​    //入栈</p>
<p>​    for (int i = 1; i &lt;= 10; i++) {</p>
<p>​        push(i);</p>
<p>​    }</p>
<p>​    //出栈</p>
<p>​    while(!empty()){</p>
<p>​        printf(“%d “, top()); //栈顶元素</p>
<p>​        pop(); //出栈</p>
<p>​    }</p>
<p>​    printf(“ “);</p>
<p>​    </p>
<p>​    return 0;</p>
<p>}</p>
</blockquote>
<p><strong>排序算法</strong></p>
<p>选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：</p>
<ul>
<li>都将数组分为已排序部分和未排序部分。</li>
</ul>
<ol>
<li><p>选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</p>
</li>
<li><p>冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</p>
</li>
<li><p>插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。</p>
</li>
</ol>
<p><strong>编码格式（优化细节）</strong></p>
<p>在 Objective-C 中，enum 建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型。</p>
<p>避免使用C语言中的基本数据类型，建议使用 Foundation 数据类型，对应关系如下：</p>
<p>int -&gt; NSInteger</p>
<p>unsigned -&gt; NSUInteger</p>
<p>float -&gt; CGFloat</p>
<p>动画时间 -&gt; NSTimeInterval</p>
<p><strong>其它知识点</strong></p>
<p><strong>HomeKit</strong>，是苹果2014年发布的智能家居平台。</p>
<p><strong>什么是 OpenGL、Quartz 2D？</strong></p>
<p>Quatarz 2d 是Apple提供的基本图形工具库。只是适用于2D图形的绘制。</p>
<p>OpenGL，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。</p>
<p><strong>ffmpeg框架</strong>：ffmpeg 是音视频处理工具，既有音视频编码解码功能，又可以作为播放器使用。</p>
<p><strong>谈谈 UITableView 的优化</strong></p>
<p>(1). 正确的复用cell。</p>
<p>(2). 设计统一规格的Cell</p>
<p>(3). 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；</p>
<p>(4). 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；</p>
<p>(4). 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！</p>
<p>(5). 减少子视图的层级关系</p>
<p>(6). 尽量使所有的视图不透明化以及做切圆操作。</p>
<p>(7). 不要动态的add 或者 remove 子控件。最好在初始化时就添加完，然后通过hidden来控制是否显示。</p>
<p>(8). 使用调试工具分析问题。</p>
<p><strong>如何实行cell的动态的行高</strong></p>
<p>如果希望每条数据显示自身的行高，必须设置两个属性，1.预估行高，2.自定义行高。</p>
<p>设置预估行高 tableView.estimatedRowHeight = 200。</p>
<p>设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension。</p>
<p>如果要让自定义行高有效，必须让容器视图有一个自下而上的约束。</p>
<p><strong>说说你对 block 的理解</strong></p>
<p>栈上的自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。</p>
<p><strong>说说你对 runtime 的理解</strong></p>
<p>主要是方法调用时如何查找缓存，如何找到方法，找不到方法时怎么转发，对象的内存布局。</p>
<p><strong>什么是野指针、空指针？</strong></p>
<p>野指针：不知道指向了哪里的指针叫野指针。即指针指向不确定，指针存的地址是一个垃圾值，未初始化。</p>
<p>空指针：不指向任何位置的指针叫空指针。即指针没有指向，指针存的地址是一个空地址，NULL。</p>
<p><strong>什么是 OOA / OOD / OOP ?</strong></p>
<p>OOA（Object Oriented Analysis）   –面向对象分析</p>
<p>OOD（Object Oriented Design）     –面向对象设计</p>
<p>OOP（Object Oriented Programming）–面向对象编程</p>
]]></content>
      
        <categories>
            
            <category> iOS基本知识回顾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> runtime </tag>
            
            <tag> runloop </tag>
            
            <tag> block </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS常用代码段]]></title>
      <url>/2016/05/21/blog_littleKey/</url>
      <content type="html"><![CDATA[<p>笔者最近读了一本书叫做《编写高质量 iOS 与 OSX 代码的52个有效方法》,没错，就是这本书，读完这本书，对于代码标准和规范我就格外上心了，但是自己也做了笔记，大概就是一下这些，其实都很基础啦，但是呢，有时候真的想不起来，哈哈，你们有木有呢？<br><a id="more"></a></p>
<h3 id="1、设置UILabel行间距"><a href="#1、设置UILabel行间距" class="headerlink" title="1、设置UILabel行间距"></a>1、设置UILabel行间距</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];    [style setLineSpacing:20];    [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];    label.attributedText = attrString;</div></pre></td></tr></table></figure>
<h3 id="2、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题"><a href="#2、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题" class="headerlink" title="2、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题"></a>2、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、// 把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典NSArray * array =     [NSArray arrayWithObjects: @&quot;first&quot;, @&quot;second&quot;, nil];[self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0];// 方法二、// 使用NSInvocationSEL aSelector = NSSelectorFromString(@&quot;doSoming:argument2:&quot;);    NSInteger argument1 = 10;    NSString *argument2 = @&quot;argument2&quot;;    if([self respondsToSelector:aSelector]) &#123;        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];        [inv setSelector:aSelector];        [inv setTarget:self];        [inv setArgument:&amp;(argument1) atIndex:2];        [inv setArgument:&amp;(argument2) atIndex:3];        [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];    &#125;</div></pre></td></tr></table></figure>
<h3 id="3、UILabel显示不同颜色字体"><a href="#3、UILabel显示不同颜色字体" class="headerlink" title="3、UILabel显示不同颜色字体"></a>3、UILabel显示不同颜色字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];label.attributedText = string;</div></pre></td></tr></table></figure>
<h3 id="4、比较两个CGRect-CGSize-CGPoint是否相等"><a href="#4、比较两个CGRect-CGSize-CGPoint是否相等" class="headerlink" title="4、比较两个CGRect/CGSize/CGPoint是否相等"></a>4、比较两个CGRect/CGSize/CGPoint是否相等</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (CGRectEqualToRect(rect1, rect2)) &#123; // 两个区域相等        // do some    &#125;    if (CGPointEqualToPoint(point1, point2)) &#123; // 两个点相等        // do some    &#125;    if (CGSizeEqualToSize(size1, size2)) &#123; // 两个size相等        // do some    &#125;</div></pre></td></tr></table></figure>
<h3 id="5、比较两个NSDate相差多少小时"><a href="#5、比较两个NSDate相差多少小时" class="headerlink" title="5、比较两个NSDate相差多少小时"></a>5、比较两个NSDate相差多少小时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSDate* date1 = someDate; NSDate* date2 = someOtherDate; NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2]; double secondsInAnHour = 3600;// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数 NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour;</div></pre></td></tr></table></figure>
<h3 id="6、每个cell之间增加间距"><a href="#6、每个cell之间增加间距" class="headerlink" title="6、每个cell之间增加间距"></a>6、每个cell之间增加间距</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123;    return yourArry.count;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;    return 1;&#125;-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123;    return cellSpacingHeight;&#125;// 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。// 方法三，自定义cell，重写setFrame：方法- (void)setFrame:(CGRect)frame&#123;    frame.size.height -= 20;    [super setFrame:frame];&#125;</div></pre></td></tr></table></figure>
<h3 id="7、播放一张张连续的图片"><a href="#7、播放一张张连续的图片" class="headerlink" title="7、播放一张张连续的图片"></a>7、播放一张张连续的图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 加入现在有三张图片分别为animate_1、animate_2、animate_3// 方法一    imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]];imageView.animationDuration = 1.0;// 方法二    imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0];// 方法二解释下，这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024</div></pre></td></tr></table></figure>
<h3 id="8、加载gif图片"><a href="#8、加载gif图片" class="headerlink" title="8、加载gif图片"></a>8、加载gif图片</h3><blockquote>
<p>推荐使用这个框架 FLAnimatedImage</p>
</blockquote>
<h3 id="9、防止离屏渲染为image添加圆角"><a href="#9、防止离屏渲染为image添加圆角" class="headerlink" title="9、防止离屏渲染为image添加圆角"></a>9、防止离屏渲染为image添加圆角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// image分类- (UIImage *)circleImage&#123;// NO代表透明UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);// 获得上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 添加一个圆CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);// 方形变圆形CGContextAddEllipseInRect(ctx, rect);// 裁剪CGContextClip(ctx);// 将图片画上去[self drawInRect:rect];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return image;&#125;</div></pre></td></tr></table></figure>
<h3 id="10、查看系统所有字体"><a href="#10、查看系统所有字体" class="headerlink" title="10、查看系统所有字体"></a>10、查看系统所有字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 打印字体for (id familyName in [UIFont familyNames]) &#123;    NSLog(@&quot;%@&quot;, familyName);    for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@&quot;  %@&quot;, fontName);&#125;// 也可以进入这个网址查看 http://iosfonts.com/</div></pre></td></tr></table></figure>
<h3 id="11、获取随机数"><a href="#11、获取随机数" class="headerlink" title="11、获取随机数"></a>11、获取随机数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSInteger i = arc4random();</div></pre></td></tr></table></figure>
<h3 id="12、获取随机数小数-0-1之间"><a href="#12、获取随机数小数-0-1之间" class="headerlink" title="12、获取随机数小数(0-1之间)"></a>12、获取随机数小数(0-1之间)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ARC4RANDOM_MAX      0x100000000double val = ((double)arc4random() / ARC4RANDOM_MAX);</div></pre></td></tr></table></figure>
<h3 id="13、AVPlayer视频播放完成的通知监听"><a href="#13、AVPlayer视频播放完成的通知监听" class="headerlink" title="13、AVPlayer视频播放完成的通知监听"></a>13、AVPlayer视频播放完成的通知监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter]       addObserver:self      selector:@selector(videoPlayEnd)      name:AVPlayerItemDidPlayToEndTimeNotification       object:nil];</div></pre></td></tr></table></figure>
<h3 id="14、判断两个rect是否有交叉"><a href="#14、判断两个rect是否有交叉" class="headerlink" title="14、判断两个rect是否有交叉"></a>14、判断两个rect是否有交叉</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (CGRectIntersectsRect(rect1, rect2)) &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="15、判断一个字符串是否为数字"><a href="#15、判断一个字符串是否为数字" class="headerlink" title="15、判断一个字符串是否为数字"></a>15、判断一个字符串是否为数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];    if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)    &#123;      // 是数字    &#125; else    &#123;      // 不是数字    &#125;</div></pre></td></tr></table></figure>
<h3 id="16、将一个view保存为pdf格式"><a href="#16、将一个view保存为pdf格式" class="headerlink" title="16、将一个view保存为pdf格式"></a>16、将一个view保存为pdf格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename&#123;    NSMutableData *pdfData = [NSMutableData data];    UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);    UIGraphicsBeginPDFPage();    CGContextRef pdfContext = UIGraphicsGetCurrentContext();    [aView.layer renderInContext:pdfContext];    UIGraphicsEndPDFContext();    NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);    NSString* documentDirectory = [documentDirectories objectAtIndex:0];    NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];    [pdfData writeToFile:documentDirectoryFilename atomically:YES];    NSLog(@&quot;documentDirectoryFileName: %@&quot;,documentDirectoryFilename);&#125;</div></pre></td></tr></table></figure>
<h3 id="17、让一个view在父视图中心"><a href="#17、让一个view在父视图中心" class="headerlink" title="17、让一个view在父视图中心"></a>17、让一个view在父视图中心</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child.center = [parent convertPoint:parent.center fromView:parent.superview];</div></pre></td></tr></table></figure>
<h3 id="18、获取当前导航控制器下前一个控制器"><a href="#18、获取当前导航控制器下前一个控制器" class="headerlink" title="18、获取当前导航控制器下前一个控制器"></a>18、获取当前导航控制器下前一个控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)backViewController&#123;    NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self];    if ( myIndex != 0 &amp;&amp; myIndex != NSNotFound ) &#123;        return [self.navigationController.viewControllers objectAtIndex:myIndex-1];    &#125; else &#123;        return nil;    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="19、保存UIImage到本地"><a href="#19、保存UIImage到本地" class="headerlink" title="19、保存UIImage到本地"></a>19、保存UIImage到本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Image.png&quot;];[UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];</div></pre></td></tr></table></figure>
<h3 id="20、键盘上方增加工具栏"><a href="#20、键盘上方增加工具栏" class="headerlink" title="20、键盘上方增加工具栏"></a>20、键盘上方增加工具栏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init];[keyboardDoneButtonView sizeToFit];UIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;Done&quot;                                                               style:UIBarButtonItemStyleBordered target:self                                                              action:@selector(doneClicked:)];[keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]];txtField.inputAccessoryView = keyboardDoneButtonView;</div></pre></td></tr></table></figure>
<h3 id="21、copy一个view"><a href="#21、copy一个view" class="headerlink" title="21、copy一个view"></a>21、copy一个view</h3><blockquote>
<p>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃<br>但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id copyOfView = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]];</div></pre></td></tr></table></figure>
<h3 id="22、在image上绘制文字并生成新的image"><a href="#22、在image上绘制文字并生成新的image" class="headerlink" title="22、在image上绘制文字并生成新的image"></a>22、在image上绘制文字并生成新的image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIFont *font = [UIFont boldSystemFontOfSize:12];    UIGraphicsBeginImageContext(image.size);    [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];    CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);    [[UIColor whiteColor] set];    [text drawInRect:CGRectIntegral(rect) withFont:font];     UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();</div></pre></td></tr></table></figure>
<h3 id="23、判断一个view是否为另一个view的子视图"><a href="#23、判断一个view是否为另一个view的子视图" class="headerlink" title="23、判断一个view是否为另一个view的子视图"></a>23、判断一个view是否为另一个view的子视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 如果myView是self.view本身，也会返回yesBOOL isSubView = [myView isDescendantOfView:self.view];</div></pre></td></tr></table></figure>
<h3 id="24、判断一个字符串是否包含另一个字符串"><a href="#24、判断一个字符串是否包含另一个字符串" class="headerlink" title="24、判断一个字符串是否包含另一个字符串"></a>24、判断一个字符串是否包含另一个字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二if ([str containsString:otherStr]) NSLog(@&quot;包含&quot;);// 方法二NSRange range = [str rangeOfString:otherStr];if (range.location != NSNotFound) NSLog(@&quot;包含&quot;);</div></pre></td></tr></table></figure>
<h3 id="25、UICollectionView自动滚动到某行"><a href="#25、UICollectionView自动滚动到某行" class="headerlink" title="25、UICollectionView自动滚动到某行"></a>25、UICollectionView自动滚动到某行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 重写viewDidLayoutSubviews方法-(void)viewDidLayoutSubviews &#123;   [super viewDidLayoutSubviews];   [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];&#125;</div></pre></td></tr></table></figure>
<h3 id="26、修改系统UIAlertController"><a href="#26、修改系统UIAlertController" class="headerlink" title="26、修改系统UIAlertController"></a>26、修改系统UIAlertController</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 但是据说这种方法会被App Store拒绝(慎用！)UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:@&quot;&quot; preferredStyle:UIAlertControllerStyleActionSheet];    NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@&quot;我是一个大文本&quot;];    [hogan addAttribute:NSFontAttributeName                  value:[UIFont systemFontOfSize:30]                  range:NSMakeRange(4, 1)];    [hogan addAttribute:NSForegroundColorAttributeName                  value:[UIColor redColor]                  range:NSMakeRange(4, 1)];    [alertVC setValue:hogan forKey:@&quot;attributedTitle&quot;];    UIAlertAction *button = [UIAlertAction actionWithTitle:@&quot;Label text&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action)&#123; &#125;];    UIImage *accessoryImage = [UIImage imageNamed:@&quot;1&quot;];    [button setValue:accessoryImage forKey:@&quot;image&quot;];    [alertVC addAction:button];    [self presentViewController:alertVC animated:YES completion:nil];</div></pre></td></tr></table></figure>
<h3 id="27、判断某一行的cell是否已经显示"><a href="#27、判断某一行的cell是否已经显示" class="headerlink" title="27、判断某一行的cell是否已经显示"></a>27、判断某一行的cell是否已经显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGRect cellRect = [tableView rectForRowAtIndexPath:indexPath];BOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect);</div></pre></td></tr></table></figure>
<h3 id="28、让导航控制器pop回指定的控制器"><a href="#28、让导航控制器pop回指定的控制器" class="headerlink" title="28、让导航控制器pop回指定的控制器"></a>28、让导航控制器pop回指定的控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]];for (UIViewController *aViewController in allViewControllers) &#123;    if ([aViewController isKindOfClass:[RequiredViewController class]]) &#123;        [self.navigationController popToViewController:aViewController animated:NO];    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="29、动画修改label上的文字"><a href="#29、动画修改label上的文字" class="headerlink" title="29、动画修改label上的文字"></a>29、动画修改label上的文字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一CATransition *animation = [CATransition animation];    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];    animation.type = kCATransitionFade;    animation.duration = 0.75;    [self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;];    self.label.text = @&quot;New&quot;;// 方法二[UIView transitionWithView:self.label                      duration:0.25f                       options:UIViewAnimationOptionTransitionCrossDissolve                    animations:^&#123;                        self.label.text = @&quot;Well done!&quot;;                    &#125; completion:nil];// 方法三[UIView animateWithDuration:1.0                     animations:^&#123;                         self.label.alpha = 0.0f;                         self.label.text = @&quot;newText&quot;;                         self.label.alpha = 1.0f;                     &#125;];</div></pre></td></tr></table></figure>
<h3 id="30、判断字典中是否包含某个key值"><a href="#30、判断字典中是否包含某个key值" class="headerlink" title="30、判断字典中是否包含某个key值"></a>30、判断字典中是否包含某个key值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([dic objectForKey:@&quot;yourKey&quot;]) &#123;    NSLog(@&quot;有这个值&quot;);&#125; else &#123;    NSLog(@&quot;没有这个值&quot;);&#125;</div></pre></td></tr></table></figure>
<h3 id="31、获取屏幕方向"><a href="#31、获取屏幕方向" class="headerlink" title="31、获取屏幕方向"></a>31、获取屏幕方向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;if(orientation == 0) //Default orientation     //默认else if(orientation == UIInterfaceOrientationPortrait)    //竖屏else if(orientation == UIInterfaceOrientationLandscapeLeft)    // 左横屏else if(orientation == UIInterfaceOrientationLandscapeRight)    //右横屏</div></pre></td></tr></table></figure>
<h3 id="32、设置UIImage的透明度"><a href="#32、设置UIImage的透明度" class="headerlink" title="32、设置UIImage的透明度"></a>32、设置UIImage的透明度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、添加UIImage分类- (UIImage *)imageByApplyingAlpha:(CGFloat) alpha &#123;    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);    CGContextRef ctx = UIGraphicsGetCurrentContext();    CGRect area = CGRectMake(0, 0, self.size.width, self.size.height);    CGContextScaleCTM(ctx, 1, -1);    CGContextTranslateCTM(ctx, 0, -area.size.height);    CGContextSetBlendMode(ctx, kCGBlendModeMultiply);    CGContextSetAlpha(ctx, alpha);    CGContextDrawImage(ctx, area, self.CGImage);    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    return newImage;&#125;// 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@&quot;yourImage&quot;]];imageView.alpha = 0.5;</div></pre></td></tr></table></figure>
<h3 id="33、Attempt-to-mutate-immutable-object-with-insertString-atIndex"><a href="#33、Attempt-to-mutate-immutable-object-with-insertString-atIndex" class="headerlink" title="33、Attempt to mutate immutable object with insertString:atIndex:"></a>33、Attempt to mutate immutable object with insertString:atIndex:</h3><blockquote>
<p>这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用</p>
</blockquote>
<h3 id="34、UIWebView添加单击手势不响应"><a href="#34、UIWebView添加单击手势不响应" class="headerlink" title="34、UIWebView添加单击手势不响应"></a>34、UIWebView添加单击手势不响应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];        tap.delegate = self;        [_webView addGestureRecognizer:tap];// 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123;    return YES;&#125;</div></pre></td></tr></table></figure>
<h3 id="35、获取手机RAM容量"><a href="#35、获取手机RAM容量" class="headerlink" title="35、获取手机RAM容量"></a>35、获取手机RAM容量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 需要导入#import &lt;mach/mach.h&gt;mach_port_t host_port;    mach_msg_type_number_t host_size;    vm_size_t pagesize;    host_port = mach_host_self();    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);    host_page_size(host_port, &amp;pagesize);    vm_statistics_data_t vm_stat;    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size) != KERN_SUCCESS) &#123;        NSLog(@&quot;Failed to fetch vm statistics&quot;);    &#125;    /* Stats in bytes */    natural_t mem_used = (vm_stat.active_count +                          vm_stat.inactive_count +                          vm_stat.wire_count) * pagesize;    natural_t mem_free = vm_stat.free_count * pagesize;    natural_t mem_total = mem_used + mem_free;    NSLog(@&quot;已用: %u 可用: %u 总共: %u&quot;, mem_used, mem_free, mem_total);</div></pre></td></tr></table></figure>
<h3 id="36、地图上两个点之间的实际距离"><a href="#36、地图上两个点之间的实际距离" class="headerlink" title="36、地图上两个点之间的实际距离"></a>36、地图上两个点之间的实际距离</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 需要导入#import &lt;CoreLocation/CoreLocation.h&gt;CLLocation *locA = [[CLLocation alloc] initWithLatitude:34 longitude:113];    CLLocation *locB = [[CLLocation alloc] initWithLatitude:31.05 longitude:121.76];// CLLocationDistance求出的单位为米    CLLocationDistance distance = [locA distanceFromLocation:locB];</div></pre></td></tr></table></figure>
<h3 id="37、在应用中打开设置的某个界面"><a href="#37、在应用中打开设置的某个界面" class="headerlink" title="37、在应用中打开设置的某个界面"></a>37、在应用中打开设置的某个界面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 打开设置-&gt;通用[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root=General&quot;]];// 以下是设置其他界面prefs:root=General&amp;path=Aboutprefs:root=General&amp;path=ACCESSIBILITYprefs:root=AIRPLANE_MODEprefs:root=General&amp;path=AUTOLOCKprefs:root=General&amp;path=USAGE/CELLULAR_USAGEprefs:root=Brightnessprefs:root=Bluetoothprefs:root=General&amp;path=DATE_AND_TIMEprefs:root=FACETIMEprefs:root=Generalprefs:root=General&amp;path=Keyboardprefs:root=CASTLEprefs:root=CASTLE&amp;path=STORAGE_AND_BACKUPprefs:root=General&amp;path=INTERNATIONALprefs:root=LOCATION_SERVICESprefs:root=ACCOUNT_SETTINGSprefs:root=MUSICprefs:root=MUSIC&amp;path=EQprefs:root=MUSIC&amp;path=VolumeLimitprefs:root=General&amp;path=Networkprefs:root=NIKE_PLUS_IPODprefs:root=NOTESprefs:root=NOTIFICATIONS_IDprefs:root=Phoneprefs:root=Photosprefs:root=General&amp;path=ManagedConfigurationListprefs:root=General&amp;path=Resetprefs:root=Sounds&amp;path=Ringtoneprefs:root=Safariprefs:root=General&amp;path=Assistantprefs:root=Soundsprefs:root=General&amp;path=SOFTWARE_UPDATE_LINKprefs:root=STOREprefs:root=TWITTERprefs:root=FACEBOOKprefs:root=General&amp;path=USAGE prefs:root=VIDEOprefs:root=General&amp;path=Network/VPNprefs:root=Wallpaperprefs:root=WIFIprefs:root=INTERNET_TETHERINGprefs:root=Phone&amp;path=Blockedprefs:root=DO_NOT_DISTURB</div></pre></td></tr></table></figure>
<h3 id="38、在UITextView中显示html文本"><a href="#38、在UITextView中显示html文本" class="headerlink" title="38、在UITextView中显示html文本"></a>38、在UITextView中显示html文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 30, 100, 199)];    textView.backgroundColor = [UIColor redColor];    [self.view addSubview:textView];    NSString *htmlString = @&quot;&lt;h1&gt;Header&lt;/h1&gt;&lt;h2&gt;Subheader&lt;/h2&gt;&lt;p&gt;Some &lt;em&gt;text&lt;/em&gt;&lt;/p&gt;![](http://blogs.babble.com/famecrawler/files/2010/11/mickey_mouse-1097.jpg)&quot;;    NSAttributedString *attributedString = [[NSAttributedString alloc] initWithData: [htmlString dataUsingEncoding:NSUnicodeStringEncoding] options: @&#123; NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType &#125; documentAttributes: nil error: nil];    textView.attributedText = attributedString;</div></pre></td></tr></table></figure>
<h3 id="39、监听scrollView是否滚动到了顶部／底部"><a href="#39、监听scrollView是否滚动到了顶部／底部" class="headerlink" title="39、监听scrollView是否滚动到了顶部／底部"></a>39、监听scrollView是否滚动到了顶部／底部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)scrollViewDidScroll: (UIScrollView*)scrollView&#123;    float scrollViewHeight = scrollView.frame.size.height;    float scrollContentSizeHeight = scrollView.contentSize.height;    float scrollOffset = scrollView.contentOffset.y;    if (scrollOffset == 0)    &#123;        // 滚动到了顶部    &#125;    else if (scrollOffset + scrollViewHeight == scrollContentSizeHeight)    &#123;        // 滚动到了底部    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="40、UISlider增量／减量为固定值-假如为5"><a href="#40、UISlider增量／减量为固定值-假如为5" class="headerlink" title="40、UISlider增量／减量为固定值(假如为5)"></a>40、UISlider增量／减量为固定值(假如为5)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setupSlider&#123;    UISlider *slider = [[UISlider alloc] init];    [self.view addSubview:slider];    [slider addTarget:self action:@selector(sliderAction:) forControlEvents:UIControlEventValueChanged];    slider.maximumValue = 100;    slider.minimumValue = 0;    slider.frame = CGRectMake(200, 20, 100, 30);&#125;- (void)sliderAction:(UISlider *)slider&#123;    [slider setValue:((int)((slider.value + 2.5) / 5) * 5) animated:NO];&#125;</div></pre></td></tr></table></figure>
<h3 id="41、选中textField或者textView所有文本-我这里以textView为例"><a href="#41、选中textField或者textView所有文本-我这里以textView为例" class="headerlink" title="41、选中textField或者textView所有文本(我这里以textView为例)"></a>41、选中textField或者textView所有文本(我这里以textView为例)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.textView setSelectedTextRange:[self.textView textRangeFromPosition:self.textView.beginningOfDocument toPosition:self.textView.endOfDocument]]</div></pre></td></tr></table></figure>
<h3 id="42、从导航控制器中删除某个控制器"><a href="#42、从导航控制器中删除某个控制器" class="headerlink" title="42、从导航控制器中删除某个控制器"></a>42、从导航控制器中删除某个控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、知道这个控制器所处的导航控制器下标NSMutableArray *navigationArray = [[NSMutableArray alloc] initWithArray: self.navigationController.viewControllers];[navigationArray removeObjectAtIndex: 2]; self.navigationController.viewControllers = navigationArray;// 方法二、知道具体是哪个控制器NSArray* tempVCA = [self.navigationController viewControllers];for(UIViewController *tempVC in tempVCA)&#123;    if([tempVC isKindOfClass:[urViewControllerClass class]])    &#123;        [tempVC removeFromParentViewController];    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="43、隐藏UITextView-UITextField光标"><a href="#43、隐藏UITextView-UITextField光标" class="headerlink" title="43、隐藏UITextView/UITextField光标"></a>43、隐藏UITextView/UITextField光标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textField.tintColor = [UIColor clearColor];</div></pre></td></tr></table></figure>
<h3 id="44、当UITextView-UITextField中没有文字时，禁用回车键"><a href="#44、当UITextView-UITextField中没有文字时，禁用回车键" class="headerlink" title="44、当UITextView/UITextField中没有文字时，禁用回车键"></a>44、当UITextView/UITextField中没有文字时，禁用回车键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textField.enablesReturnKeyAutomatically = YES;</div></pre></td></tr></table></figure>
<h3 id="45、字符串encode编码-编码url字符串不成功的问题"><a href="#45、字符串encode编码-编码url字符串不成功的问题" class="headerlink" title="45、字符串encode编码(编码url字符串不成功的问题)"></a>45、字符串encode编码(编码url字符串不成功的问题)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 我们一般用这个方法处理stringByAddingPercentEscapesUsingEncoding但是这个方法好想不会处理／和&amp;这种特殊符号，这种情况就需要用下边这个方法处理@implementation NSString (NSString_Extended)- (NSString *)urlencode &#123;    NSMutableString *output = [NSMutableString string];    const unsigned char *source = (const unsigned char *)[self UTF8String];    int sourceLen = strlen((const char *)source);    for (int i = 0; i &lt; sourceLen; ++i) &#123;        const unsigned char thisChar = source[i];        if (thisChar == &apos; &apos;)&#123;            [output appendString:@&quot;+&quot;];        &#125; else if (thisChar == &apos;.&apos; || thisChar == &apos;-&apos; || thisChar == &apos;_&apos; || thisChar == &apos;~&apos; ||                    (thisChar &gt;= &apos;a&apos; &amp;&amp; thisChar &lt;= &apos;z&apos;) ||                   (thisChar &gt;= &apos;A&apos; &amp;&amp; thisChar &lt;= &apos;Z&apos;) ||                   (thisChar &gt;= &apos;0&apos; &amp;&amp; thisChar &lt;= &apos;9&apos;)) &#123;            [output appendFormat:@&quot;%c&quot;, thisChar];        &#125; else &#123;            [output appendFormat:@&quot;%%%02X&quot;, thisChar];        &#125;    &#125;    return output;&#125;</div></pre></td></tr></table></figure>
<h3 id="46、计算UILabel上某段文字的frame"><a href="#46、计算UILabel上某段文字的frame" class="headerlink" title="46、计算UILabel上某段文字的frame"></a>46、计算UILabel上某段文字的frame</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@implementation UILabel (TextRect)- (CGRect)boundingRectForCharacterRange:(NSRange)range&#123;    NSTextStorage *textStorage = [[NSTextStorage alloc] initWithAttributedString:[self attributedText]];    NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init];    [textStorage addLayoutManager:layoutManager];    NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:[self bounds].size];    textContainer.lineFragmentPadding = 0;    [layoutManager addTextContainer:textContainer];    NSRange glyphRange;    [layoutManager characterRangeForGlyphRange:range actualGlyphRange:&amp;glyphRange];    return [layoutManager boundingRectForGlyphRange:glyphRange inTextContainer:textContainer];&#125;</div></pre></td></tr></table></figure>
<h3 id="47、获取随机UUID"><a href="#47、获取随机UUID" class="headerlink" title="47、获取随机UUID"></a>47、获取随机UUID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *result;    if([[[UIDevice currentDevice] systemVersion] floatValue] &gt; 6.0)    &#123;       result = [[NSUUID UUID] UUIDString];    &#125;    else    &#123;        CFUUIDRef uuidRef = CFUUIDCreate(NULL);        CFStringRef uuid = CFUUIDCreateString(NULL, uuidRef);        CFRelease(uuidRef);        result = (__bridge_transfer NSString *)uuid;    &#125;</div></pre></td></tr></table></figure>
<h3 id="48、仿苹果抖动动画"><a href="#48、仿苹果抖动动画" class="headerlink" title="48、仿苹果抖动动画"></a>48、仿苹果抖动动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define RADIANS(degrees) (((degrees) * M_PI) / 180.0)- (void)startAnimate &#123;    view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(-5));    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionRepeat | UIViewAnimationOptionAutoreverse) animations:^ &#123;                         view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(5));                     &#125; completion:nil];&#125;- (void)stopAnimate &#123;    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveLinear) animations:^ &#123;                         view.transform = CGAffineTransformIdentity;                     &#125; completion:nil];&#125;</div></pre></td></tr></table></figure>
<h3 id="49、修改UISearBar内部背景颜色"><a href="#49、修改UISearBar内部背景颜色" class="headerlink" title="49、修改UISearBar内部背景颜色"></a>49、修改UISearBar内部背景颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;];textField.backgroundColor = [UIColor redColor];</div></pre></td></tr></table></figure>
<h3 id="50、UITextView滚动到顶部"><a href="#50、UITextView滚动到顶部" class="headerlink" title="50、UITextView滚动到顶部"></a>50、UITextView滚动到顶部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一    [self.textView scrollRangeToVisible:NSMakeRange(0, 0)];    // 方法二    [self.textView setContentOffset:CGPointZero animated:YES];</div></pre></td></tr></table></figure>
<h3 id="51、通知监听APP生命周期"><a href="#51、通知监听APP生命周期" class="headerlink" title="51、通知监听APP生命周期"></a>51、通知监听APP生命周期</h3><blockquote>
<p>UIApplicationDidEnterBackgroundNotification 应用程序进入后台<br>UIApplicationWillEnterForegroundNotification 应用程序将要进入前台<br>UIApplicationDidFinishLaunchingNotification 应用程序完成启动<br>UIApplicationDidFinishLaunchingNotification 应用程序由挂起变的活跃<br>UIApplicationWillResignActiveNotification 应用程序挂起(有电话进来或者锁屏)<br>UIApplicationDidReceiveMemoryWarningNotification 应用程序收到内存警告<br>UIApplicationDidReceiveMemoryWarningNotification 应用程序终止(后台杀死、手机关机等)<br>UIApplicationSignificantTimeChangeNotification 当有重大时间改变(凌晨0点，设备时间被修改，时区改变等)<br>UIApplicationWillChangeStatusBarOrientationNotification 设备方向将要改变<br>UIApplicationDidChangeStatusBarOrientationNotification 设备方向改变<br>UIApplicationWillChangeStatusBarFrameNotification 设备状态栏frame将要改变<br>UIApplicationDidChangeStatusBarFrameNotification 设备状态栏frame改变<br>UIApplicationBackgroundRefreshStatusDidChangeNotification 应用程序在后台下载内容的状态发生变化<br>UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件被锁定,无法访问<br>UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件可用了</p>
</blockquote>
<h3 id="52、触摸事件类型"><a href="#52、触摸事件类型" class="headerlink" title="52、触摸事件类型"></a>52、触摸事件类型</h3><blockquote>
<p>UIControlEventTouchCancel 取消控件当前触发的事件<br>UIControlEventTouchDown 点按下去的事件<br>UIControlEventTouchDownRepeat 重复的触动事件<br>UIControlEventTouchDragEnter 手指被拖动到控件的边界的事件<br>UIControlEventTouchDragExit 一个手指从控件内拖到外界的事件<br>UIControlEventTouchDragInside 手指在控件的边界内拖动的事件<br>UIControlEventTouchDragOutside 手指在控件边界之外被拖动的事件<br>UIControlEventTouchUpInside 手指处于控制范围内的触摸事件<br>UIControlEventTouchUpOutside 手指超出控制范围的控制中的触摸事件</p>
</blockquote>
<h3 id="53、UITextField文字周围增加边距"><a href="#53、UITextField文字周围增加边距" class="headerlink" title="53、UITextField文字周围增加边距"></a>53、UITextField文字周围增加边距</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 子类化UITextField，增加insert属性@interface WZBTextField : UITextField@property (nonatomic, assign) UIEdgeInsets insets;@end// 在.m文件重写下列方法- (CGRect)textRectForBounds:(CGRect)bounds &#123;    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) &#123;        return [self adjustRectWithWidthRightView:paddedRect];    &#125;    return paddedRect;&#125;- (CGRect)placeholderRectForBounds:(CGRect)bounds &#123;    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) &#123;        return [self adjustRectWithWidthRightView:paddedRect];    &#125;    return paddedRect;&#125;- (CGRect)editingRectForBounds:(CGRect)bounds &#123;    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeWhileEditing) &#123;        return [self adjustRectWithWidthRightView:paddedRect];    &#125;    return paddedRect;&#125;- (CGRect)adjustRectWithWidthRightView:(CGRect)bounds &#123;    CGRect paddedRect = bounds;    paddedRect.size.width -= CGRectGetWidth(self.rightView.frame);    return paddedRect;&#125;</div></pre></td></tr></table></figure>
<h3 id="54、监听UISlider拖动状态"><a href="#54、监听UISlider拖动状态" class="headerlink" title="54、监听UISlider拖动状态"></a>54、监听UISlider拖动状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 添加事件[slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged];// 实现方法- (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event &#123;    UITouch *touchEvent = [[event allTouches] anyObject];    switch (touchEvent.phase) &#123;        case UITouchPhaseBegan:            NSLog(@&quot;开始拖动&quot;);            break;        case UITouchPhaseMoved:            NSLog(@&quot;正在拖动&quot;);            break;        case UITouchPhaseEnded:            NSLog(@&quot;结束拖动&quot;);            break;        default:            break;    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="55、设置UITextField光标位置"><a href="#55、设置UITextField光标位置" class="headerlink" title="55、设置UITextField光标位置"></a>55、设置UITextField光标位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// textField需要设置的textField，index要设置的光标位置- (void)cursorLocation:(UITextField *)textField index:(NSInteger)index&#123;    NSRange range = NSMakeRange(index, 0);    UITextPosition *start = [textField positionFromPosition:[textField beginningOfDocument] offset:range.location];    UITextPosition *end = [textField positionFromPosition:start offset:range.length];    [textField setSelectedTextRange:[textField textRangeFromPosition:start toPosition:end]];&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS小知识代码段 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS小知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[个人总结和收集的iOS进阶路线(大佬请绕路)]]></title>
      <url>/2016/04/12/blog_guide/</url>
      <content type="html"><![CDATA[<p>个人总结和收集到的iOS有关知识结构……<br><a id="more"></a><br>iOS技术栈<br><img src="http://upload-images.jianshu.io/upload_images/1853274-f938e42bd0b1c7f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>iOS基本知识分类<br><img src="http://upload-images.jianshu.io/upload_images/1853274-262c949b552a2fdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>《Effective Objective-C》读后总结<br><img src="http://upload-images.jianshu.io/upload_images/1853274-afc25b730be09c20.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>不知道看完你有什么感受，如果觉得自己在某方面不足的话，那就要抓紧时间迎头赶上哦，毕竟，竞争激烈嘛(大佬请自便,哈哈)……</p>
]]></content>
      
        <categories>
            
            <category> iOS面试知识点集锦 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHubPages + Hexo 搭建个人博客]]></title>
      <url>/2016/03/22/blog_aboutHexo/</url>
      <content type="html"><![CDATA[<p>首先:GitHubPages是什么？<br>GitHubPages可以认为是个人用户编写的并且上传到github的网页文件<br>其次,为什么采用GitHubPages搭建？<br>300M的免费空间,众多大牛的聚集地,趋势所向,赶紧行动起来吧,跟着我一起搭建属于自己的博客!<br><a id="more"></a></p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>地址:<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="external">http://www.runoob.com/nodejs/nodejs-install-setup.html</a></p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>下载地址:<a href="http://git-scm.com/download/" target="_blank" rel="external">http://git-scm.com/download/</a></p>
<p>以下步骤也可以按照Hexo的官方文档来进行<br>地址：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/index.html</a></p>
<p>你的系统需要支持Node和Git哦……</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>选定需要安装的文件夹 比如我们选择D:\Hexo目录<br>打开终端命令行如下:<br>$ cd D:/Hexo<br>$ npm install hexo-cli -g<br>$ hexo init blog #blog为你指定的新建文件的文件夹<br>$ cd blog<br>$ npm install<br>$ hexo g # 或者hexo generate<br>$ hexo s # 或者hexo server，可以在<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 查看</p>
<p>Hexo常用命令<br>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 简写 hexo g<br>hexo server (hexo s) 启动本地web服务，用于博客的预览 简写 hexo s<br>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 简写 hexo d<br>hexo new “postName” #新建文章 简写 hexo n<br>hexo new page “pageName” #新建页面</p>
<p>组合命令<br>hexo d -g #生成部署<br>hexo s -g #生成预览</p>
<p>此时我们cd到Hexo文件夹目录下 使用以下命令<br>hexo clean<br>hexo g<br>hexo s</p>
<p>然后看到提示启动本地服务成功即可打开浏览器 输入网址 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 进行访问<br>Hexo默认的主题是landscape画风如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1853274-eb070a3f8aafa918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<h3 id="开始写文章"><a href="#开始写文章" class="headerlink" title="开始写文章"></a>开始写文章</h3><p>新建一个文件 我们在终端里 进入到\blog\source目录 执行hexo new [layout] “postName” #新建文章 即可 这里需要注意的是其中layout是可选参数，默认值为post 我们可以到本地的scaffolds下查看<br>默认为<br>title: GitHubPages + Hexo 搭建个人博客 # 文章标题名称<br>date: 1458576000000 #文章生成时间，可随意更改</p>
<h2 id="tags-文章标签"><a href="#tags-文章标签" class="headerlink" title="tags: #文章标签"></a>tags: #文章标签</h2><p>注意：所有文件后都必须要有空格哦，不然执行hexo g 就会报错</p>
<p>可能你会认为接下来的书写效率较低　那么笔者推荐你使用MarkDown书写工具 比如<a href="https://github.com/atom/atom" target="_blank" rel="external">Atom</a> 或者<a href="http://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a> 笔者下面采用Atom示例</p>
<p>打开Atom 选择Add Project Folder 将本地的Hexo目录打开即可<br><img src="http://upload-images.jianshu.io/upload_images/1853274-50ffe92ab7aae792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"><br>看起来是不是方面很多 关于书写MarkDown的语法可以参考<a href="http://wowubuntu.com/markdown/#link" target="_blank" rel="external">《Markdown 语法说明》</a></p>
<h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>Hexo 提供了较多的主题供我们选择 <a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo主题地址</a> 例如 Next Jacman yelee都是很不错的主题<br>比如yelee主题<br><img src="http://upload-images.jianshu.io/upload_images/1853274-c4223cdc42ce1719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>步骤如下：<br>（1）进入到本地Hexo的themes目录 使用git clone <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">https://github.com/MOxFIVE/hexo-theme-yelee</a> 即可<br> (2)在（1）完成的基础上 我们进入到下面的文件里进行如下操作<br> <img src="http://upload-images.jianshu.io/upload_images/1853274-7d0fc004d1cb4d43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt Text"><br> （3）进行其他的配置可以<a href="http://moxfive.xyz/yelee/new-features.html" target="_blank" rel="external">点此进入</a> ,若是想更新主题 直接在themes目录下 使用git pull + 对应的主题在GitHub上的地址即可</p>
<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>建议采用 <a href="https://www.qiniu.com/" target="_blank" rel="external">七牛云</a> 访问速度快，支持日志、防盗链和水印,免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求,个人用户还不是妥妥的</p>
<h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><p>到这里目前来看我们搭建的博客地址都是以.github.io结尾 如果你感觉这个二级域名不爽 你也可以去申请一个自己的域名 <a href="http://upload-images.jianshu.io/upload_images/1853274-b989327d0f3690cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">阿里云</a></p>
<p>接着，在repo根目录下建立一个CNAME文件，里面写上域名即可</p>
<p>到此 GitHubPages + Hexo 搭建个人博客就介绍完毕了</p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHubPages </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
