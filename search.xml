<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[深入理解runtime]]></title>
      <url>/2016/10/18/blog_runtime/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> runtime </category>
            
        </categories>
        
        
        <tags>
            
            <tag> runtime </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解RunLoop]]></title>
      <url>/2016/09/01/blog_runLoop/</url>
      <content type="html"></content>
      
        <categories>
            
            <category> NSRunLoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> RunLoop </tag>
            
            <tag> NSRunLoop </tag>
            
            <tag> CFRunLoop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Block精析]]></title>
      <url>/2016/08/02/blog_block/</url>
      <content type="html"><![CDATA[<p>工作中经常会使用到Block 但是对于Block你真正的了解吗？下面是我对 Block 的整理，从零开始，由浅入深，并且带了几个 Block 实际开发的应用场景和面试经常会被问到的问题。<br><a id="more"></a></p>
<h3 id="Block的概念"><a href="#Block的概念" class="headerlink" title="Block的概念"></a>Block的概念</h3><p>苹果的官方文档给出这样的一句话<br>Blocks are a language-level feature added to C, Objective-C and C++, which allow you to create distinct segments of code that can be passed around to methods or functions as if they were values.<br>翻译过来就是：Block是Apple Inc.为C、C++以及Objective-C添加的特性，可以创建不同代码段传递给方法或函数。<br>简单点来说Block 是一种特殊的数据类型(匿名的函数和代码块)，可以正常定义变量、作为参数、作为返回值；还可以保存一段代码，在需要的时候调用.当然你也可以理解成闭包(闭包:闭包就是能够读取其它函数内部变量的函数)。</p>
<h3 id="Block的声明-类型-定义-调用"><a href="#Block的声明-类型-定义-调用" class="headerlink" title="Block的声明,类型,定义,调用"></a>Block的声明,类型,定义,调用</h3><p>#声明#<br>    <code>声明格式:返回值(^block变量名)(参数)</code></p>
]]></content>
      
        <categories>
            
            <category> Block私房笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Block </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS小知识点回顾]]></title>
      <url>/2016/07/18/blog_iOSStudy/</url>
      <content type="html"><![CDATA[<p>根据面试情况总结的iOS基础面试题,如有错误,欢迎斧正……<br><a id="more"></a><br><strong>设计模式是什么？ 你知道哪些设计模式，并简要叙述？</strong></p>
<p>设计模式是一种编码经验，就是用比较成熟的逻辑去处理某一种类型的事情。</p>
<p>(1). MVC模式：Model View Control，把模型 视图 控制器 层进行解耦合编写。</p>
<p>(2). MVVM模式：Model View ViewModel 把模型 视图 业务逻辑 层进行解耦和编写。</p>
<p>(3). 单例模式：通过static关键词，声明全局变量。在整个进程运行期间只会被赋值一次。</p>
<p>(4). 观察者模式：KVO是典型的通知模式，观察某个属性的状态，状态发生变化时通知观察者。</p>
<p>(5). 委托模式：代理+协议的组合。实现1对1的反向传值操作。</p>
<p>(6). 工厂模式：通过一个类方法，批量的根据已有模板生产对象。</p>
<p><strong>MVC 和 MVVM 的区别</strong></p>
<p>(1). MVVM是对胖模型进行的拆分，其本质是给控制器减负，将一些弱业务逻辑放到VM中去处理。</p>
<p>(2). MVC是一切设计的基础，所有新的设计模式都是基于MVC进行的改进。</p>
<p><strong>#import跟 #include 有什么区别，@class呢，#import&lt;&gt; 跟 #import””有什么区别？</strong></p>
<p>答：</p>
<p>(1). #import是Objective-C导入头文件的关键字，#include是C/C++导入头文件的关键字，使用#import头文件会自动只导入一次，不会重复导入。</p>
<p>(2). @class告诉编译器某个类的声明，当执行时，才去查看类的实现文件，可以解决头文件的相互包含。</p>
<p>(3). #import&lt;&gt;用来包含系统的头文件，#import””用来包含用户头文件。</p>
<p><strong>frame 和 bounds 有什么不同？</strong></p>
<p>frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父view的坐标系统)</p>
<p>bounds指的是：该view在本身坐标系统中的位置和大小。(参照点是本身坐标系统)</p>
<p><strong>Objective-C的类可以多重继承么？可以实现多个接口么？Category是什么？重写一个类的方式用继承好还是分类好？为什么？</strong></p>
<p>答：Objective-C的类不可以多重继承；可以实现多个接口（协议）；Category是类别；一般情况用分类好，用Category去重写类的方法，仅对本Category有效，不会影响到其他类与原有类的关系。</p>
<p><strong>@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的</strong></p>
<p>@property 的本质是什么？</p>
<p>@property = ivar + getter + setter;</p>
<p>“属性” (property)有两大概念：ivar（实例变量）、getter+setter（存取方法）</p>
<p>“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。</p>
<p><strong>@property中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</strong></p>
<p>属性可以拥有的特质分为四类:</p>
<p>1.原子性— nonatomic 特质</p>
<p>2.读/写权限—readwrite(读写)、readonly (只读)</p>
<p>3.内存管理语义—assign、strong、 weak、unsafe_unretained、copy</p>
<p>4.方法名—getter=<name> 、setter=<name></name></name></p>
<p>5.不常用的：nonnull,null_resettable,nullable</p>
<p><strong>属性关键字 readwrite，readonly，assign，retain，copy，nonatomic 各是什么作用，在那种情况下用？</strong></p>
<p>答：</p>
<p>(1). readwrite 是可读可写特性。需要生成getter方法和setter方法。</p>
<p>(2). readonly 是只读特性。只会生成getter方法，不会生成setter方法，不希望属性在类外改变。</p>
<p>(3). assign 是赋值特性。setter方法将传入参数赋值给实例变量;仅设置变量时,assign用于基本数据类型。</p>
<p>(4). retain(MRC)/strong(ARC) 表示持有特性。setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。</p>
<p>(5). copy 表示拷贝特性。setter方法将传入对象复制一份，需要完全一份新的变量时。</p>
<p>(6). nonatomic 非原子操作。决定编译器生成的setter和getter方法是否是原子操作，atomic表示多线程安全，一般使用nonatomic，效率高。</p>
<p><strong>什么情况使用 weak 关键字，相比 assign 有什么不同？</strong></p>
<p>1.在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。</p>
<p>2.自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。</p>
<p>IBOutlet连出来的视图属性为什么可以被设置成weak?</p>
<p>因为父控件的subViews数组已经对它有一个强引用。</p>
<p>不同点：</p>
<p>assign 可以用非 OC 对象，而 weak 必须用于 OC 对象。</p>
<p>weak 表明该属性定义了一种“非拥有关系”。在属性所指的对象销毁时，属性值会自动清空(nil)。</p>
<p><strong>怎么用 copy 关键字？</strong></p>
<p> 用途：</p>
<ol>
<li><p>NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</p>
</li>
<li><p>block 也经常使用 copy 关键字。</p>
<p>说明：</p>
<p>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但写上 copy 也无伤大雅，还能时刻提醒我们：编译器自动对 block 进行了 copy 操作。如果不写 copy ，该类的调用者有可能会忘记或者根本不知道“编译器会自动对 block 进行了 copy 操作”，他们有可能会在调用之前自行拷贝属性值。这种操作多余而低效。</p>
</li>
</ol>
<p><strong>用@property声明的 NSString / NSArray / NSDictionary 经常使用 copy 关键字，为什么？如果改用strong关键字，可能造成什么问题？</strong></p>
<p>答：用 @property 声明 NSString、NSArray、NSDictionary 经常使用 copy 关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，他们之间可能进行赋值操作（就是把可变的赋值给不可变的），为确保对象中的字符串值不会无意间变动，应该在设置新属性值时拷贝一份。</p>
<ol>
<li><p>因为父类指针可以指向子类对象,使用 copy 的目的是为了让本对象的属性不受外界影响,使用 copy 无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本。</p>
</li>
<li><p>如果我们使用是 strong ,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性。</p>
</li>
</ol>
<p>//总结：使用copy的目的是，防止把可变类型的对象赋值给不可变类型的对象时，可变类型对象的值发送变化会无意间篡改不可变类型对象原来的值。</p>
<p><strong>浅拷贝和深拷贝的区别？</strong></p>
<p>答：</p>
<p>浅拷贝：只复制指向对象的指针，而不复制引用对象本身。</p>
<p>深拷贝：复制引用对象本身。内存中存在了两份独立对象本身，当修改A时，A_copy不变。</p>
<p><strong>系统对象的 copy 与 mutableCopy 方法</strong></p>
<p>不管是集合类对象（NSArray、NSDictionary、NSSet … 之类的对象），还是非集合类对象（NSString, NSNumber … 之类的对象），接收到copy和mutableCopy消息时，都遵循以下准则：</p>
<ol>
<li><p>copy 返回的是不可变对象（immutableObject）；如果用copy返回值调用mutable对象的方法就会crash。</p>
</li>
<li><p>mutableCopy 返回的是可变对象（mutableObject）。</p>
</li>
</ol>
<p>一、非集合类对象的copy与mutableCopy</p>
<p>  在非集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</p>
<p>  对可变对象进行copy和mutableCopy都是内容复制。</p>
<p>二、集合类对象的copy与mutableCopy (同上)</p>
<p>  在集合类对象中，对不可变对象进行copy操作，是指针复制，mutableCopy操作是内容复制；</p>
<p>  对可变对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对集合内的对象元素仍然是指针复制。(即单层内容复制)</p>
<p>【总结一句话】：</p>
<p>只有对不可变对象进行copy操作是指针复制（浅复制），其它情况都是内容复制（深复制）！</p>
<p><strong>这个写法会出什么问题：@property (nonatomic, copy) NSMutableArray *arr;</strong></p>
<p>问题：添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃。</p>
<p>//如：-[__NSArrayI removeObjectAtIndex:]: unrecognized selector sent to instance 0x7fcd1bc30460</p>
<p>// copy后返回的是不可变对象（即 arr 是 NSArray 类型，NSArray 类型对象不能调用 NSMutableArray 类型对象的方法）</p>
<p>原因：是因为 copy 就是复制一个不可变 NSArray 的对象，不能对 NSArray 对象进行添加/修改。</p>
<p><strong>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？</strong></p>
<p>若想令自己所写的对象具有拷贝功能，则需实现 NSCopying 协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。</p>
<p>具体步骤：</p>
<ol>
<li><p>需声明该类遵从 NSCopying 协议</p>
</li>
<li><p>实现 NSCopying 协议的方法。</p>
</li>
</ol>
<p>// 该协议只有一个方法:</p>
<p>- (id)copyWithZone:(NSZone *)zone;</p>
<p>// 注意：使用 copy 修饰符，调用的是copy方法，其实真正需要实现的是 “copyWithZone” 方法。</p>
<p><strong>@synthesize 和 @dynamic 分别有什么作用？</strong></p>
<p>@property有两个对应的词，一个是@synthesize（合成实例变量），一个是@dynamic。</p>
<p>如果@synthesize和@dynamic都没有写，那么默认的就是 @synthesize var = _var;</p>
<p>// 在类的实现代码里通过 @synthesize 语法可以来指定实例变量的名字。(@synthesize var = _newVar;)</p>
<ol>
<li><p>@synthesize 的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法。</p>
</li>
<li><p>@dynamic 告诉编译器，属性的setter与getter方法由用户自己实现，不自动生成（如，@dynamic var）。</p>
</li>
</ol>
<p><strong>常见的 Objective-C 的数据类型有那些，和C的基本数据类型有什么区别？如：NSInteger和int</strong></p>
<p>答：</p>
<p>Objective-C的数据类型有NSString，NSNumber，NSArray，NSMutableArray，NSData等等，这些都是class，创建后便是对象，而C语言的基本数据类型int，只是一定字节的内存空间，用于存放数值;NSInteger是基本数据类型，并不是NSNumber的子类，当然也不是NSObject的子类。NSInteger是基本数据类型Int或者Long的别名(NSInteger的定义typedef long NSInteger)，它的区别在于，NSInteger会根据系统是32位还是64位来决定是本身是int还是long。</p>
<p><strong>id 声明的对象有什么特性？</strong></p>
<p>答：id 声明的对象具有运行时的特性，即可以指向任意类型的Objcetive-C的对象。</p>
<p><strong>Objective-C 如何对内存管理的，说说你的看法和解决方法？</strong></p>
<p>答：Objective-C的内存管理主要有三种方式ARC(自动内存计数)、手动内存计数、内存池。</p>
<p>(1). 自动内存计数ARC：由Xcode自动在App编译阶段，在代码中添加内存管理代码。</p>
<p>(2). 手动内存计数MRC：遵循内存谁申请、谁释放；谁添加，谁释放的原则。</p>
<p>(3). 内存释放池Release Pool：把需要释放的内存统一放在一个池子中，当池子被抽干后(drain)，池子中所有的内存空间也被自动释放掉。内存池的释放操作分为自动和手动。自动释放受runloop机制影响。</p>
<p><strong>Objective-C 中创建线程的方法是什么？如果在主线程中执行代码，方法是什么？如果想延时执行代码、方法又是什么？</strong></p>
<p>答：线程创建有三种方法：使用NSThread创建、使用GCD的dispatch、使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread</p>
<p><strong>Category（类别）、 Extension（扩展）和继承的区别</strong></p>
<p>区别：</p>
<ol>
<li><p>分类有名字，类扩展没有分类名字，是一种特殊的分类。</p>
</li>
<li><p>分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法。</p>
</li>
<li><p>继承可以增加，修改或者删除方法，并且可以增加属性。</p>
</li>
</ol>
<p><strong>我们说的OC是动态运行时语言是什么意思？</strong></p>
<p>答：主要是将数据类型的确定由编译时，推迟到了运行时。简单来说, 运行时机制使我们直到运行时才去决定一个对象的类别,以及调用该类别对象指定方法。</p>
<p><strong>为什么我们常见的delegate属性都用是week而不是retain/strong？</strong></p>
<p>答：是为了防止delegate两端产生不必要的循环引用。</p>
<p><strong>什么时候用delete，什么时候用Notification？</strong></p>
<p>Delegate(委托模式)：1对1的反向消息通知功能。</p>
<p>Notification(通知模式)：只想要把消息发送出去，告知某些状态的变化。但是并不关心谁想要知道这个。</p>
<p><strong>什么是 KVO 和 KVC？</strong></p>
<p>(1). KVC(Key-Value-Coding)：键值编码 是一种通过字符串间接访问对象的方式（即给属性赋值）</p>
<p>举例说明：</p>
<blockquote>
<p>   stu.name = @”张三” // 点语法给属性赋值</p>
<p>   [stu setValue:@”张三” forKey:@”name”]; // 通过字符串使用KVC方式给属性赋值</p>
<p>   stu1.nameLabel.text = @”张三”;</p>
<p>   [stu1 setValue:@”张三” forKey:@”nameLabel.text”]; // 跨层赋值</p>
</blockquote>
<p>2). KVO(key-Value-Observing)：键值观察机制 他提供了观察某一属性变化的方法，极大的简化了代码。</p>
<p>​     KVO只能被KVC触发，包括使用setValue:forKey:方法和点语法。</p>
<p>KVC 和 KVO 的 keyPath 可以是属性、实例变量、成员变量。</p>
<p><strong>KVC的底层实现？</strong></p>
<p>当一个对象调用setValue方法时，方法内部会做以下操作：</p>
<p>(1). 检查是否存在相应的key的set方法，如果存在，就调用set方法。</p>
<p>(2). 如果set方法不存在，就会查找与key相同名称并且带下划线的成员变量，如果有，则直接给成员变量属性赋值。</p>
<p>(3). 如果没有找到_key，就会查找相同名称的属性key，如果有就直接赋值。</p>
<p>(4). 如果还没有找到，则调用valueForUndefinedKey:和setValue:forUndefinedKey:方法。</p>
<p>这些方法的默认实现都是抛出异常，我们可以根据需要重写它们。</p>
<p><strong>KVO的底层实现？</strong></p>
<p>KVO基于runtime机制实现。</p>
<p><strong>ViewController生命周期</strong></p>
<p>按照执行顺序排列：</p>
<ol>
<li><p>initWithCoder：通过nib文件初始化时触发。</p>
</li>
<li><p>awakeFromNib：nib文件被加载的时候，会发生一个awakeFromNib的消息到nib文件中的每个对象。      </p>
</li>
<li><p>loadView：开始加载视图控制器自带的view。</p>
</li>
<li><p>viewDidLoad：视图控制器的view被加载完成。  </p>
</li>
<li><p>viewWillAppear：视图控制器的view将要显示在window上。</p>
</li>
<li><p>updateViewConstraints：视图控制器的view开始更新AutoLayout约束。</p>
</li>
<li><p>viewWillLayoutSubviews：视图控制器的view将要更新内容视图的位置。</p>
</li>
<li><p>viewDidLayoutSubviews：视图控制器的view已经更新视图的位置。</p>
</li>
<li><p>viewDidAppear：视图控制器的view已经展示到window上。</p>
</li>
<li><p>viewWillDisappear：视图控制器的view将要从window上消失。</p>
</li>
<li><p>viewDidDisappear：视图控制器的view已经从window上消失。</p>
</li>
</ol>
<p><strong>方法和选择器有何不同？</strong></p>
<p>selector是一个方法的名字，方法是一个组合体，包含了名字和实现。</p>
<p><strong>你是否接触过OC中的反射机制？简单聊一下概念和使用</strong></p>
<p>(1). class反射</p>
<p>通过类名的字符串形式实例化对象。</p>
<blockquote>
<p>Class class = NSClassFromString(@”student”);</p>
<p>Student *stu = [[class alloc] init];</p>
</blockquote>
<p>将类名变为字符串。</p>
<blockquote>
<p>Class class =[Student class];</p>
<p>NSString *className = NSStringFromClass(class);</p>
</blockquote>
<p>(2). SEL的反射</p>
<p>通过方法的字符串形式实例化方法。</p>
<blockquote>
<p>SEL selector = NSSelectorFromString(@”setName”);  </p>
<p>[stu performSelector:selector withObject:@”Mike”];</p>
</blockquote>
<p>将方法变成字符串。</p>
<blockquote>
<p>NSStringFromSelector(@selector*(setName:));</p>
</blockquote>
<p><strong>调用方法有两种方式：</strong></p>
<p>(1). 直接通过方法名来调用。[person show];</p>
<p>(2). 间接的通过SEL数据来调用 SEL aaa = @selector(show); [person performSelector:aaa];  </p>
<p><strong>如何对iOS设备进行性能测试？</strong></p>
<p>答： Profile-&gt; Instruments -&gt;Time Profiler</p>
<p><strong>开发项目时你是怎么检查内存泄露？</strong></p>
<p>(1). 静态分析 analyze。</p>
<p>(2). instruments工具里面有个leak可以动态分析。</p>
<p><strong>什么是懒加载？</strong></p>
<p>答：懒加载就是只在用到的时候才去初始化。也可以理解成延时加载。</p>
<p>我觉得最好也最简单的一个例子就是tableView中图片的加载显示了, 一个延时加载, 避免内存过高,一个异步加载,避免线程堵塞提高用户体验。</p>
<p><strong>类变量的 @public，@protected，@private，@package 声明各有什么含义？</strong></p>
<p>@public 任何地方都能访问;</p>
<p>@protected 该类和子类中访问,是默认的;</p>
<p>@private 只能在本类中访问;</p>
<p>@package 本包内使用,跨包不可以。</p>
<p><strong>什么是谓词？</strong></p>
<p>谓词就是通过NSPredicate给定的逻辑条件作为约束条件,完成对数据的筛选。</p>
<p>//定义谓词对象,谓词对象中包含了过滤条件(过滤条件比较多)</p>
<p>NSPredicate *predicate = [NSPredicate predicateWithFormat:@”age&lt;%d”,30];</p>
<p>//使用谓词条件过滤数组中的元素,过滤之后返回查询的结果</p>
<p>NSArray *array = [persons filteredArrayUsingPredicate:predicate];</p>
<p><strong>isa指针问题</strong></p>
<p>isa：是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类,而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调 用时,先会从本身查找类方法的实现,如果没有,元类会向他父类查找该方法。同时注意的是:元类(meteClass)也是类,它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass)。根元类的isa指针指向本身,这样形成了一个封闭的内循环。</p>
<p><strong>如何访问并修改一个类的私有属性？</strong></p>
<p>(1). 一种是通过KVC获取。</p>
<p>(2). 通过runtime访问并修改私有属性。</p>
<p><strong>一个objc对象的isa的指针指向什么？有什么作用？</strong></p>
<p>答：指向他的类对象,从而可以找到对象上的方法。</p>
<p><strong>isKindOfClass、isMemberOfClass、selector作用分别是什么</strong></p>
<p>isKindOfClass：作用是某个对象属于某个类型或者继承自某类型。</p>
<p>isMemberOfClass：某个对象确切属于某个类型。</p>
<p>selector：通过方法名，获取在内存中的函数的入口地址。</p>
<p><strong>delegate 和 notification 的区别</strong></p>
<p>(1). 二者都用于传递消息，不同之处主要在于一个是一对一的，另一个是一对多的。</p>
<p>(2). notification通过维护一个array，实现一对多消息的转发。</p>
<p>(3). delegate需要两者之间必须建立联系，不然没法调用代理的方法；notification不需要两者之间有联系。</p>
<p><strong>什么是block？</strong></p>
<p>闭包（block）：闭包就是获取其它函数局部变量的匿名函数。</p>
<p><strong>block反向传值</strong></p>
<p>在控制器间传值可以使用代理或者block，使用block相对来说简洁。</p>
<p><strong>block的注意点</strong></p>
<p>(1). 在block内部使用外部指针且会造成循环引用情况下，需要用__week修饰外部指针：</p>
<p>__weak typeof(self) weakSelf = self;</p>
<p>(2). 在block内部如果调用了延时函数还使用弱指针会取不到该指针，因为已经被销毁了，需要在block内部再将弱指针重新强引用一下。</p>
<p>__strong typeof(self) strongSelf = weakSelf;</p>
<p>(3). 如果需要在block内部改变外部栈区变量的话，需要在用__block修饰外部变量。</p>
<p><strong>BAD_ACCESS在什么情况下出现？</strong></p>
<p>答：这种问题在开发时经常遇到。原因是访问了野指针，比如访问已经释放对象的成员变量或者发消息、死循环等。</p>
<p><strong>lldb（gdb）常用的控制台调试命令？</strong></p>
<p>(1). p 输出基本类型。是打印命令，需要指定类型。是print的简写</p>
<p>p (int)[[[self view] subviews] count]</p>
<p>(2). po 打印对象，会调用对象description方法。是print-object的简写</p>
<p>po [self view]</p>
<p>(3). expr 可以在调试时动态执行指定表达式，并将结果打印出来。常用于在调试过程中修改变量的值。</p>
<p>(4). bt：打印调用堆栈，是thread backtrace的简写，加all可打印所有thread的堆栈</p>
<p>(5). br l：是breakpoint list的简写</p>
<p><strong>你一般是怎么用Instruments的？</strong></p>
<p>Instruments里面工具很多，常用：</p>
<p>(1). Time Profiler: 性能分析</p>
<p>(2). Zombies：检查是否访问了僵尸对象，但是这个工具只能从上往下检查，不智能。</p>
<p>(3). Allocations：用来检查内存，写算法的那批人也用这个来检查。</p>
<p>(4). Leaks：检查内存，看是否有内存泄露。</p>
<p><strong>iOS中常用的数据存储方式有哪些？</strong></p>
<p>数据存储有四种方案：NSUserDefault、KeyChain、file、DB。</p>
<p>其中File有三种方式：plist、Archive（归档）</p>
<p>DB包括：SQLite、FMDB、CoreData</p>
<p><strong>iOS的沙盒目录结构是怎样的？</strong></p>
<p>沙盒结构：</p>
<p>(1). Application：存放程序源文件，上架前经过数字签名，上架后不可修改。</p>
<p>(2). Documents：常用目录，iCloud备份目录，存放数据。（这里不能存缓存文件，否则上架不被通过）</p>
<p>(3). Library：</p>
<p>Caches：存放体积大又不需要备份的数据。(常用的缓存路径)</p>
<p>Preference：设置目录，iCloud会备份设置信息。</p>
<p>(4). tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能。</p>
<p><strong>iOS多线程技术有哪几种方式？</strong></p>
<p>答：pthread、NSThread、GCD、NSOperation</p>
<p><strong>GCD 与 NSOperation 的区别：</strong></p>
<p>GCD 和 NSOperation 都是用于实现多线程：</p>
<p>GCD 基于C语言的底层API，GCD主要与block结合使用，代码简洁高效。</p>
<p>NSOperation 属于Objective-C类，是基于GCD更高一层的封装。复杂任务一般用NSOperation实现。</p>
<p><strong>写出使用GCD方式从子线程回到主线程的方法代码</strong></p>
<p>答：</p>
<blockquote>
<p>dispatch_sync(dispatch_get_main_queue(), ^{ });</p>
</blockquote>
<p><strong>如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）</strong><br><strong>dispatch_barrier_async（栅栏函数）的作用是什么？</strong></p>
<p>函数定义：dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</p>
<p>作用：</p>
<p>1.在它前面的任务执行结束后它才执行，它后面的任务要等它执行完成后才会开始执行。</p>
<p>2.避免数据竞争<br><strong>什么是 RunLoop</strong></p>
<p>从字面上讲就是运行循环，它内部就是do-while循环，在这个循环内部不断地处理各种任务。</p>
<p>一个线程对应一个RunLoop，基本作用就是保持程序的持续运行，处理app中的各种事件。通过runloop，有事运行，没事就休息，可以节省cpu资源，提高程序性能。</p>
<p>主线程的run loop默认是启动的。</p>
<p><strong>什么是 Runtime</strong></p>
<p>Runtime又叫运行时，是一套底层的C语言API，其为iOS内部的核心之一，我们平时编写的OC代码，底层都是基于它来实现的。</p>
<p><strong>Runtime实现的机制是什么，怎么用，一般用于干嘛？</strong></p>
<p>1). 使用时需要导入的头文件 <objc message.h=""> <objc runtime.h=""></objc></objc></p>
<p>2). Runtime 运行时机制，它是一套C语言库。</p>
<p>3). 实际上我们编写的所有OC代码，最终都是转成了runtime库的东西。</p>
<p>比如：</p>
<p>类转成了 Runtime 库里面的结构体等数据类型，</p>
<p>方法转成了 Runtime 库里面的C语言函数，</p>
<p>平时调方法都是转成了 objc_msgSend 函数（所以说OC有个消息发送机制）</p>
<p>// OC是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)。</p>
<p>// [stu show];  在objc动态编译时，会被转意为：objc_msgSend(stu, @selector(show));</p>
<p>4). 因此，可以说 Runtime 是OC的底层实现，是OC的幕后执行者。</p>
<p>有了Runtime库，能做什么事情呢？</p>
<p> Runtime库里面包含了跟类、成员变量、方法相关的API。</p>
<p> 比如：</p>
<p>​    （1）获取类里面的所有成员变量。</p>
<p>​    （2）为类动态添加成员变量。</p>
<p>​    （3）动态改变类的方法实现。</p>
<p>​    （4）为类动态添加新的方法等。</p>
<p> 因此，有了Runtime，想怎么改就怎么改。</p>
<p><strong>什么是 Method Swizzle（黑魔法），什么情况下会使用？</strong></p>
<p>(1). 在没有一个类的实现源码的情况下，想改变其中一个方法的实现，除了继承它重写、和借助类别重名方法暴力抢先之外，还有更加灵活的方法 Method Swizzle。</p>
<p>(2). Method Swizzle 指的是改变一个已存在的选择器对应的实现的过程。OC中方法的调用能够在运行时通过改变，通过改变类的调度表中选择器到最终函数间的映射关系。</p>
<p>(3). 在OC中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用OC的动态特性，可以实现在运行时偷换selector对应的方法实现。</p>
<p>(4). 每个类都有一个方法列表，存放着selector的名字和方法实现的映射关系。IMP有点类似函数指针，指向具体的方法实现。</p>
<p>(5). 我们可以利用 method_exchangeImplementations 来交换2个方法中的IMP。</p>
<p>(6). 我们可以利用 class_replaceMethod 来修改类。</p>
<p>(7). 我们可以利用 method_setImplementation 来直接设置某个方法的IMP。</p>
<p>(8). 归根结底，都是偷换了selector的IMP。</p>
<p><strong>_objc_msgForward 函数是做什么的，直接调用它将会发生什么？</strong></p>
<p>答：_objc_msgForward是 IMP 类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发。</p>
<p><strong>什么是 TCP / UDP ?</strong></p>
<p>TCP：传输控制协议。</p>
<p>UDP：用户数据协议。</p>
<p>TCP 是面向连接的，建立连接需要经历三次握手，是可靠的传输层协议。</p>
<p>UDP 是面向无连接的，数据传输是不可靠的，它只管发，不管收不收得到。</p>
<p>简单的说，TCP注重数据安全，而UDP数据传输快点，但安全性一般。</p>
<p><strong>通信底层原理（OSI七层模型）</strong></p>
<p>OSI采用了分层的结构化技术，共分七层：</p>
<p>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p><strong>介绍一下XMPP？</strong></p>
<p>XMPP是一种以XML为基础的开放式实时通信协议。</p>
<p>简单的说，XMPP就是一种协议，一种规定。就是说，在网络上传东西，XMM就是规定你上传大小的格式。<br><strong>tableView的重用机制？</strong></p>
<p>答：UITableView 通过重用单元格来达到节省内存的目的: 通过为每个单元格指定一个重用标识符，即指定了单元格的种类,当屏幕上的单元格滑出屏幕时，系统会把这个单元格添加到重用队列中，等待被重用，当有新单元格从屏幕外滑入屏幕内时，从重用队列中找看有没有可以重用的单元格，如果有，就拿过来用，如果没有就创建一个来使用。</p>
<p><strong>如何实现视图的变形?</strong></p>
<p>答：通过修改view的 transform 属性即可。</p>
<p><strong>在手势对象基础类UIGestureRecognizer的常用子类手势类型中哪两个手势发生后，响应只会执行一次？</strong></p>
<p>答：UITapGestureRecognizer,UISwipeGestureRecognizer是一次性手势,手势发生后,响应只会执行一次。</p>
<p><strong>字符串常用方法：</strong></p>
<p>NSString <em>str = @”abc</em>123”;</p>
<p>NSArray <em>arr = [str componentsSeparatedByString:@”</em>“]; //以目标字符串把原字符串分割成两部分，存到数组中。@[@”abc”, @”123”];</p>
<p><strong>你是怎么封装一个view的</strong></p>
<p>(1）. 可以通过纯代码或者xib的方式来封装子控件</p>
<p>(2）. 建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值<br><strong>HTTP协议中 POST 方法和 GET 方法有那些区别?</strong></p>
<ol>
<li><p>GET用于向服务器请求数据，POST用于提交数据</p>
</li>
<li><p>GET请求，请求参数拼接形式暴露在地址栏，而POST请求参数则放在请求体里面，因此GET请求不适合用于验证密码等操作</p>
</li>
<li><p>GET请求的URL有长度限制，POST请求不会有长度限制</p>
</li>
</ol>
<p><strong>请简单的介绍下APNS发送系统消息的机制</strong></p>
<p>APNS优势：杜绝了类似安卓那种为了接受通知不停在后台唤醒程序保持长连接的行为，由iOS系统和APNS进行长连接替代。</p>
<p>APNS的原理：</p>
<p>(1). 应用在通知中心注册，由iOS系统向APNS请求返回设备令牌(device Token)</p>
<p>(2). 应用程序接收到设备令牌并发送给自己的后台服务器</p>
<p>(3). 服务器把要推送的内容和设备发送给APNS</p>
<p>(4). APNS根据设备令牌找到设备，再由iOS根据APPID把推送内容展示</p>
<p><strong>第三方框架</strong></p>
<hr>
<p><strong>AFNetworking 底层原理分析</strong></p>
<p>AFNetworking主要是对NSURLSession和NSURLConnection(iOS9.0废弃)的封装,其中主要有以下类:</p>
<p>(1). AFHTTPRequestOperationManager：内部封装的是 NSURLConnection, 负责发送网络请求, 使用最多的一个类。(3.0废弃)</p>
<p>(2). AFHTTPSessionManager：内部封装是 NSURLSession, 负责发送网络请求,使用最多的一个类。</p>
<p>(3). AFNetworkReachabilityManager：实时监测网络状态的工具类。当前的网络环境发生改变之后,这个工具类就可以检测到。</p>
<p>(4). AFSecurityPolicy：网络安全的工具类, 主要是针对 HTTPS 服务。</p>
<p>(5). AFURLRequestSerialization：序列化工具类,基类。上传的数据转换成JSON格式</p>
<p>(AFJSONRequestSerializer).使用不多。</p>
<p>(6). AFURLResponseSerialization：反序列化工具类;基类.使用比较多:</p>
<p>(7). AFJSONResponseSerializer; JSON解析器,默认的解析器.</p>
<p>(8). AFHTTPResponseSerializer; 万能解析器; JSON和XML之外的数据类型,直接返回二进制数据.对服务器返回的数据不做任何处理.</p>
<p>(9). AFXMLParserResponseSerializer; XML解析器;</p>
<p><strong>描述下SDWebImage里面给UIImageView加载图片的逻辑</strong></p>
<p>SDWebImage 中为 UIImageView 提供了一个分类UIImageView+WebCache.h, 这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后再替换占位图片。</p>
<p>​    </p>
<p>加载图片的过程大致如下：</p>
<p>1.首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存</p>
<p>2.如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来</p>
<p>3.如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片</p>
<p>4.下载后的图片会加入缓存中，并写入磁盘中</p>
<p>5.整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来</p>
<p>SDWebImage原理：</p>
<p>调用类别的方法：</p>
<ol>
<li><p>从内存（字典）中找图片（当这个图片在本次使用程序的过程中已经被加载过），找到直接使用。</p>
</li>
<li><p>从沙盒中找（当这个图片在之前使用程序的过程中被加载过），找到使用，缓存到内存中。</p>
</li>
<li><p>从网络上获取，使用，缓存到内存，缓存到沙盒。</p>
</li>
</ol>
<p><strong>友盟统计接口统计的所有功能</strong></p>
<p>APP启动速度，APP停留页面时间等</p>
<p><strong>算法</strong></p>
<hr>
<p><strong>模拟栈操作</strong></p>
<blockquote>
<p> /**</p>
<ul>
<li><p>栈是一种数据结构，特点：先进后出</p>
</li>
<li><p>练习：使用全局变量模拟栈的操作</p>
<p>*/</p>
</li>
</ul>
<p>#include <stdio.h></stdio.h></p>
<p>#include <stdbool.h></stdbool.h></p>
<p>#include <assert.h></assert.h></p>
<p>//保护全局变量：在全局变量前加static后，这个全局变量就只能在本文件中使用</p>
<p>static int data[1024];//栈最多能保存1024个数据</p>
<p>static int count = 0;//目前已经放了多少个数(相当于栈顶位置)</p>
<p>//数据入栈 push</p>
<p>void push(int x){</p>
<p>  assert(!full());//防止数组越界</p>
<p>data[count++] = x;</p>
<p>}</p>
<p>//数据出栈 pop</p>
<p>int pop(){</p>
<p>assert(!empty());</p>
<p>return data[–count];</p>
<p>}</p>
<p>//查看栈顶元素 top</p>
<p>int top(){</p>
<p>assert(!empty());</p>
<p>return data[count-1];</p>
<p>}</p>
<p>//查询栈满 full</p>
<p>bool full() {</p>
<p>if(count &gt;= 1024) {</p>
<p>​     return 1;</p>
<p>}</p>
<p>​     return 0;</p>
<p>}</p>
<p>//查询栈空 empty</p>
<p>bool empty() {</p>
<p>if(count &lt;= 0) {</p>
<p>return 1;</p>
<p>}</p>
<p>​    return 0;</p>
<p>}</p>
<p>int main(){</p>
<p>​    //入栈</p>
<p>​    for (int i = 1; i &lt;= 10; i++) {</p>
<p>​        push(i);</p>
<p>​    }</p>
<p>​    //出栈</p>
<p>​    while(!empty()){</p>
<p>​        printf(“%d “, top()); //栈顶元素</p>
<p>​        pop(); //出栈</p>
<p>​    }</p>
<p>​    printf(“ “);</p>
<p>​    </p>
<p>​    return 0;</p>
<p>}</p>
</blockquote>
<p><strong>排序算法</strong></p>
<p>选择排序、冒泡排序、插入排序三种排序算法可以总结为如下：</p>
<ul>
<li>都将数组分为已排序部分和未排序部分。</li>
</ul>
<ol>
<li><p>选择排序将已排序部分定义在左端，然后选择未排序部分的最小元素和未排序部分的第一个元素交换。</p>
</li>
<li><p>冒泡排序将已排序部分定义在右端，在遍历未排序部分的过程执行交换，将最大元素交换到最右端。</p>
</li>
<li><p>插入排序将已排序部分定义在左端，将未排序部分元的第一个元素插入到已排序部分合适的位置。</p>
</li>
</ol>
<p><strong>编码格式（优化细节）</strong></p>
<p>在 Objective-C 中，enum 建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型。</p>
<p>避免使用C语言中的基本数据类型，建议使用 Foundation 数据类型，对应关系如下：</p>
<p>int -&gt; NSInteger</p>
<p>unsigned -&gt; NSUInteger</p>
<p>float -&gt; CGFloat</p>
<p>动画时间 -&gt; NSTimeInterval</p>
<p><strong>其它知识点</strong></p>
<p><strong>HomeKit</strong>，是苹果2014年发布的智能家居平台。</p>
<p><strong>什么是 OpenGL、Quartz 2D？</strong></p>
<p>Quatarz 2d 是Apple提供的基本图形工具库。只是适用于2D图形的绘制。</p>
<p>OpenGL，是一个跨平台的图形开发库。适用于2D和3D图形的绘制。</p>
<p><strong>ffmpeg框架</strong>：ffmpeg 是音视频处理工具，既有音视频编码解码功能，又可以作为播放器使用。</p>
<p><strong>谈谈 UITableView 的优化</strong></p>
<p>(1). 正确的复用cell。</p>
<p>(2). 设计统一规格的Cell</p>
<p>(3). 提前计算并缓存好高度（布局），因为heightForRowAtIndexPath:是调用最频繁的方法；</p>
<p>(4). 异步绘制，遇到复杂界面，遇到性能瓶颈时，可能就是突破口；</p>
<p>(4). 滑动时按需加载，这个在大量图片展示，网络加载的时候很管用！</p>
<p>(5). 减少子视图的层级关系</p>
<p>(6). 尽量使所有的视图不透明化以及做切圆操作。</p>
<p>(7). 不要动态的add 或者 remove 子控件。最好在初始化时就添加完，然后通过hidden来控制是否显示。</p>
<p>(8). 使用调试工具分析问题。</p>
<p><strong>如何实行cell的动态的行高</strong></p>
<p>如果希望每条数据显示自身的行高，必须设置两个属性，1.预估行高，2.自定义行高。</p>
<p>设置预估行高 tableView.estimatedRowHeight = 200。</p>
<p>设置定义行高 tableView.estimatedRowHeight = UITableViewAutomaticDimension。</p>
<p>如果要让自定义行高有效，必须让容器视图有一个自下而上的约束。</p>
<p><strong>说说你对 block 的理解</strong></p>
<p>栈上的自动复制到堆上，block 的属性修饰符是 copy，循环引用的原理和解决方案。</p>
<p><strong>说说你对 runtime 的理解</strong></p>
<p>主要是方法调用时如何查找缓存，如何找到方法，找不到方法时怎么转发，对象的内存布局。</p>
<p><strong>什么是野指针、空指针？</strong></p>
<p>野指针：不知道指向了哪里的指针叫野指针。即指针指向不确定，指针存的地址是一个垃圾值，未初始化。</p>
<p>空指针：不指向任何位置的指针叫空指针。即指针没有指向，指针存的地址是一个空地址，NULL。</p>
<p><strong>什么是 OOA / OOD / OOP ?</strong></p>
<p>OOA（Object Oriented Analysis）   –面向对象分析</p>
<p>OOD（Object Oriented Design）     –面向对象设计</p>
<p>OOP（Object Oriented Programming）–面向对象编程</p>
]]></content>
      
        <categories>
            
            <category> iOS基本知识回顾 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Object-C </tag>
            
            <tag> runtime </tag>
            
            <tag> runloop </tag>
            
            <tag> block </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS知识点方便查阅(含代码)]]></title>
      <url>/2016/05/21/blog_littleKey/</url>
      <content type="html"><![CDATA[<p>笔者最近读了一本书叫做《编写高质量 iOS 与 OSX 代码的52个有效方法》,没错，就是这本书，读完这本书，对于代码标准和规范我就格外上心了，但是自己也做了笔记，大概就是一下这些，其实都很基础啦，但是呢，有时候真的想不起来，哈哈，你们有木有呢？<br><a id="more"></a></p>
<h3 id="1、设置UILabel行间距"><a href="#1、设置UILabel行间距" class="headerlink" title="1、设置UILabel行间距"></a>1、设置UILabel行间距</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableAttributedString* attrString = [[NSMutableAttributedString  alloc] initWithString:label.text];    NSMutableParagraphStyle *style = [[NSMutableParagraphStyle alloc] init];    [style setLineSpacing:20];    [attrString addAttribute:NSParagraphStyleAttributeName value:style range:NSMakeRange(0, label.text.length)];    label.attributedText = attrString;</div></pre></td></tr></table></figure>
<h3 id="2、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题"><a href="#2、当使用-performSelector-withObject-withObject-afterDelay-方法时，需要传入多参数问题" class="headerlink" title="2、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题"></a>2、当使用-performSelector:withObject:withObject:afterDelay:方法时，需要传入多参数问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、// 把参数放进一个数组／字典，直接把数组／字典当成一个参数传过去，具体方法实现的地方再解析这个数组／字典NSArray * array =     [NSArray arrayWithObjects: @&quot;first&quot;, @&quot;second&quot;, nil];[self performSelector:@selector(fooFirstInput:) withObject: array afterDelay:15.0];// 方法二、// 使用NSInvocationSEL aSelector = NSSelectorFromString(@&quot;doSoming:argument2:&quot;);    NSInteger argument1 = 10;    NSString *argument2 = @&quot;argument2&quot;;    if([self respondsToSelector:aSelector]) &#123;        NSInvocation *inv = [NSInvocation invocationWithMethodSignature:[self methodSignatureForSelector:aSelector]];        [inv setSelector:aSelector];        [inv setTarget:self];        [inv setArgument:&amp;(argument1) atIndex:2];        [inv setArgument:&amp;(argument2) atIndex:3];        [inv performSelector:@selector(invoke) withObject:nil afterDelay:15.0];    &#125;</div></pre></td></tr></table></figure>
<h3 id="3、UILabel显示不同颜色字体"><a href="#3、UILabel显示不同颜色字体" class="headerlink" title="3、UILabel显示不同颜色字体"></a>3、UILabel显示不同颜色字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableAttributedString * string = [[NSMutableAttributedString alloc] initWithString:label.text];[string addAttribute:NSForegroundColorAttributeName value:[UIColor redColor] range:NSMakeRange(0,5)];[string addAttribute:NSForegroundColorAttributeName value:[UIColor greenColor] range:NSMakeRange(5,6)];[string addAttribute:NSForegroundColorAttributeName value:[UIColor blueColor] range:NSMakeRange(11,5)];label.attributedText = string;</div></pre></td></tr></table></figure>
<h3 id="4、比较两个CGRect-CGSize-CGPoint是否相等"><a href="#4、比较两个CGRect-CGSize-CGPoint是否相等" class="headerlink" title="4、比较两个CGRect/CGSize/CGPoint是否相等"></a>4、比较两个CGRect/CGSize/CGPoint是否相等</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (CGRectEqualToRect(rect1, rect2)) &#123; // 两个区域相等        // do some    &#125;    if (CGPointEqualToPoint(point1, point2)) &#123; // 两个点相等        // do some    &#125;    if (CGSizeEqualToSize(size1, size2)) &#123; // 两个size相等        // do some    &#125;</div></pre></td></tr></table></figure>
<h3 id="5、比较两个NSDate相差多少小时"><a href="#5、比较两个NSDate相差多少小时" class="headerlink" title="5、比较两个NSDate相差多少小时"></a>5、比较两个NSDate相差多少小时</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSDate* date1 = someDate; NSDate* date2 = someOtherDate; NSTimeInterval distanceBetweenDates = [date1 timeIntervalSinceDate:date2]; double secondsInAnHour = 3600;// 除以3600是把秒化成小时，除以60得到结果为相差的分钟数 NSInteger hoursBetweenDates = distanceBetweenDates / secondsInAnHour;</div></pre></td></tr></table></figure>
<h3 id="6、每个cell之间增加间距"><a href="#6、每个cell之间增加间距" class="headerlink" title="6、每个cell之间增加间距"></a>6、每个cell之间增加间距</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一，每个分区只显示一行cell，分区头当作你想要的间距(注意，从数据源数组中取值的时候需要用indexPath.section而不是indexPath.row)- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123;    return yourArry.count;&#125;- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section&#123;    return 1;&#125;-(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section&#123;    return cellSpacingHeight;&#125;// 方法二，在cell的contentView上加个稍微低一点的view，cell上原本的内容放在你的view上，而不是contentView上，这样能伪造出一个间距来。// 方法三，自定义cell，重写setFrame：方法- (void)setFrame:(CGRect)frame&#123;    frame.size.height -= 20;    [super setFrame:frame];&#125;</div></pre></td></tr></table></figure>
<h3 id="7、播放一张张连续的图片"><a href="#7、播放一张张连续的图片" class="headerlink" title="7、播放一张张连续的图片"></a>7、播放一张张连续的图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 加入现在有三张图片分别为animate_1、animate_2、animate_3// 方法一    imageView.animationImages = @[[UIImage imageNamed:@&quot;animate_1&quot;], [UIImage imageNamed:@&quot;animate_2&quot;], [UIImage imageNamed:@&quot;animate_3&quot;]];imageView.animationDuration = 1.0;// 方法二    imageView.image = [UIImage animatedImageNamed:@&quot;animate_&quot; duration:1.0];// 方法二解释下，这个方法会加载animate_为前缀的，后边0-1024，也就是animate_0、animate_1一直到animate_1024</div></pre></td></tr></table></figure>
<h3 id="8、加载gif图片"><a href="#8、加载gif图片" class="headerlink" title="8、加载gif图片"></a>8、加载gif图片</h3><blockquote>
<p>推荐使用这个框架 FLAnimatedImage</p>
</blockquote>
<h3 id="9、防止离屏渲染为image添加圆角"><a href="#9、防止离屏渲染为image添加圆角" class="headerlink" title="9、防止离屏渲染为image添加圆角"></a>9、防止离屏渲染为image添加圆角</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// image分类- (UIImage *)circleImage&#123;// NO代表透明UIGraphicsBeginImageContextWithOptions(self.size, NO, 1);// 获得上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 添加一个圆CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);// 方形变圆形CGContextAddEllipseInRect(ctx, rect);// 裁剪CGContextClip(ctx);// 将图片画上去[self drawInRect:rect];UIImage *image = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return image;&#125;</div></pre></td></tr></table></figure>
<h3 id="10、查看系统所有字体"><a href="#10、查看系统所有字体" class="headerlink" title="10、查看系统所有字体"></a>10、查看系统所有字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 打印字体for (id familyName in [UIFont familyNames]) &#123;    NSLog(@&quot;%@&quot;, familyName);    for (id fontName in [UIFont fontNamesForFamilyName:familyName]) NSLog(@&quot;  %@&quot;, fontName);&#125;// 也可以进入这个网址查看 http://iosfonts.com/</div></pre></td></tr></table></figure>
<h3 id="11、获取随机数"><a href="#11、获取随机数" class="headerlink" title="11、获取随机数"></a>11、获取随机数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSInteger i = arc4random();</div></pre></td></tr></table></figure>
<h3 id="12、获取随机数小数-0-1之间"><a href="#12、获取随机数小数-0-1之间" class="headerlink" title="12、获取随机数小数(0-1之间)"></a>12、获取随机数小数(0-1之间)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ARC4RANDOM_MAX      0x100000000double val = ((double)arc4random() / ARC4RANDOM_MAX);</div></pre></td></tr></table></figure>
<h3 id="13、AVPlayer视频播放完成的通知监听"><a href="#13、AVPlayer视频播放完成的通知监听" class="headerlink" title="13、AVPlayer视频播放完成的通知监听"></a>13、AVPlayer视频播放完成的通知监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter]       addObserver:self      selector:@selector(videoPlayEnd)      name:AVPlayerItemDidPlayToEndTimeNotification       object:nil];</div></pre></td></tr></table></figure>
<h3 id="14、判断两个rect是否有交叉"><a href="#14、判断两个rect是否有交叉" class="headerlink" title="14、判断两个rect是否有交叉"></a>14、判断两个rect是否有交叉</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (CGRectIntersectsRect(rect1, rect2)) &#123;&#125;</div></pre></td></tr></table></figure>
<h3 id="15、判断一个字符串是否为数字"><a href="#15、判断一个字符串是否为数字" class="headerlink" title="15、判断一个字符串是否为数字"></a>15、判断一个字符串是否为数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSCharacterSet *notDigits = [[NSCharacterSet decimalDigitCharacterSet] invertedSet];    if ([str rangeOfCharacterFromSet:notDigits].location == NSNotFound)    &#123;      // 是数字    &#125; else    &#123;      // 不是数字    &#125;</div></pre></td></tr></table></figure>
<h3 id="16、将一个view保存为pdf格式"><a href="#16、将一个view保存为pdf格式" class="headerlink" title="16、将一个view保存为pdf格式"></a>16、将一个view保存为pdf格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)createPDFfromUIView:(UIView*)aView saveToDocumentsWithFileName:(NSString*)aFilename&#123;    NSMutableData *pdfData = [NSMutableData data];    UIGraphicsBeginPDFContextToData(pdfData, aView.bounds, nil);    UIGraphicsBeginPDFPage();    CGContextRef pdfContext = UIGraphicsGetCurrentContext();    [aView.layer renderInContext:pdfContext];    UIGraphicsEndPDFContext();    NSArray* documentDirectories = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES);    NSString* documentDirectory = [documentDirectories objectAtIndex:0];    NSString* documentDirectoryFilename = [documentDirectory stringByAppendingPathComponent:aFilename];    [pdfData writeToFile:documentDirectoryFilename atomically:YES];    NSLog(@&quot;documentDirectoryFileName: %@&quot;,documentDirectoryFilename);&#125;</div></pre></td></tr></table></figure>
<h3 id="17、让一个view在父视图中心"><a href="#17、让一个view在父视图中心" class="headerlink" title="17、让一个view在父视图中心"></a>17、让一个view在父视图中心</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">child.center = [parent convertPoint:parent.center fromView:parent.superview];</div></pre></td></tr></table></figure>
<h3 id="18、获取当前导航控制器下前一个控制器"><a href="#18、获取当前导航控制器下前一个控制器" class="headerlink" title="18、获取当前导航控制器下前一个控制器"></a>18、获取当前导航控制器下前一个控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (UIViewController *)backViewController&#123;    NSInteger myIndex = [self.navigationController.viewControllers indexOfObject:self];    if ( myIndex != 0 &amp;&amp; myIndex != NSNotFound ) &#123;        return [self.navigationController.viewControllers objectAtIndex:myIndex-1];    &#125; else &#123;        return nil;    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="19、保存UIImage到本地"><a href="#19、保存UIImage到本地" class="headerlink" title="19、保存UIImage到本地"></a>19、保存UIImage到本地</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:@&quot;Image.png&quot;];[UIImagePNGRepresentation(image) writeToFile:filePath atomically:YES];</div></pre></td></tr></table></figure>
<h3 id="20、键盘上方增加工具栏"><a href="#20、键盘上方增加工具栏" class="headerlink" title="20、键盘上方增加工具栏"></a>20、键盘上方增加工具栏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIToolbar *keyboardDoneButtonView = [[UIToolbar alloc] init];[keyboardDoneButtonView sizeToFit];UIBarButtonItem *doneButton = [[UIBarButtonItem alloc] initWithTitle:@&quot;Done&quot;                                                               style:UIBarButtonItemStyleBordered target:self                                                              action:@selector(doneClicked:)];[keyboardDoneButtonView setItems:[NSArray arrayWithObjects:doneButton, nil]];txtField.inputAccessoryView = keyboardDoneButtonView;</div></pre></td></tr></table></figure>
<h3 id="21、copy一个view"><a href="#21、copy一个view" class="headerlink" title="21、copy一个view"></a>21、copy一个view</h3><blockquote>
<p>因为UIView没有实现copy协议，因此找不到copyWithZone方法，使用copy的时候导致崩溃<br>但是我们可以通过归档再解档实现copy，这相当于对视图进行了一次深拷贝，代码如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">id copyOfView = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:originalView]];</div></pre></td></tr></table></figure>
<h3 id="22、在image上绘制文字并生成新的image"><a href="#22、在image上绘制文字并生成新的image" class="headerlink" title="22、在image上绘制文字并生成新的image"></a>22、在image上绘制文字并生成新的image</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIFont *font = [UIFont boldSystemFontOfSize:12];    UIGraphicsBeginImageContext(image.size);    [image drawInRect:CGRectMake(0,0,image.size.width,image.size.height)];    CGRect rect = CGRectMake(point.x, point.y, image.size.width, image.size.height);    [[UIColor whiteColor] set];    [text drawInRect:CGRectIntegral(rect) withFont:font];     UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();</div></pre></td></tr></table></figure>
<h3 id="23、判断一个view是否为另一个view的子视图"><a href="#23、判断一个view是否为另一个view的子视图" class="headerlink" title="23、判断一个view是否为另一个view的子视图"></a>23、判断一个view是否为另一个view的子视图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 如果myView是self.view本身，也会返回yesBOOL isSubView = [myView isDescendantOfView:self.view];</div></pre></td></tr></table></figure>
<h3 id="24、判断一个字符串是否包含另一个字符串"><a href="#24、判断一个字符串是否包含另一个字符串" class="headerlink" title="24、判断一个字符串是否包含另一个字符串"></a>24、判断一个字符串是否包含另一个字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、这种方法只适用于iOS8之后，如果是配iOS8之前用方法二if ([str containsString:otherStr]) NSLog(@&quot;包含&quot;);// 方法二NSRange range = [str rangeOfString:otherStr];if (range.location != NSNotFound) NSLog(@&quot;包含&quot;);</div></pre></td></tr></table></figure>
<h3 id="25、UICollectionView自动滚动到某行"><a href="#25、UICollectionView自动滚动到某行" class="headerlink" title="25、UICollectionView自动滚动到某行"></a>25、UICollectionView自动滚动到某行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 重写viewDidLayoutSubviews方法-(void)viewDidLayoutSubviews &#123;   [super viewDidLayoutSubviews];   [self.collectionView scrollToItemAtIndexPath:indexPath atScrollPosition:UICollectionViewScrollPositionCenteredVertically animated:NO];&#125;</div></pre></td></tr></table></figure>
<h3 id="26、修改系统UIAlertController"><a href="#26、修改系统UIAlertController" class="headerlink" title="26、修改系统UIAlertController"></a>26、修改系统UIAlertController</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 但是据说这种方法会被App Store拒绝(慎用！)UIAlertController *alertVC = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:@&quot;&quot; preferredStyle:UIAlertControllerStyleActionSheet];    NSMutableAttributedString *hogan = [[NSMutableAttributedString alloc] initWithString:@&quot;我是一个大文本&quot;];    [hogan addAttribute:NSFontAttributeName                  value:[UIFont systemFontOfSize:30]                  range:NSMakeRange(4, 1)];    [hogan addAttribute:NSForegroundColorAttributeName                  value:[UIColor redColor]                  range:NSMakeRange(4, 1)];    [alertVC setValue:hogan forKey:@&quot;attributedTitle&quot;];    UIAlertAction *button = [UIAlertAction actionWithTitle:@&quot;Label text&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction *action)&#123; &#125;];    UIImage *accessoryImage = [UIImage imageNamed:@&quot;1&quot;];    [button setValue:accessoryImage forKey:@&quot;image&quot;];    [alertVC addAction:button];    [self presentViewController:alertVC animated:YES completion:nil];</div></pre></td></tr></table></figure>
<h3 id="27、判断某一行的cell是否已经显示"><a href="#27、判断某一行的cell是否已经显示" class="headerlink" title="27、判断某一行的cell是否已经显示"></a>27、判断某一行的cell是否已经显示</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGRect cellRect = [tableView rectForRowAtIndexPath:indexPath];BOOL completelyVisible = CGRectContainsRect(tableView.bounds, cellRect);</div></pre></td></tr></table></figure>
<h3 id="28、让导航控制器pop回指定的控制器"><a href="#28、让导航控制器pop回指定的控制器" class="headerlink" title="28、让导航控制器pop回指定的控制器"></a>28、让导航控制器pop回指定的控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSMutableArray *allViewControllers = [NSMutableArray arrayWithArray:[self.navigationController viewControllers]];for (UIViewController *aViewController in allViewControllers) &#123;    if ([aViewController isKindOfClass:[RequiredViewController class]]) &#123;        [self.navigationController popToViewController:aViewController animated:NO];    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="29、动画修改label上的文字"><a href="#29、动画修改label上的文字" class="headerlink" title="29、动画修改label上的文字"></a>29、动画修改label上的文字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一CATransition *animation = [CATransition animation];    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];    animation.type = kCATransitionFade;    animation.duration = 0.75;    [self.label.layer addAnimation:animation forKey:@&quot;kCATransitionFade&quot;];    self.label.text = @&quot;New&quot;;// 方法二[UIView transitionWithView:self.label                      duration:0.25f                       options:UIViewAnimationOptionTransitionCrossDissolve                    animations:^&#123;                        self.label.text = @&quot;Well done!&quot;;                    &#125; completion:nil];// 方法三[UIView animateWithDuration:1.0                     animations:^&#123;                         self.label.alpha = 0.0f;                         self.label.text = @&quot;newText&quot;;                         self.label.alpha = 1.0f;                     &#125;];</div></pre></td></tr></table></figure>
<h3 id="30、判断字典中是否包含某个key值"><a href="#30、判断字典中是否包含某个key值" class="headerlink" title="30、判断字典中是否包含某个key值"></a>30、判断字典中是否包含某个key值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if ([dic objectForKey:@&quot;yourKey&quot;]) &#123;    NSLog(@&quot;有这个值&quot;);&#125; else &#123;    NSLog(@&quot;没有这个值&quot;);&#125;</div></pre></td></tr></table></figure>
<h3 id="31、获取屏幕方向"><a href="#31、获取屏幕方向" class="headerlink" title="31、获取屏幕方向"></a>31、获取屏幕方向</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIInterfaceOrientation orientation = [UIApplication sharedApplication].statusBarOrientation;if(orientation == 0) //Default orientation     //默认else if(orientation == UIInterfaceOrientationPortrait)    //竖屏else if(orientation == UIInterfaceOrientationLandscapeLeft)    // 左横屏else if(orientation == UIInterfaceOrientationLandscapeRight)    //右横屏</div></pre></td></tr></table></figure>
<h3 id="32、设置UIImage的透明度"><a href="#32、设置UIImage的透明度" class="headerlink" title="32、设置UIImage的透明度"></a>32、设置UIImage的透明度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、添加UIImage分类- (UIImage *)imageByApplyingAlpha:(CGFloat) alpha &#123;    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);    CGContextRef ctx = UIGraphicsGetCurrentContext();    CGRect area = CGRectMake(0, 0, self.size.width, self.size.height);    CGContextScaleCTM(ctx, 1, -1);    CGContextTranslateCTM(ctx, 0, -area.size.height);    CGContextSetBlendMode(ctx, kCGBlendModeMultiply);    CGContextSetAlpha(ctx, alpha);    CGContextDrawImage(ctx, area, self.CGImage);    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();    UIGraphicsEndImageContext();    return newImage;&#125;// 方法二、如果没有奇葩需求，干脆用UIImageView设置透明度UIImageView *imageView = [[UIImageView alloc] initWithImage:[UIImage imageWithName:@&quot;yourImage&quot;]];imageView.alpha = 0.5;</div></pre></td></tr></table></figure>
<h3 id="33、Attempt-to-mutate-immutable-object-with-insertString-atIndex"><a href="#33、Attempt-to-mutate-immutable-object-with-insertString-atIndex" class="headerlink" title="33、Attempt to mutate immutable object with insertString:atIndex:"></a>33、Attempt to mutate immutable object with insertString:atIndex:</h3><blockquote>
<p>这个错是因为你拿字符串调用insertString:atIndex:方法的时候，调用对象不是NSMutableString，应该先转成这个类型再调用</p>
</blockquote>
<h3 id="34、UIWebView添加单击手势不响应"><a href="#34、UIWebView添加单击手势不响应" class="headerlink" title="34、UIWebView添加单击手势不响应"></a>34、UIWebView添加单击手势不响应</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(webViewClick)];        tap.delegate = self;        [_webView addGestureRecognizer:tap];// 因为webView本身有一个单击手势，所以再添加会造成手势冲突，从而不响应。需要绑定手势代理，并实现下边的代理方法- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer&#123;    return YES;&#125;</div></pre></td></tr></table></figure>
<h3 id="35、获取手机RAM容量"><a href="#35、获取手机RAM容量" class="headerlink" title="35、获取手机RAM容量"></a>35、获取手机RAM容量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 需要导入#import &lt;mach/mach.h&gt;mach_port_t host_port;    mach_msg_type_number_t host_size;    vm_size_t pagesize;    host_port = mach_host_self();    host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);    host_page_size(host_port, &amp;pagesize);    vm_statistics_data_t vm_stat;    if (host_statistics(host_port, HOST_VM_INFO, (host_info_t)&amp;vm_stat, &amp;host_size) != KERN_SUCCESS) &#123;        NSLog(@&quot;Failed to fetch vm statistics&quot;);    &#125;    /* Stats in bytes */    natural_t mem_used = (vm_stat.active_count +                          vm_stat.inactive_count +                          vm_stat.wire_count) * pagesize;    natural_t mem_free = vm_stat.free_count * pagesize;    natural_t mem_total = mem_used + mem_free;    NSLog(@&quot;已用: %u 可用: %u 总共: %u&quot;, mem_used, mem_free, mem_total);</div></pre></td></tr></table></figure>
<h3 id="36、地图上两个点之间的实际距离"><a href="#36、地图上两个点之间的实际距离" class="headerlink" title="36、地图上两个点之间的实际距离"></a>36、地图上两个点之间的实际距离</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 需要导入#import &lt;CoreLocation/CoreLocation.h&gt;CLLocation *locA = [[CLLocation alloc] initWithLatitude:34 longitude:113];    CLLocation *locB = [[CLLocation alloc] initWithLatitude:31.05 longitude:121.76];// CLLocationDistance求出的单位为米    CLLocationDistance distance = [locA distanceFromLocation:locB];</div></pre></td></tr></table></figure>
<h3 id="37、在应用中打开设置的某个界面"><a href="#37、在应用中打开设置的某个界面" class="headerlink" title="37、在应用中打开设置的某个界面"></a>37、在应用中打开设置的某个界面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 打开设置-&gt;通用[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&quot;prefs:root=General&quot;]];// 以下是设置其他界面prefs:root=General&amp;path=Aboutprefs:root=General&amp;path=ACCESSIBILITYprefs:root=AIRPLANE_MODEprefs:root=General&amp;path=AUTOLOCKprefs:root=General&amp;path=USAGE/CELLULAR_USAGEprefs:root=Brightnessprefs:root=Bluetoothprefs:root=General&amp;path=DATE_AND_TIMEprefs:root=FACETIMEprefs:root=Generalprefs:root=General&amp;path=Keyboardprefs:root=CASTLEprefs:root=CASTLE&amp;path=STORAGE_AND_BACKUPprefs:root=General&amp;path=INTERNATIONALprefs:root=LOCATION_SERVICESprefs:root=ACCOUNT_SETTINGSprefs:root=MUSICprefs:root=MUSIC&amp;path=EQprefs:root=MUSIC&amp;path=VolumeLimitprefs:root=General&amp;path=Networkprefs:root=NIKE_PLUS_IPODprefs:root=NOTESprefs:root=NOTIFICATIONS_IDprefs:root=Phoneprefs:root=Photosprefs:root=General&amp;path=ManagedConfigurationListprefs:root=General&amp;path=Resetprefs:root=Sounds&amp;path=Ringtoneprefs:root=Safariprefs:root=General&amp;path=Assistantprefs:root=Soundsprefs:root=General&amp;path=SOFTWARE_UPDATE_LINKprefs:root=STOREprefs:root=TWITTERprefs:root=FACEBOOKprefs:root=General&amp;path=USAGE prefs:root=VIDEOprefs:root=General&amp;path=Network/VPNprefs:root=Wallpaperprefs:root=WIFIprefs:root=INTERNET_TETHERINGprefs:root=Phone&amp;path=Blockedprefs:root=DO_NOT_DISTURB</div></pre></td></tr></table></figure>
<h3 id="38、在UITextView中显示html文本"><a href="#38、在UITextView中显示html文本" class="headerlink" title="38、在UITextView中显示html文本"></a>38、在UITextView中显示html文本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UITextView *textView = [[UITextView alloc] initWithFrame:CGRectMake(20, 30, 100, 199)];    textView.backgroundColor = [UIColor redColor];    [self.view addSubview:textView];    NSString *htmlString = @&quot;&lt;h1&gt;Header&lt;/h1&gt;&lt;h2&gt;Subheader&lt;/h2&gt;&lt;p&gt;Some &lt;em&gt;text&lt;/em&gt;&lt;/p&gt;![](http://blogs.babble.com/famecrawler/files/2010/11/mickey_mouse-1097.jpg)&quot;;    NSAttributedString *attributedString = [[NSAttributedString alloc] initWithData: [htmlString dataUsingEncoding:NSUnicodeStringEncoding] options: @&#123; NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType &#125; documentAttributes: nil error: nil];    textView.attributedText = attributedString;</div></pre></td></tr></table></figure>
<h3 id="39、监听scrollView是否滚动到了顶部／底部"><a href="#39、监听scrollView是否滚动到了顶部／底部" class="headerlink" title="39、监听scrollView是否滚动到了顶部／底部"></a>39、监听scrollView是否滚动到了顶部／底部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-(void)scrollViewDidScroll: (UIScrollView*)scrollView&#123;    float scrollViewHeight = scrollView.frame.size.height;    float scrollContentSizeHeight = scrollView.contentSize.height;    float scrollOffset = scrollView.contentOffset.y;    if (scrollOffset == 0)    &#123;        // 滚动到了顶部    &#125;    else if (scrollOffset + scrollViewHeight == scrollContentSizeHeight)    &#123;        // 滚动到了底部    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="40、UISlider增量／减量为固定值-假如为5"><a href="#40、UISlider增量／减量为固定值-假如为5" class="headerlink" title="40、UISlider增量／减量为固定值(假如为5)"></a>40、UISlider增量／减量为固定值(假如为5)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)setupSlider&#123;    UISlider *slider = [[UISlider alloc] init];    [self.view addSubview:slider];    [slider addTarget:self action:@selector(sliderAction:) forControlEvents:UIControlEventValueChanged];    slider.maximumValue = 100;    slider.minimumValue = 0;    slider.frame = CGRectMake(200, 20, 100, 30);&#125;- (void)sliderAction:(UISlider *)slider&#123;    [slider setValue:((int)((slider.value + 2.5) / 5) * 5) animated:NO];&#125;</div></pre></td></tr></table></figure>
<h3 id="41、选中textField或者textView所有文本-我这里以textView为例"><a href="#41、选中textField或者textView所有文本-我这里以textView为例" class="headerlink" title="41、选中textField或者textView所有文本(我这里以textView为例)"></a>41、选中textField或者textView所有文本(我这里以textView为例)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.textView setSelectedTextRange:[self.textView textRangeFromPosition:self.textView.beginningOfDocument toPosition:self.textView.endOfDocument]]</div></pre></td></tr></table></figure>
<h3 id="42、从导航控制器中删除某个控制器"><a href="#42、从导航控制器中删除某个控制器" class="headerlink" title="42、从导航控制器中删除某个控制器"></a>42、从导航控制器中删除某个控制器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一、知道这个控制器所处的导航控制器下标NSMutableArray *navigationArray = [[NSMutableArray alloc] initWithArray: self.navigationController.viewControllers];[navigationArray removeObjectAtIndex: 2]; self.navigationController.viewControllers = navigationArray;// 方法二、知道具体是哪个控制器NSArray* tempVCA = [self.navigationController viewControllers];for(UIViewController *tempVC in tempVCA)&#123;    if([tempVC isKindOfClass:[urViewControllerClass class]])    &#123;        [tempVC removeFromParentViewController];    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="43、隐藏UITextView-UITextField光标"><a href="#43、隐藏UITextView-UITextField光标" class="headerlink" title="43、隐藏UITextView/UITextField光标"></a>43、隐藏UITextView/UITextField光标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textField.tintColor = [UIColor clearColor];</div></pre></td></tr></table></figure>
<h3 id="44、当UITextView-UITextField中没有文字时，禁用回车键"><a href="#44、当UITextView-UITextField中没有文字时，禁用回车键" class="headerlink" title="44、当UITextView/UITextField中没有文字时，禁用回车键"></a>44、当UITextView/UITextField中没有文字时，禁用回车键</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">textField.enablesReturnKeyAutomatically = YES;</div></pre></td></tr></table></figure>
<h3 id="45、字符串encode编码-编码url字符串不成功的问题"><a href="#45、字符串encode编码-编码url字符串不成功的问题" class="headerlink" title="45、字符串encode编码(编码url字符串不成功的问题)"></a>45、字符串encode编码(编码url字符串不成功的问题)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 我们一般用这个方法处理stringByAddingPercentEscapesUsingEncoding但是这个方法好想不会处理／和&amp;这种特殊符号，这种情况就需要用下边这个方法处理@implementation NSString (NSString_Extended)- (NSString *)urlencode &#123;    NSMutableString *output = [NSMutableString string];    const unsigned char *source = (const unsigned char *)[self UTF8String];    int sourceLen = strlen((const char *)source);    for (int i = 0; i &lt; sourceLen; ++i) &#123;        const unsigned char thisChar = source[i];        if (thisChar == &apos; &apos;)&#123;            [output appendString:@&quot;+&quot;];        &#125; else if (thisChar == &apos;.&apos; || thisChar == &apos;-&apos; || thisChar == &apos;_&apos; || thisChar == &apos;~&apos; ||                    (thisChar &gt;= &apos;a&apos; &amp;&amp; thisChar &lt;= &apos;z&apos;) ||                   (thisChar &gt;= &apos;A&apos; &amp;&amp; thisChar &lt;= &apos;Z&apos;) ||                   (thisChar &gt;= &apos;0&apos; &amp;&amp; thisChar &lt;= &apos;9&apos;)) &#123;            [output appendFormat:@&quot;%c&quot;, thisChar];        &#125; else &#123;            [output appendFormat:@&quot;%%%02X&quot;, thisChar];        &#125;    &#125;    return output;&#125;</div></pre></td></tr></table></figure>
<h3 id="46、计算UILabel上某段文字的frame"><a href="#46、计算UILabel上某段文字的frame" class="headerlink" title="46、计算UILabel上某段文字的frame"></a>46、计算UILabel上某段文字的frame</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@implementation UILabel (TextRect)- (CGRect)boundingRectForCharacterRange:(NSRange)range&#123;    NSTextStorage *textStorage = [[NSTextStorage alloc] initWithAttributedString:[self attributedText]];    NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init];    [textStorage addLayoutManager:layoutManager];    NSTextContainer *textContainer = [[NSTextContainer alloc] initWithSize:[self bounds].size];    textContainer.lineFragmentPadding = 0;    [layoutManager addTextContainer:textContainer];    NSRange glyphRange;    [layoutManager characterRangeForGlyphRange:range actualGlyphRange:&amp;glyphRange];    return [layoutManager boundingRectForGlyphRange:glyphRange inTextContainer:textContainer];&#125;</div></pre></td></tr></table></figure>
<h3 id="47、获取随机UUID"><a href="#47、获取随机UUID" class="headerlink" title="47、获取随机UUID"></a>47、获取随机UUID</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *result;    if([[[UIDevice currentDevice] systemVersion] floatValue] &gt; 6.0)    &#123;       result = [[NSUUID UUID] UUIDString];    &#125;    else    &#123;        CFUUIDRef uuidRef = CFUUIDCreate(NULL);        CFStringRef uuid = CFUUIDCreateString(NULL, uuidRef);        CFRelease(uuidRef);        result = (__bridge_transfer NSString *)uuid;    &#125;</div></pre></td></tr></table></figure>
<h3 id="48、仿苹果抖动动画"><a href="#48、仿苹果抖动动画" class="headerlink" title="48、仿苹果抖动动画"></a>48、仿苹果抖动动画</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define RADIANS(degrees) (((degrees) * M_PI) / 180.0)- (void)startAnimate &#123;    view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(-5));    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionRepeat | UIViewAnimationOptionAutoreverse) animations:^ &#123;                         view.transform = CGAffineTransformRotate(CGAffineTransformIdentity, RADIANS(5));                     &#125; completion:nil];&#125;- (void)stopAnimate &#123;    [UIView animateWithDuration:0.25 delay:0.0 options:(UIViewAnimationOptionAllowUserInteraction | UIViewAnimationOptionBeginFromCurrentState | UIViewAnimationOptionCurveLinear) animations:^ &#123;                         view.transform = CGAffineTransformIdentity;                     &#125; completion:nil];&#125;</div></pre></td></tr></table></figure>
<h3 id="49、修改UISearBar内部背景颜色"><a href="#49、修改UISearBar内部背景颜色" class="headerlink" title="49、修改UISearBar内部背景颜色"></a>49、修改UISearBar内部背景颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UITextField *textField = [_searchBar valueForKey:@&quot;_searchField&quot;];textField.backgroundColor = [UIColor redColor];</div></pre></td></tr></table></figure>
<h3 id="50、UITextView滚动到顶部"><a href="#50、UITextView滚动到顶部" class="headerlink" title="50、UITextView滚动到顶部"></a>50、UITextView滚动到顶部</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 方法一    [self.textView scrollRangeToVisible:NSMakeRange(0, 0)];    // 方法二    [self.textView setContentOffset:CGPointZero animated:YES];</div></pre></td></tr></table></figure>
<h3 id="51、通知监听APP生命周期"><a href="#51、通知监听APP生命周期" class="headerlink" title="51、通知监听APP生命周期"></a>51、通知监听APP生命周期</h3><blockquote>
<p>UIApplicationDidEnterBackgroundNotification 应用程序进入后台<br>UIApplicationWillEnterForegroundNotification 应用程序将要进入前台<br>UIApplicationDidFinishLaunchingNotification 应用程序完成启动<br>UIApplicationDidFinishLaunchingNotification 应用程序由挂起变的活跃<br>UIApplicationWillResignActiveNotification 应用程序挂起(有电话进来或者锁屏)<br>UIApplicationDidReceiveMemoryWarningNotification 应用程序收到内存警告<br>UIApplicationDidReceiveMemoryWarningNotification 应用程序终止(后台杀死、手机关机等)<br>UIApplicationSignificantTimeChangeNotification 当有重大时间改变(凌晨0点，设备时间被修改，时区改变等)<br>UIApplicationWillChangeStatusBarOrientationNotification 设备方向将要改变<br>UIApplicationDidChangeStatusBarOrientationNotification 设备方向改变<br>UIApplicationWillChangeStatusBarFrameNotification 设备状态栏frame将要改变<br>UIApplicationDidChangeStatusBarFrameNotification 设备状态栏frame改变<br>UIApplicationBackgroundRefreshStatusDidChangeNotification 应用程序在后台下载内容的状态发生变化<br>UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件被锁定,无法访问<br>UIApplicationProtectedDataWillBecomeUnavailable 本地受保护的文件可用了</p>
</blockquote>
<h3 id="52、触摸事件类型"><a href="#52、触摸事件类型" class="headerlink" title="52、触摸事件类型"></a>52、触摸事件类型</h3><blockquote>
<p>UIControlEventTouchCancel 取消控件当前触发的事件<br>UIControlEventTouchDown 点按下去的事件<br>UIControlEventTouchDownRepeat 重复的触动事件<br>UIControlEventTouchDragEnter 手指被拖动到控件的边界的事件<br>UIControlEventTouchDragExit 一个手指从控件内拖到外界的事件<br>UIControlEventTouchDragInside 手指在控件的边界内拖动的事件<br>UIControlEventTouchDragOutside 手指在控件边界之外被拖动的事件<br>UIControlEventTouchUpInside 手指处于控制范围内的触摸事件<br>UIControlEventTouchUpOutside 手指超出控制范围的控制中的触摸事件</p>
</blockquote>
<h3 id="53、UITextField文字周围增加边距"><a href="#53、UITextField文字周围增加边距" class="headerlink" title="53、UITextField文字周围增加边距"></a>53、UITextField文字周围增加边距</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 子类化UITextField，增加insert属性@interface WZBTextField : UITextField@property (nonatomic, assign) UIEdgeInsets insets;@end// 在.m文件重写下列方法- (CGRect)textRectForBounds:(CGRect)bounds &#123;    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) &#123;        return [self adjustRectWithWidthRightView:paddedRect];    &#125;    return paddedRect;&#125;- (CGRect)placeholderRectForBounds:(CGRect)bounds &#123;    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeUnlessEditing) &#123;        return [self adjustRectWithWidthRightView:paddedRect];    &#125;    return paddedRect;&#125;- (CGRect)editingRectForBounds:(CGRect)bounds &#123;    CGRect paddedRect = UIEdgeInsetsInsetRect(bounds, self.insets);    if (self.rightViewMode == UITextFieldViewModeAlways || self.rightViewMode == UITextFieldViewModeWhileEditing) &#123;        return [self adjustRectWithWidthRightView:paddedRect];    &#125;    return paddedRect;&#125;- (CGRect)adjustRectWithWidthRightView:(CGRect)bounds &#123;    CGRect paddedRect = bounds;    paddedRect.size.width -= CGRectGetWidth(self.rightView.frame);    return paddedRect;&#125;</div></pre></td></tr></table></figure>
<h3 id="54、监听UISlider拖动状态"><a href="#54、监听UISlider拖动状态" class="headerlink" title="54、监听UISlider拖动状态"></a>54、监听UISlider拖动状态</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// 添加事件[slider addTarget:self action:@selector(sliderValurChanged:forEvent:) forControlEvents:UIControlEventValueChanged];// 实现方法- (void)sliderValurChanged:(UISlider*)slider forEvent:(UIEvent*)event &#123;    UITouch *touchEvent = [[event allTouches] anyObject];    switch (touchEvent.phase) &#123;        case UITouchPhaseBegan:            NSLog(@&quot;开始拖动&quot;);            break;        case UITouchPhaseMoved:            NSLog(@&quot;正在拖动&quot;);            break;        case UITouchPhaseEnded:            NSLog(@&quot;结束拖动&quot;);            break;        default:            break;    &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="55、设置UITextField光标位置"><a href="#55、设置UITextField光标位置" class="headerlink" title="55、设置UITextField光标位置"></a>55、设置UITextField光标位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">// textField需要设置的textField，index要设置的光标位置- (void)cursorLocation:(UITextField *)textField index:(NSInteger)index&#123;    NSRange range = NSMakeRange(index, 0);    UITextPosition *start = [textField positionFromPosition:[textField beginningOfDocument] offset:range.location];    UITextPosition *end = [textField positionFromPosition:start offset:range.length];    [textField setSelectedTextRange:[textField textRangeFromPosition:start toPosition:end]];&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> iOS小知识代码段 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS小知识 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS工程师面试知识点集锦]]></title>
      <url>/2016/04/12/blog_guide/</url>
      <content type="html"><![CDATA[<p>俗话说的好,金三银四.转眼到了招工作的旺季,笔者总结了些iOS面试的提纲,希望读客们看到了会对你的工作和以后学习方向有帮助……<br><a id="more"></a><br>直接上图<br><img src="http://upload-images.jianshu.io/upload_images/1853274-f938e42bd0b1c7f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>不知道看完你有什么感受，如果觉得自己在某方面不足的话，那就要抓紧时间迎头赶上哦，毕竟，竞争激烈嘛(大佬请自便,哈哈)……</p>
]]></content>
      
        <categories>
            
            <category> iOS面试知识点集锦 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 面试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[GitHubPages + Hexo 搭建个人博客]]></title>
      <url>/2016/03/22/blog_aboutHexo/</url>
      <content type="html"><![CDATA[<p>首先:GitHubPages是什么？<br>GitHubPages可以认为是个人用户编写的并且上传到github的网页文件<br>其次,为什么采用GitHubPages搭建？<br>300M的免费空间,众多大牛的聚集地,趋势所向,赶紧行动起来吧,跟着我一起搭建属于自己的博客!<br><a id="more"></a></p>
<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>地址:<a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="external">http://www.runoob.com/nodejs/nodejs-install-setup.html</a></p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>下载地址:<a href="http://git-scm.com/download/" target="_blank" rel="external">http://git-scm.com/download/</a></p>
<p>以下步骤也可以按照Hexo的官方文档来进行<br>地址：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">https://hexo.io/zh-cn/docs/index.html</a></p>
<p>你的系统需要支持Node和Git哦……</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>选定需要安装的文件夹 比如我们选择D:\Hexo目录<br>打开终端命令行如下:<br>$ cd D:/Hexo<br>$ npm install hexo-cli -g<br>$ hexo init blog #blog为你指定的新建文件的文件夹<br>$ cd blog<br>$ npm install<br>$ hexo g # 或者hexo generate<br>$ hexo s # 或者hexo server，可以在<a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 查看</p>
<p>Hexo常用命令<br>hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹 简写 hexo g<br>hexo server (hexo s) 启动本地web服务，用于博客的预览 简写 hexo s<br>hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台） 简写 hexo d<br>hexo new “postName” #新建文章 简写 hexo n<br>hexo new page “pageName” #新建页面</p>
<p>组合命令<br>hexo d -g #生成部署<br>hexo s -g #生成预览</p>
<p>此时我们cd到Hexo文件夹目录下 使用以下命令<br>hexo clean<br>hexo g<br>hexo s</p>
<p>然后看到提示启动本地服务成功即可打开浏览器 输入网址 <a href="http://localhost:4000/" target="_blank" rel="external">http://localhost:4000/</a> 进行访问<br>Hexo默认的主题是landscape画风如下</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1853274-eb070a3f8aafa918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<h3 id="开始写文章"><a href="#开始写文章" class="headerlink" title="开始写文章"></a>开始写文章</h3><p>新建一个文件 我们在终端里 进入到\blog\source目录 执行hexo new [layout] “postName” #新建文章 即可 这里需要注意的是其中layout是可选参数，默认值为post 我们可以到本地的scaffolds下查看<br>默认为<br>title: GitHubPages + Hexo 搭建个人博客 # 文章标题名称<br>date: 1458576000000 #文章生成时间，可随意更改</p>
<h2 id="tags-文章标签"><a href="#tags-文章标签" class="headerlink" title="tags: #文章标签"></a>tags: #文章标签</h2><p>注意：所有文件后都必须要有空格哦，不然执行hexo g 就会报错</p>
<p>可能你会认为接下来的书写效率较低　那么笔者推荐你使用MarkDown书写工具 比如<a href="https://github.com/atom/atom" target="_blank" rel="external">Atom</a> 或者<a href="http://www.jetbrains.com/idea/" target="_blank" rel="external">IntelliJ IDEA</a> 笔者下面采用Atom示例</p>
<p>打开Atom 选择Add Project Folder 将本地的Hexo目录打开即可<br><img src="http://upload-images.jianshu.io/upload_images/1853274-50ffe92ab7aae792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"><br>看起来是不是方面很多 关于书写MarkDown的语法可以参考<a href="http://wowubuntu.com/markdown/#link" target="_blank" rel="external">《Markdown 语法说明》</a></p>
<h3 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h3><p>Hexo 提供了较多的主题供我们选择 <a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo主题地址</a> 例如 Next Jacman yelee都是很不错的主题<br>比如yelee主题<br><img src="http://upload-images.jianshu.io/upload_images/1853274-c4223cdc42ce1719.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt text"></p>
<p>步骤如下：<br>（1）进入到本地Hexo的themes目录 使用git clone <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="external">https://github.com/MOxFIVE/hexo-theme-yelee</a> 即可<br> (2)在（1）完成的基础上 我们进入到下面的文件里进行如下操作<br> <img src="http://upload-images.jianshu.io/upload_images/1853274-7d0fc004d1cb4d43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Alt Text"><br> （3）进行其他的配置可以<a href="http://moxfive.xyz/yelee/new-features.html" target="_blank" rel="external">点此进入</a> ,若是想更新主题 直接在themes目录下 使用git pull + 对应的主题在GitHub上的地址即可</p>
<h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>建议采用 <a href="https://www.qiniu.com/" target="_blank" rel="external">七牛云</a> 访问速度快，支持日志、防盗链和水印,免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求,个人用户还不是妥妥的</p>
<h3 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h3><p>到这里目前来看我们搭建的博客地址都是以.github.io结尾 如果你感觉这个二级域名不爽 你也可以去申请一个自己的域名 <a href="http://upload-images.jianshu.io/upload_images/1853274-b989327d0f3690cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" target="_blank" rel="external">阿里云</a></p>
<p>接着，在repo根目录下建立一个CNAME文件，里面写上域名即可</p>
<p>到此 GitHubPages + Hexo 搭建个人博客就介绍完毕了</p>
]]></content>
      
        <categories>
            
            <category> Hexo搭建 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> GitHubPages </tag>
            
            <tag> Hexo </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
